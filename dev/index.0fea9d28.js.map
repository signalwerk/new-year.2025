{"mappings":"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","sources":["<anon>","src/index.js"],"sourcesContent":["var $35da740d59af89ba$exports = {};\n// Game constants\nconst $35da740d59af89ba$var$GAME_WIDTH = 360; // Base width, will be scaled\nconst $35da740d59af89ba$var$GAME_HEIGHT = 640; // 16:9 ratio\nconst $35da740d59af89ba$var$LANES = 6;\nconst $35da740d59af89ba$var$PADDING_TOP = 80; // More space for score/level\nconst $35da740d59af89ba$var$PADDING_BOTTOM = 100; // More space for controls/UI\nconst $35da740d59af89ba$var$PADDING_LEFT = 80;\nconst $35da740d59af89ba$var$PADDING_RIGHT = 40;\n// Game area calculations\nconst $35da740d59af89ba$var$GAME_AREA_WIDTH = $35da740d59af89ba$var$GAME_WIDTH - ($35da740d59af89ba$var$PADDING_LEFT + $35da740d59af89ba$var$PADDING_RIGHT);\nconst $35da740d59af89ba$var$GAME_AREA_HEIGHT = $35da740d59af89ba$var$GAME_HEIGHT - ($35da740d59af89ba$var$PADDING_TOP + $35da740d59af89ba$var$PADDING_BOTTOM);\nconst $35da740d59af89ba$var$LANE_WIDTH = $35da740d59af89ba$var$GAME_AREA_WIDTH / $35da740d59af89ba$var$LANES; // Width of each lane\nconst $35da740d59af89ba$var$SPOT_SIZE = $35da740d59af89ba$var$LANE_WIDTH; // Defense spots are same width as lanes\nconst $35da740d59af89ba$var$GRID_ROWS = Math.floor($35da740d59af89ba$var$GAME_AREA_HEIGHT / $35da740d59af89ba$var$SPOT_SIZE);\n// Add to game constants\nconst $35da740d59af89ba$var$DEBUG = true; // Toggle for development visualization\n// Add to game constants\nconst $35da740d59af89ba$var$LEVELS = [\n    {\n        name: \"Level 1\",\n        duration: 30000,\n        waves: [\n            {\n                type: 0,\n                count: 3,\n                startTime: 1000,\n                spacing: 1000\n            },\n            {\n                type: 0,\n                count: 5,\n                startTime: 8000,\n                spacing: 800\n            },\n            {\n                type: 1,\n                count: 2,\n                startTime: 15000,\n                spacing: 2000\n            },\n            {\n                type: 0,\n                count: 4,\n                startTime: 20000,\n                spacing: 500\n            },\n            {\n                type: 1,\n                count: 3,\n                startTime: 25000,\n                spacing: 1500\n            }\n        ]\n    },\n    {\n        name: \"Level 2\",\n        duration: 45000,\n        waves: [\n            {\n                type: 1,\n                count: 3,\n                startTime: 2000,\n                spacing: 1200\n            },\n            {\n                type: 0,\n                count: 6,\n                startTime: 10000,\n                spacing: 400\n            },\n            {\n                type: 2,\n                count: 1,\n                startTime: 18000,\n                spacing: 0\n            },\n            {\n                type: 1,\n                count: 4,\n                startTime: 25000,\n                spacing: 1000\n            },\n            {\n                type: 2,\n                count: 2,\n                startTime: 35000,\n                spacing: 2000\n            },\n            {\n                type: 0,\n                count: 8,\n                startTime: 40000,\n                spacing: 300\n            }\n        ]\n    }\n];\nconst $35da740d59af89ba$var$GAME_STATES = {\n    MENU: \"menu\",\n    PLAYING: \"playing\",\n    LEVEL_COMPLETE: \"levelComplete\",\n    GAME_OVER: \"gameover\",\n    GAME_COMPLETE: \"gameComplete\"\n};\n// Add to game constants\nconst $35da740d59af89ba$var$DEFENSE_TYPES = [\n    {\n        id: 0,\n        name: \"Basic\",\n        color: \"#4CAF50\",\n        cost: 100,\n        damage: 10,\n        health: 100\n    },\n    {\n        id: 1,\n        name: \"Medium\",\n        color: \"#2196F3\",\n        cost: 200,\n        damage: 20,\n        health: 100\n    },\n    {\n        id: 2,\n        name: \"Strong\",\n        color: \"#9C27B0\",\n        cost: 300,\n        damage: 30,\n        health: 100\n    }\n];\n// Add to game constants\nconst $35da740d59af89ba$var$METEOR_TYPES = [\n    {\n        id: 0,\n        name: \"Small\",\n        color: \"#FF9999\",\n        health: 30,\n        speed: 0.05,\n        damageRate: 30\n    },\n    {\n        id: 1,\n        name: \"Medium\",\n        color: \"#FF4444\",\n        health: 60,\n        speed: 0.02,\n        damageRate: 50\n    },\n    {\n        id: 2,\n        name: \"Large\",\n        color: \"#FF0000\",\n        health: 90,\n        speed: 0.08,\n        damageRate: 50\n    }\n];\n// Font definitions\nconst $35da740d59af89ba$var$FONT = {\n    SMALL: {\n        size: \"12px\",\n        family: \"Arial\",\n        get full () {\n            return `${this.size} ${this.family}`;\n        }\n    },\n    LARGE: {\n        size: \"14px\",\n        family: \"Arial\",\n        get full () {\n            return `${this.size} ${this.family}`;\n        }\n    }\n};\n// Test meteor\nclass $35da740d59af89ba$var$Meteor {\n    constructor(lane, type = $35da740d59af89ba$var$METEOR_TYPES[0]){\n        // Default to weakest type\n        this.lane = lane;\n        this.type = type;\n        this.y = $35da740d59af89ba$var$PADDING_TOP;\n        this.health = type.health;\n        this.speed = type.speed;\n        this.isBlocked = false; // New property to track if meteor is blocked by defense\n        this.blockingDefense = null; // Reference to blocking defense\n    }\n    update(deltaTime) {\n        if (!this.isBlocked) this.y += this.speed * deltaTime;\n    }\n    block(defense) {\n        this.isBlocked = true;\n        this.blockingDefense = defense;\n    }\n    unblock() {\n        this.isBlocked = false;\n        this.blockingDefense = null;\n    }\n    draw(ctx) {\n        const x = $35da740d59af89ba$var$PADDING_LEFT + this.lane * $35da740d59af89ba$var$LANE_WIDTH + $35da740d59af89ba$var$LANE_WIDTH / 2;\n        ctx.fillStyle = this.type.color;\n        ctx.beginPath();\n        ctx.arc(x, this.y, 10, 0, Math.PI * 2);\n        ctx.fill();\n        if ($35da740d59af89ba$var$DEBUG) {\n            // Draw collision circle\n            ctx.strokeStyle = \"rgba(255,0,0,0.3)\";\n            ctx.beginPath();\n            ctx.arc(x, this.y, 10, 0, Math.PI * 2);\n            ctx.stroke();\n            // Draw health\n            ctx.fillStyle = \"white\";\n            ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n            ctx.textAlign = \"center\";\n            ctx.fillText(`${this.health}`, x, this.y);\n        }\n    }\n    takeDamage(damage) {\n        this.health -= damage;\n        return this.health <= 0;\n    }\n}\n// Add to existing constants\nclass $35da740d59af89ba$var$Button {\n    constructor(x, y, width, height, text, backgroundColor = \"#444\", textColor = \"white\", fontSize = 16){\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.text = text;\n        this.backgroundColor = backgroundColor;\n        this.textColor = textColor;\n        this.fontSize = fontSize;\n    }\n    isClicked(clickX, clickY) {\n        return clickX >= this.x && clickX <= this.x + this.width && clickY >= this.y && clickY <= this.y + this.height;\n    }\n    draw(ctx) {\n        // Draw button background\n        ctx.fillStyle = this.backgroundColor;\n        ctx.fillRect(this.x, this.y, this.width, this.height);\n        // Draw button text\n        ctx.fillStyle = this.textColor;\n        ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height / 2);\n    }\n}\nclass $35da740d59af89ba$var$Projectile {\n    constructor(x, y, damage){\n        this.x = x;\n        this.y = y;\n        this.speed = 0.3;\n        this.damage = damage;\n        this.size = 4;\n    }\n    update(deltaTime) {\n        this.y -= this.speed * deltaTime;\n    }\n    draw(ctx) {\n        ctx.fillStyle = \"yellow\";\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n        ctx.fill();\n        if ($35da740d59af89ba$var$DEBUG) {\n            // Draw collision circle\n            ctx.strokeStyle = \"rgba(255,255,0,0.3)\";\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n            ctx.stroke();\n        }\n    }\n    checkCollision(meteor) {\n        const meteorX = $35da740d59af89ba$var$PADDING_LEFT + meteor.lane * $35da740d59af89ba$var$LANE_WIDTH + $35da740d59af89ba$var$LANE_WIDTH / 2;\n        const dx = this.x - meteorX;\n        const dy = this.y - meteor.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        return distance < this.size + 10; // 10 is meteor radius\n    }\n    isOffScreen() {\n        return this.y < $35da740d59af89ba$var$PADDING_TOP;\n    }\n}\n// Add to game constants\nclass $35da740d59af89ba$var$Defense {\n    constructor(type = null){\n        this.type = type;\n        this.health = type ? type.health : 0;\n        this.maxHealth = type ? type.health : 0;\n        this.projectiles = [];\n        this.lastFireTime = 0;\n        this.fireRate = 1000;\n        this.blockingMeteors = []; // Add array to track blocked meteors\n    }\n    isEmpty() {\n        return this.type === null;\n    }\n    takeDamage(amount) {\n        this.health -= amount;\n        return this.health <= 0;\n    }\n    update(currentTime, x, y, meteors, coins) {\n        if (!this.isEmpty()) {\n            // Fire projectile if enough time has passed\n            if (currentTime - this.lastFireTime > this.fireRate) {\n                this.projectiles.push(new $35da740d59af89ba$var$Projectile(x, y, this.type.damage));\n                this.lastFireTime = currentTime;\n            }\n            // Check for meteor collisions with this defense\n            const defenseRow = Math.floor((y - $35da740d59af89ba$var$PADDING_TOP) / $35da740d59af89ba$var$SPOT_SIZE);\n            meteors.forEach((meteor)=>{\n                const meteorRow = Math.floor((meteor.y - $35da740d59af89ba$var$PADDING_TOP) / $35da740d59af89ba$var$SPOT_SIZE);\n                if (meteorRow === defenseRow && meteor.lane === Math.floor((x - $35da740d59af89ba$var$PADDING_LEFT) / $35da740d59af89ba$var$LANE_WIDTH)) {\n                    // Block meteor if not already blocked\n                    if (!meteor.isBlocked) {\n                        meteor.block(this);\n                        this.blockingMeteors.push(meteor); // Track this meteor\n                    }\n                    // Take damage from meteor using meteor's damage rate\n                    if (meteor.blockingDefense === this) {\n                        const destroyed = this.takeDamage(meteor.type.damageRate / 60);\n                        if (destroyed) {\n                            // Unblock all meteors this defense was blocking\n                            this.blockingMeteors.forEach((m)=>m.unblock());\n                            this.blockingMeteors = [];\n                            this.type = null; // Reset defense when destroyed\n                            this.health = 0;\n                            this.maxHealth = 0;\n                        }\n                    }\n                }\n            });\n            // Update existing projectiles and check collisions\n            this.projectiles = this.projectiles.filter((projectile)=>{\n                projectile.update(16);\n                // Check for collisions with any meteor\n                for(let i = 0; i < meteors.length; i++){\n                    const meteor = meteors[i];\n                    if (projectile.checkCollision(meteor)) {\n                        const destroyed = meteor.takeDamage(projectile.damage);\n                        if (destroyed) {\n                            // Spawn coin at meteor's position\n                            const meteorX = $35da740d59af89ba$var$PADDING_LEFT + meteor.lane * $35da740d59af89ba$var$LANE_WIDTH + $35da740d59af89ba$var$LANE_WIDTH / 2;\n                            coins.push(new $35da740d59af89ba$var$Coin(meteorX, meteor.y));\n                            meteors.splice(i, 1);\n                        }\n                        return false; // Remove projectile\n                    }\n                }\n                return !projectile.isOffScreen();\n            });\n        }\n    }\n    draw(ctx, x, y, size, isSelected = false, isInactive = false) {\n        if ($35da740d59af89ba$var$DEBUG) {\n            // Draw spot outline\n            ctx.strokeStyle = this.isEmpty() ? \"#666\" : \"#888\";\n            ctx.lineWidth = 1;\n            ctx.strokeRect(x - size / 2, y - size / 2, size, size);\n        }\n        if (!this.isEmpty()) {\n            // Draw defense with health-based opacity\n            ctx.fillStyle = this.type.color;\n            if (isInactive) ctx.globalAlpha = 0.5;\n            else ctx.globalAlpha = Math.max(0.3, this.health / this.maxHealth);\n            ctx.fillRect(x - size / 2, y - size / 2, size, size);\n            ctx.globalAlpha = 1.0;\n            // Draw projectiles\n            this.projectiles.forEach((projectile)=>projectile.draw(ctx));\n            if ($35da740d59af89ba$var$DEBUG) {\n                // Draw health bar\n                ctx.fillStyle = \"white\";\n                ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n                ctx.textAlign = \"center\";\n                ctx.fillText(`${Math.floor(this.health / this.maxHealth * 100)}%`, x, y);\n            }\n            // Draw selection highlight\n            if (isSelected) {\n                ctx.strokeStyle = \"yellow\";\n                ctx.lineWidth = 2;\n                ctx.strokeRect(x - size / 2, y - size / 2, size, size);\n            }\n        }\n    }\n}\nclass $35da740d59af89ba$var$DefenseOption {\n    constructor(type, x, y){\n        this.type = type;\n        this.x = x;\n        this.y = y;\n        this.defense = new $35da740d59af89ba$var$Defense(type);\n    }\n    draw(ctx, isSelected = false, currentCurrency = 0) {\n        const isInactive = currentCurrency < this.type.cost;\n        // Draw defense using Defense class\n        this.defense.draw(ctx, this.x + $35da740d59af89ba$var$SPOT_SIZE / 2, this.y + $35da740d59af89ba$var$SPOT_SIZE / 2, $35da740d59af89ba$var$SPOT_SIZE, isSelected, isInactive);\n        // Draw cost (red if can't afford)\n        ctx.fillStyle = isInactive ? \"red\" : \"white\";\n        ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n        ctx.textAlign = \"center\";\n        ctx.fillText(`$${this.type.cost}`, this.x + $35da740d59af89ba$var$SPOT_SIZE / 2, this.y + $35da740d59af89ba$var$SPOT_SIZE + 15);\n    }\n    isClicked(clickX, clickY) {\n        return clickX >= this.x && clickX <= this.x + $35da740d59af89ba$var$SPOT_SIZE && clickY >= this.y && clickY <= this.y + $35da740d59af89ba$var$SPOT_SIZE;\n    }\n}\nclass $35da740d59af89ba$var$DefenseSpot {\n    constructor(x, y, row, lane){\n        this.x = x;\n        this.y = y;\n        this.row = row;\n        this.lane = lane;\n        this.defense = new $35da740d59af89ba$var$Defense();\n    }\n    isEmpty() {\n        return this.defense.isEmpty();\n    }\n    placeDefense(defenseType) {\n        if (this.isEmpty()) {\n            this.defense = new $35da740d59af89ba$var$Defense(defenseType);\n            return true;\n        }\n        return false;\n    }\n    removeDefense() {\n        this.defense = new $35da740d59af89ba$var$Defense(); // Reset to empty defense\n    }\n    draw(ctx) {\n        // Draw defense (or empty spot)\n        this.defense.draw(ctx, this.x, this.y, $35da740d59af89ba$var$SPOT_SIZE);\n        if ($35da740d59af89ba$var$DEBUG) {\n            // Draw coordinates for debugging\n            ctx.fillStyle = \"#666\";\n            ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n            ctx.textAlign = \"center\";\n            ctx.fillText(`${this.lane},${this.row}`, this.x, this.y);\n        }\n    }\n    update(currentTime, meteors, coins) {\n        this.defense.update(currentTime, this.x, this.y, meteors, coins);\n    }\n}\n// Add to game constants\nconst $35da740d59af89ba$var$INITIAL_CURRENCY = 500;\nclass $35da740d59af89ba$var$Coin {\n    constructor(x, y, value = 10){\n        this.x = x;\n        this.y = y;\n        this.value = value;\n        this.lifetime = 5000; // 5 seconds lifetime\n        this.createTime = performance.now();\n        this.size = 8;\n        this.hitRadius = 35; // Bigger radius for hit detection\n        // Base movement\n        const angle = Math.random() * Math.PI * 2;\n        const speed = 0.3 + Math.random() * 0.1;\n        this.vx = Math.cos(angle) * speed;\n        this.vy = Math.sin(angle) * speed;\n        // Wave motion parameters\n        this.waveAmplitude = 2 + Math.random() * 0.5; // Random wave size\n        this.waveFrequency = 0.005 + Math.random() * 0.01; // Random wave frequency\n        this.waveOffset = Math.random() * Math.PI * 2; // Random wave phase\n        this.baseX = x; // Keep track of base position\n        this.baseY = y;\n        this.time = 0;\n    }\n    update(currentTime) {\n        this.time += 16; // Increment time (assuming ~60fps)\n        // Update base position with velocity\n        this.baseX += this.vx;\n        this.baseY += this.vy;\n        // Add wave motion\n        this.x = this.baseX + Math.sin(this.time * this.waveFrequency + this.waveOffset) * this.waveAmplitude;\n        this.y = this.baseY + Math.cos(this.time * this.waveFrequency + this.waveOffset) * this.waveAmplitude;\n        // Slow down movement\n        // this.vx *= 0.98;\n        // this.vy *= 0.98;\n        // this.waveAmplitude *= 0.99; // Gradually reduce wave size\n        // Calculate remaining lifetime\n        const age = currentTime - this.createTime;\n        return age < this.lifetime;\n    }\n    draw(ctx, currentTime) {\n        const age = currentTime - this.createTime;\n        const remainingTime = this.lifetime - age;\n        // Start blinking when less than 1.5 seconds remaining\n        if (remainingTime < 1500) {\n            // Blink faster as time runs out\n            const blinkRate = 100 + remainingTime / 1500 * 400;\n            if (Math.floor(currentTime / blinkRate) % 2 === 0) return; // Skip drawing to create blink effect\n        }\n        if ($35da740d59af89ba$var$DEBUG) {\n            // Draw hit area\n            ctx.strokeStyle = \"rgba(255, 215, 0, 0.3)\"; // Semi-transparent gold\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.hitRadius, 0, Math.PI * 2);\n            ctx.stroke();\n        }\n        // Draw coin\n        ctx.fillStyle = \"#FFD700\"; // Gold color\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n        ctx.fill();\n        // Draw value\n        ctx.fillStyle = \"black\";\n        ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(`$`, this.x, this.y);\n    }\n    isClicked(clickX, clickY) {\n        const dx = clickX - this.x;\n        const dy = clickY - this.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        return distance < this.hitRadius; // Use bigger radius for hit detection\n    }\n}\nclass $35da740d59af89ba$var$LevelManager {\n    constructor(){\n        this.currentLevel = 0;\n        this.levelStartTime = 0;\n        this.waveStates = new Map();\n        this.allWavesComplete = false;\n    }\n    startLevel(levelIndex) {\n        this.currentLevel = levelIndex;\n        this.levelStartTime = performance.now();\n        this.waveStates = new Map();\n        this.allWavesComplete = false;\n        // Initialize wave states\n        $35da740d59af89ba$var$LEVELS[levelIndex].waves.forEach((wave, index)=>{\n            this.waveStates.set(index, {\n                meteorsSpawned: 0,\n                nextSpawnTime: wave.startTime\n            });\n        });\n    }\n    update(currentTime, meteors) {\n        if (this.currentLevel >= $35da740d59af89ba$var$LEVELS.length) return false;\n        const level = $35da740d59af89ba$var$LEVELS[this.currentLevel];\n        const levelTime = currentTime - this.levelStartTime;\n        // Check if level time is exceeded\n        if (levelTime >= level.duration) {\n            this.allWavesComplete = true;\n            return false;\n        }\n        // Update each wave\n        level.waves.forEach((wave, waveIndex)=>{\n            const state = this.waveStates.get(waveIndex);\n            if (levelTime >= state.nextSpawnTime && state.meteorsSpawned < wave.count) {\n                meteors.push(new $35da740d59af89ba$var$Meteor(Math.floor(Math.random() * $35da740d59af89ba$var$LANES), $35da740d59af89ba$var$METEOR_TYPES[wave.type]));\n                state.meteorsSpawned++;\n                state.nextSpawnTime = levelTime + wave.spacing;\n            }\n        });\n        return true;\n    }\n    isLevelComplete(meteors) {\n        return this.allWavesComplete && meteors.length === 0;\n    }\n    getLevelProgress() {\n        const levelTime = performance.now() - this.levelStartTime;\n        const duration = $35da740d59af89ba$var$LEVELS[this.currentLevel].duration;\n        return Math.min(levelTime / duration, 1);\n    }\n}\nclass $35da740d59af89ba$var$Game {\n    constructor(){\n        this.canvas = document.getElementById(\"canvas\");\n        this.ctx = this.canvas.getContext(\"2d\");\n        this.lastTime = 0;\n        this.meteors = [];\n        this.coins = [];\n        // Initialize game dimensions and scaling\n        this.initializeCanvas();\n        window.addEventListener(\"resize\", ()=>this.initializeCanvas());\n        // Start game loop\n        requestAnimationFrame((timestamp)=>this.gameLoop(timestamp));\n        // Add test meteor in middle lane\n        this.testMeteor = new $35da740d59af89ba$var$Meteor(2); // Lane 3 (0-based index)\n        // Add game state and button handling\n        this.gameState = $35da740d59af89ba$var$GAME_STATES.MENU;\n        this.setupEventListeners();\n        // Create buttons\n        const buttonWidth = 100;\n        const buttonHeight = 50;\n        const buttonX = $35da740d59af89ba$var$GAME_WIDTH / 2 - buttonWidth / 2;\n        const buttonY = $35da740d59af89ba$var$GAME_HEIGHT / 2 - buttonHeight / 2;\n        this.startButton = new $35da740d59af89ba$var$Button(buttonX, buttonY, buttonWidth, buttonHeight, \"Start Game\");\n        this.retryButton = new $35da740d59af89ba$var$Button(buttonX, buttonY, buttonWidth, buttonHeight, \"Try Again\");\n        this.gameOverText = new $35da740d59af89ba$var$Button($35da740d59af89ba$var$GAME_WIDTH / 2 - 100, $35da740d59af89ba$var$GAME_HEIGHT / 2 - 100, 200, 50, \"Game Over!\", \"transparent\", \"red\", 24);\n        // Initialize currency and defense options\n        this.currency = $35da740d59af89ba$var$INITIAL_CURRENCY;\n        this.defenseOptions = this.createDefenseOptions();\n        this.selectedDefense = null;\n        // Initialize the defense grid\n        this.defenseGrid = this.createDefenseGrid();\n        this.levelManager = new $35da740d59af89ba$var$LevelManager();\n        // Add new buttons\n        this.nextLevelButton = new $35da740d59af89ba$var$Button($35da740d59af89ba$var$GAME_WIDTH / 2 - 60, $35da740d59af89ba$var$GAME_HEIGHT / 2 + 50, 120, 40, \"Next Level\");\n        this.levelCompleteText = new $35da740d59af89ba$var$Button($35da740d59af89ba$var$GAME_WIDTH / 2 - 100, $35da740d59af89ba$var$GAME_HEIGHT / 2 - 50, 200, 50, \"Level Complete!\", \"transparent\", \"#4CAF50\", 24);\n        this.gameCompleteText = new $35da740d59af89ba$var$Button($35da740d59af89ba$var$GAME_WIDTH / 2 - 100, $35da740d59af89ba$var$GAME_HEIGHT / 2 - 50, 200, 50, \"Game Complete!\", \"transparent\", \"#4CAF50\", 24);\n    }\n    initializeCanvas() {\n        // Calculate scaling to fit viewport while maintaining aspect ratio\n        const viewportWidth = window.innerWidth;\n        const viewportHeight = window.innerHeight;\n        const scale = Math.min(viewportWidth / $35da740d59af89ba$var$GAME_WIDTH, viewportHeight / $35da740d59af89ba$var$GAME_HEIGHT);\n        this.canvas.width = $35da740d59af89ba$var$GAME_WIDTH;\n        this.canvas.height = $35da740d59af89ba$var$GAME_HEIGHT;\n        // Scale canvas using CSS\n        this.canvas.style.width = `${$35da740d59af89ba$var$GAME_WIDTH * scale}px`;\n        this.canvas.style.height = `${$35da740d59af89ba$var$GAME_HEIGHT * scale}px`;\n    }\n    setupEventListeners() {\n        this.canvas.addEventListener(\"click\", (e)=>{\n            const rect = this.canvas.getBoundingClientRect();\n            const scale = this.canvas.width / rect.width;\n            const x = (e.clientX - rect.left) * scale;\n            const y = (e.clientY - rect.top) * scale;\n            if (this.gameState === $35da740d59af89ba$var$GAME_STATES.MENU) {\n                if (this.startButton.isClicked(x, y)) this.startGame();\n            } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.GAME_OVER) {\n                if (this.retryButton.isClicked(x, y)) this.startGame();\n            } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.LEVEL_COMPLETE) {\n                if (this.nextLevelButton.isClicked(x, y)) this.startNextLevel();\n            } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.PLAYING) {\n                // Check for coin collection first\n                let coinCollected = false;\n                for(let i = this.coins.length - 1; i >= 0; i--){\n                    const coin = this.coins[i];\n                    if (coin.isClicked(x, y)) {\n                        // Add coin value to currency\n                        this.currency += coin.value;\n                        // Remove coin\n                        this.coins.splice(i, 1);\n                        coinCollected = true;\n                        break; // Only collect one coin per click\n                    }\n                }\n                // Only check defense interactions if we didn't collect a coin\n                if (!coinCollected) {\n                    // Check if defense option was clicked\n                    this.defenseOptions.forEach((option)=>{\n                        if (option.isClicked(x, y)) {\n                            if (this.currency >= option.type.cost) {\n                                this.selectedDefense = option.type;\n                                console.log(`Selected ${option.type.name} defense`);\n                            } else console.log(\"Not enough currency!\");\n                        }\n                    });\n                    // Check if grid spot was clicked\n                    if (this.selectedDefense) {\n                        const spot = this.getSpotAtPosition(x, y);\n                        if (spot && spot.isEmpty()) {\n                            if (this.currency >= this.selectedDefense.cost) {\n                                spot.placeDefense(this.selectedDefense);\n                                this.currency -= this.selectedDefense.cost;\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    }\n    startGame() {\n        this.gameState = $35da740d59af89ba$var$GAME_STATES.PLAYING;\n        this.meteors = [];\n        this.coins = [];\n        this.currency = $35da740d59af89ba$var$INITIAL_CURRENCY;\n        this.selectedDefense = null;\n        this.levelManager.startLevel(0);\n        // Reset defense grid\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++)this.defenseGrid[row][lane].removeDefense();\n    }\n    startNextLevel() {\n        this.meteors = [];\n        this.coins = [];\n        this.currency = $35da740d59af89ba$var$INITIAL_CURRENCY;\n        this.selectedDefense = null;\n        // Reset defense grid\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++)this.defenseGrid[row][lane].removeDefense();\n        this.levelManager.startLevel(this.levelManager.currentLevel + 1);\n        this.gameState = $35da740d59af89ba$var$GAME_STATES.PLAYING;\n    }\n    gameLoop(timestamp) {\n        // Calculate delta time\n        const deltaTime = timestamp - this.lastTime;\n        this.lastTime = timestamp;\n        // Clear canvas\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        // Update and draw game elements\n        this.update(deltaTime);\n        this.draw();\n        // Continue game loop\n        requestAnimationFrame((timestamp)=>this.gameLoop(timestamp));\n    }\n    drawBackground() {\n        // Draw game area border\n        this.ctx.strokeStyle = \"#333\";\n        this.ctx.strokeRect($35da740d59af89ba$var$PADDING_LEFT, $35da740d59af89ba$var$PADDING_TOP, this.gameAreaWidth, this.gameAreaHeight);\n        // Draw lanes\n        for(let i = 0; i <= $35da740d59af89ba$var$LANES; i++){\n            const x = $35da740d59af89ba$var$PADDING_LEFT + i * this.laneWidth;\n            this.ctx.beginPath();\n            this.ctx.moveTo(x, $35da740d59af89ba$var$PADDING_TOP);\n            this.ctx.lineTo(x, $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM);\n            this.ctx.stroke();\n        }\n        // Draw padding areas (for visualization)\n        this.ctx.fillStyle = \"#222\";\n        // Top padding\n        this.ctx.fillRect(0, 0, $35da740d59af89ba$var$GAME_WIDTH, $35da740d59af89ba$var$PADDING_TOP);\n        // Bottom padding\n        this.ctx.fillRect(0, $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM, $35da740d59af89ba$var$GAME_WIDTH, $35da740d59af89ba$var$PADDING_BOTTOM);\n        // Left padding\n        this.ctx.fillRect(0, $35da740d59af89ba$var$PADDING_TOP, $35da740d59af89ba$var$PADDING_LEFT, this.gameAreaHeight);\n        // Right padding\n        this.ctx.fillRect($35da740d59af89ba$var$GAME_WIDTH - $35da740d59af89ba$var$PADDING_RIGHT, $35da740d59af89ba$var$PADDING_TOP, $35da740d59af89ba$var$PADDING_RIGHT, this.gameAreaHeight);\n        // Draw defense grid\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++)this.defenseGrid[row][lane].draw(this.ctx);\n    }\n    update(deltaTime) {\n        if (this.gameState !== $35da740d59af89ba$var$GAME_STATES.PLAYING) return;\n        const currentTime = performance.now();\n        // Update all defense spots\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++)this.defenseGrid[row][lane].update(currentTime, this.meteors, this.coins);\n        // Update meteors and check for game over\n        this.meteors = this.meteors.filter((meteor)=>{\n            meteor.update(deltaTime);\n            if (meteor.y >= $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM) {\n                this.gameState = $35da740d59af89ba$var$GAME_STATES.GAME_OVER;\n                return false;\n            }\n            return true;\n        });\n        // Update coins\n        this.coins = this.coins.filter((coin)=>coin.update(currentTime));\n        // Update level manager\n        this.levelManager.update(currentTime, this.meteors);\n        // Check for level completion\n        if (this.levelManager.isLevelComplete(this.meteors)) {\n            if (this.levelManager.currentLevel >= $35da740d59af89ba$var$LEVELS.length - 1) this.gameState = $35da740d59af89ba$var$GAME_STATES.GAME_COMPLETE;\n            else this.gameState = $35da740d59af89ba$var$GAME_STATES.LEVEL_COMPLETE;\n        }\n    }\n    drawCurrency() {\n        this.ctx.fillStyle = \"white\";\n        this.ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n        this.ctx.textAlign = \"left\";\n        this.ctx.fillText(`Currency: $${this.currency}`, $35da740d59af89ba$var$PADDING_LEFT, $35da740d59af89ba$var$PADDING_TOP / 2);\n    }\n    draw() {\n        // Draw background first\n        this.drawBackground();\n        if (this.gameState === $35da740d59af89ba$var$GAME_STATES.MENU) this.startButton.draw(this.ctx);\n        else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.PLAYING) {\n            // Draw currency\n            this.drawCurrency();\n            // Draw progress bar\n            this.drawProgressBar(this.ctx);\n            // Draw defense options\n            this.defenseOptions.forEach((option)=>{\n                option.draw(this.ctx, this.selectedDefense && option.type.id === this.selectedDefense.id, this.currency);\n            });\n            // Draw meteors\n            this.meteors.forEach((meteor)=>meteor.draw(this.ctx));\n            // Draw coins\n            const currentTime = performance.now();\n            this.coins.forEach((coin)=>coin.draw(this.ctx, currentTime));\n        } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.LEVEL_COMPLETE) {\n            this.levelCompleteText.draw(this.ctx);\n            this.nextLevelButton.draw(this.ctx);\n        } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.GAME_COMPLETE) this.gameCompleteText.draw(this.ctx);\n        else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.GAME_OVER) {\n            this.gameOverText.draw(this.ctx);\n            this.retryButton.draw(this.ctx);\n        }\n    }\n    createDefenseOptions() {\n        return $35da740d59af89ba$var$DEFENSE_TYPES.map((type, index)=>{\n            const y = $35da740d59af89ba$var$PADDING_TOP + 50 + index * ($35da740d59af89ba$var$SPOT_SIZE + 30); // Space them vertically with room for cost\n            const x = 10; // Align to left side\n            return new $35da740d59af89ba$var$DefenseOption(type, x, y);\n        });\n    }\n    createDefenseGrid() {\n        const grid = [];\n        // Create 2D array for easier position reference\n        for(let row = 0; row < $35da740d59af89ba$var$GRID_ROWS; row++){\n            const rowArray = [];\n            for(let lane = 0; lane < $35da740d59af89ba$var$LANES; lane++){\n                const x = $35da740d59af89ba$var$PADDING_LEFT + lane * $35da740d59af89ba$var$LANE_WIDTH + $35da740d59af89ba$var$LANE_WIDTH / 2;\n                const y = $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM - row * $35da740d59af89ba$var$SPOT_SIZE - $35da740d59af89ba$var$SPOT_SIZE / 2;\n                rowArray.push(new $35da740d59af89ba$var$DefenseSpot(x, y, row, lane));\n            }\n            grid.push(rowArray);\n        }\n        return grid;\n    }\n    // Helper method to get spot at specific coordinates\n    getSpotAtPosition(x, y) {\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++){\n            const spot = this.defenseGrid[row][lane];\n            if (x >= spot.x - $35da740d59af89ba$var$SPOT_SIZE / 2 && x <= spot.x + $35da740d59af89ba$var$SPOT_SIZE / 2 && y >= spot.y - $35da740d59af89ba$var$SPOT_SIZE / 2 && y <= spot.y + $35da740d59af89ba$var$SPOT_SIZE / 2) return spot;\n        }\n        return null;\n    }\n    drawProgressBar(ctx) {\n        // Draw progress bar background\n        const barWidth = $35da740d59af89ba$var$GAME_WIDTH - 100; // Leave some padding\n        const barHeight = 20;\n        const x = 50; // Padding from left\n        const y = 20; // Padding from top\n        // Background\n        ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n        ctx.fillRect(x, y, barWidth, barHeight);\n        // Progress (inverted to show remaining time)\n        const progress = 1 - this.levelManager.getLevelProgress();\n        ctx.fillStyle = progress < 0.2 ? \"#ff4444\" : \"#4CAF50\"; // Red when low on time\n        ctx.fillRect(x, y, barWidth * progress, barHeight);\n        // Border\n        ctx.strokeStyle = \"white\";\n        ctx.strokeRect(x, y, barWidth, barHeight);\n        // Level text\n        ctx.fillStyle = \"white\";\n        ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n        ctx.textAlign = \"center\";\n        ctx.fillText(`${$35da740d59af89ba$var$LEVELS[this.levelManager.currentLevel].name}`, $35da740d59af89ba$var$GAME_WIDTH / 2, y + barHeight + 16);\n        // Time remaining\n        const timeLeft = Math.ceil(($35da740d59af89ba$var$LEVELS[this.levelManager.currentLevel].duration - (performance.now() - this.levelManager.levelStartTime)) / 1000);\n        if (timeLeft > 0) {\n            ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n            ctx.fillText(`${timeLeft}s`, $35da740d59af89ba$var$GAME_WIDTH - 30, y + barHeight / 2 + 5);\n        }\n    }\n}\n// Start the game when the page loads\nwindow.addEventListener(\"load\", ()=>{\n    new $35da740d59af89ba$var$Game();\n});\n\n\n//# sourceMappingURL=index.0fea9d28.js.map\n","// Game constants\nconst GAME_WIDTH = 360; // Base width, will be scaled\nconst GAME_HEIGHT = 640; // 16:9 ratio\nconst LANES = 6;\nconst PADDING_TOP = 80; // More space for score/level\nconst PADDING_BOTTOM = 100; // More space for controls/UI\nconst PADDING_LEFT = 80;\nconst PADDING_RIGHT = 40;\n\n// Game area calculations\nconst GAME_AREA_WIDTH = GAME_WIDTH - (PADDING_LEFT + PADDING_RIGHT);\nconst GAME_AREA_HEIGHT = GAME_HEIGHT - (PADDING_TOP + PADDING_BOTTOM);\nconst LANE_WIDTH = GAME_AREA_WIDTH / LANES; // Width of each lane\nconst SPOT_SIZE = LANE_WIDTH; // Defense spots are same width as lanes\nconst GRID_ROWS = Math.floor(GAME_AREA_HEIGHT / SPOT_SIZE);\n\n// Add to game constants\nconst DEBUG = true; // Toggle for development visualization\n\n// Add to game constants\nconst LEVELS = [\n  {\n    name: \"Level 1\",\n    duration: 30000, // 30 seconds\n    waves: [\n      { type: 0, count: 3, startTime: 1000, spacing: 1000 }, // 3 small meteors at 1s\n      { type: 0, count: 5, startTime: 8000, spacing: 800 }, // 5 small meteors at 8s\n      { type: 1, count: 2, startTime: 15000, spacing: 2000 }, // 2 medium meteors at 15s\n      { type: 0, count: 4, startTime: 20000, spacing: 500 }, // 4 small meteors at 20s\n      { type: 1, count: 3, startTime: 25000, spacing: 1500 }, // 3 medium meteors at 25s\n    ],\n  },\n  {\n    name: \"Level 2\",\n    duration: 45000, // 45 seconds\n    waves: [\n      { type: 1, count: 3, startTime: 2000, spacing: 1200 }, // 3 medium meteors at 2s\n      { type: 0, count: 6, startTime: 10000, spacing: 400 }, // 6 small meteors at 10s\n      { type: 2, count: 1, startTime: 18000, spacing: 0 }, // 1 large meteor at 18s\n      { type: 1, count: 4, startTime: 25000, spacing: 1000 }, // 4 medium meteors at 25s\n      { type: 2, count: 2, startTime: 35000, spacing: 2000 }, // 2 large meteors at 35s\n      { type: 0, count: 8, startTime: 40000, spacing: 300 }, // 8 small meteors at 40s\n    ],\n  },\n];\n\nconst GAME_STATES = {\n  MENU: \"menu\",\n  PLAYING: \"playing\",\n  LEVEL_COMPLETE: \"levelComplete\",\n  GAME_OVER: \"gameover\",\n  GAME_COMPLETE: \"gameComplete\",\n};\n\n// Add to game constants\nconst DEFENSE_TYPES = [\n  {\n    id: 0,\n    name: \"Basic\",\n    color: \"#4CAF50\",\n    cost: 100,\n    damage: 10,\n    health: 100,\n  },\n  {\n    id: 1,\n    name: \"Medium\",\n    color: \"#2196F3\",\n    cost: 200,\n    damage: 20,\n    health: 100,\n  },\n  {\n    id: 2,\n    name: \"Strong\",\n    color: \"#9C27B0\",\n    cost: 300,\n    damage: 30,\n    health: 100,\n  },\n];\n\n// Add to game constants\nconst METEOR_TYPES = [\n  {\n    id: 0,\n    name: \"Small\",\n    color: \"#FF9999\",\n    health: 30,\n    speed: 0.05,\n    damageRate: 30,\n  },\n  {\n    id: 1,\n    name: \"Medium\",\n    color: \"#FF4444\",\n    health: 60,\n    speed: 0.02,\n    damageRate: 50,\n  },\n  {\n    id: 2,\n    name: \"Large\",\n    color: \"#FF0000\",\n    health: 90,\n    speed: 0.08,\n    damageRate: 50,\n  },\n];\n\n// Font definitions\nconst FONT = {\n  SMALL: {\n    size: \"12px\",\n    family: \"Arial\",\n    get full() {\n      return `${this.size} ${this.family}`;\n    },\n  },\n  LARGE: {\n    size: \"14px\",\n    family: \"Arial\",\n    get full() {\n      return `${this.size} ${this.family}`;\n    },\n  },\n};\n\n// Test meteor\nclass Meteor {\n  constructor(lane, type = METEOR_TYPES[0]) {\n    // Default to weakest type\n    this.lane = lane;\n    this.type = type;\n    this.y = PADDING_TOP;\n    this.health = type.health;\n    this.speed = type.speed;\n    this.isBlocked = false; // New property to track if meteor is blocked by defense\n    this.blockingDefense = null; // Reference to blocking defense\n  }\n\n  update(deltaTime) {\n    if (!this.isBlocked) {\n      this.y += this.speed * deltaTime;\n    }\n  }\n\n  block(defense) {\n    this.isBlocked = true;\n    this.blockingDefense = defense;\n  }\n\n  unblock() {\n    this.isBlocked = false;\n    this.blockingDefense = null;\n  }\n\n  draw(ctx) {\n    const x = PADDING_LEFT + this.lane * LANE_WIDTH + LANE_WIDTH / 2;\n    ctx.fillStyle = this.type.color;\n    ctx.beginPath();\n    ctx.arc(x, this.y, 10, 0, Math.PI * 2);\n    ctx.fill();\n\n    if (DEBUG) {\n      // Draw collision circle\n      ctx.strokeStyle = \"rgba(255,0,0,0.3)\";\n      ctx.beginPath();\n      ctx.arc(x, this.y, 10, 0, Math.PI * 2);\n      ctx.stroke();\n\n      // Draw health\n      ctx.fillStyle = \"white\";\n      ctx.font = FONT.SMALL.full;\n      ctx.textAlign = \"center\";\n      ctx.fillText(`${this.health}`, x, this.y);\n    }\n  }\n\n  takeDamage(damage) {\n    this.health -= damage;\n    return this.health <= 0;\n  }\n}\n\n// Add to existing constants\nclass Button {\n  constructor(\n    x,\n    y,\n    width,\n    height,\n    text,\n    backgroundColor = \"#444\",\n    textColor = \"white\",\n    fontSize = 16,\n  ) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.text = text;\n    this.backgroundColor = backgroundColor;\n    this.textColor = textColor;\n    this.fontSize = fontSize;\n  }\n\n  isClicked(clickX, clickY) {\n    return (\n      clickX >= this.x &&\n      clickX <= this.x + this.width &&\n      clickY >= this.y &&\n      clickY <= this.y + this.height\n    );\n  }\n\n  draw(ctx) {\n    // Draw button background\n    ctx.fillStyle = this.backgroundColor;\n    ctx.fillRect(this.x, this.y, this.width, this.height);\n\n    // Draw button text\n    ctx.fillStyle = this.textColor;\n    ctx.font = FONT.LARGE.full;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height / 2);\n  }\n}\n\nclass Projectile {\n  constructor(x, y, damage) {\n    this.x = x;\n    this.y = y;\n    this.speed = 0.3;\n    this.damage = damage;\n    this.size = 4;\n  }\n\n  update(deltaTime) {\n    this.y -= this.speed * deltaTime;\n  }\n\n  draw(ctx) {\n    ctx.fillStyle = \"yellow\";\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n    ctx.fill();\n\n    if (DEBUG) {\n      // Draw collision circle\n      ctx.strokeStyle = \"rgba(255,255,0,0.3)\";\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n  }\n\n  checkCollision(meteor) {\n    const meteorX = PADDING_LEFT + meteor.lane * LANE_WIDTH + LANE_WIDTH / 2;\n    const dx = this.x - meteorX;\n    const dy = this.y - meteor.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < this.size + 10; // 10 is meteor radius\n  }\n\n  isOffScreen() {\n    return this.y < PADDING_TOP;\n  }\n}\n\n// Add to game constants\nclass Defense {\n  constructor(type = null) {\n    this.type = type;\n    this.health = type ? type.health : 0;\n    this.maxHealth = type ? type.health : 0;\n    this.projectiles = [];\n    this.lastFireTime = 0;\n    this.fireRate = 1000;\n    this.blockingMeteors = []; // Add array to track blocked meteors\n  }\n\n  isEmpty() {\n    return this.type === null;\n  }\n\n  takeDamage(amount) {\n    this.health -= amount;\n    return this.health <= 0;\n  }\n\n  update(currentTime, x, y, meteors, coins) {\n    if (!this.isEmpty()) {\n      // Fire projectile if enough time has passed\n      if (currentTime - this.lastFireTime > this.fireRate) {\n        this.projectiles.push(new Projectile(x, y, this.type.damage));\n        this.lastFireTime = currentTime;\n      }\n\n      // Check for meteor collisions with this defense\n      const defenseRow = Math.floor((y - PADDING_TOP) / SPOT_SIZE);\n      meteors.forEach((meteor) => {\n        const meteorRow = Math.floor((meteor.y - PADDING_TOP) / SPOT_SIZE);\n        if (\n          meteorRow === defenseRow &&\n          meteor.lane === Math.floor((x - PADDING_LEFT) / LANE_WIDTH)\n        ) {\n          // Block meteor if not already blocked\n          if (!meteor.isBlocked) {\n            meteor.block(this);\n            this.blockingMeteors.push(meteor); // Track this meteor\n          }\n\n          // Take damage from meteor using meteor's damage rate\n          if (meteor.blockingDefense === this) {\n            const destroyed = this.takeDamage(meteor.type.damageRate / 60);\n            if (destroyed) {\n              // Unblock all meteors this defense was blocking\n              this.blockingMeteors.forEach((m) => m.unblock());\n              this.blockingMeteors = [];\n              this.type = null; // Reset defense when destroyed\n              this.health = 0;\n              this.maxHealth = 0;\n            }\n          }\n        }\n      });\n\n      // Update existing projectiles and check collisions\n      this.projectiles = this.projectiles.filter((projectile) => {\n        projectile.update(16);\n\n        // Check for collisions with any meteor\n        for (let i = 0; i < meteors.length; i++) {\n          const meteor = meteors[i];\n          if (projectile.checkCollision(meteor)) {\n            const destroyed = meteor.takeDamage(projectile.damage);\n            if (destroyed) {\n              // Spawn coin at meteor's position\n              const meteorX =\n                PADDING_LEFT + meteor.lane * LANE_WIDTH + LANE_WIDTH / 2;\n              coins.push(new Coin(meteorX, meteor.y));\n              meteors.splice(i, 1);\n            }\n            return false; // Remove projectile\n          }\n        }\n\n        return !projectile.isOffScreen();\n      });\n    }\n  }\n\n  draw(ctx, x, y, size, isSelected = false, isInactive = false) {\n    if (DEBUG) {\n      // Draw spot outline\n      ctx.strokeStyle = this.isEmpty() ? \"#666\" : \"#888\";\n      ctx.lineWidth = 1;\n      ctx.strokeRect(x - size / 2, y - size / 2, size, size);\n    }\n\n    if (!this.isEmpty()) {\n      // Draw defense with health-based opacity\n      ctx.fillStyle = this.type.color;\n      if (isInactive) {\n        ctx.globalAlpha = 0.5;\n      } else {\n        ctx.globalAlpha = Math.max(0.3, this.health / this.maxHealth);\n      }\n      ctx.fillRect(x - size / 2, y - size / 2, size, size);\n      ctx.globalAlpha = 1.0;\n\n      // Draw projectiles\n      this.projectiles.forEach((projectile) => projectile.draw(ctx));\n\n      if (DEBUG) {\n        // Draw health bar\n        ctx.fillStyle = \"white\";\n        ctx.font = FONT.SMALL.full;\n        ctx.textAlign = \"center\";\n        ctx.fillText(\n          `${Math.floor((this.health / this.maxHealth) * 100)}%`,\n          x,\n          y,\n        );\n      }\n\n      // Draw selection highlight\n      if (isSelected) {\n        ctx.strokeStyle = \"yellow\";\n        ctx.lineWidth = 2;\n        ctx.strokeRect(x - size / 2, y - size / 2, size, size);\n      }\n    }\n  }\n}\n\nclass DefenseOption {\n  constructor(type, x, y) {\n    this.type = type;\n    this.x = x;\n    this.y = y;\n    this.defense = new Defense(type);\n  }\n\n  draw(ctx, isSelected = false, currentCurrency = 0) {\n    const isInactive = currentCurrency < this.type.cost;\n\n    // Draw defense using Defense class\n    this.defense.draw(\n      ctx,\n      this.x + SPOT_SIZE / 2,\n      this.y + SPOT_SIZE / 2,\n      SPOT_SIZE,\n      isSelected,\n      isInactive,\n    );\n\n    // Draw cost (red if can't afford)\n    ctx.fillStyle = isInactive ? \"red\" : \"white\";\n    ctx.font = FONT.LARGE.full;\n    ctx.textAlign = \"center\";\n    ctx.fillText(\n      `$${this.type.cost}`,\n      this.x + SPOT_SIZE / 2,\n      this.y + SPOT_SIZE + 15,\n    );\n  }\n\n  isClicked(clickX, clickY) {\n    return (\n      clickX >= this.x &&\n      clickX <= this.x + SPOT_SIZE &&\n      clickY >= this.y &&\n      clickY <= this.y + SPOT_SIZE\n    );\n  }\n}\n\nclass DefenseSpot {\n  constructor(x, y, row, lane) {\n    this.x = x;\n    this.y = y;\n    this.row = row;\n    this.lane = lane;\n    this.defense = new Defense();\n  }\n\n  isEmpty() {\n    return this.defense.isEmpty();\n  }\n\n  placeDefense(defenseType) {\n    if (this.isEmpty()) {\n      this.defense = new Defense(defenseType);\n      return true;\n    }\n    return false;\n  }\n\n  removeDefense() {\n    this.defense = new Defense(); // Reset to empty defense\n  }\n\n  draw(ctx) {\n    // Draw defense (or empty spot)\n    this.defense.draw(ctx, this.x, this.y, SPOT_SIZE);\n\n    if (DEBUG) {\n      // Draw coordinates for debugging\n      ctx.fillStyle = \"#666\";\n      ctx.font = FONT.SMALL.full;\n      ctx.textAlign = \"center\";\n      ctx.fillText(`${this.lane},${this.row}`, this.x, this.y);\n    }\n  }\n\n  update(currentTime, meteors, coins) {\n    this.defense.update(currentTime, this.x, this.y, meteors, coins);\n  }\n}\n\n// Add to game constants\nconst INITIAL_CURRENCY = 500;\n\nclass Coin {\n  constructor(x, y, value = 10) {\n    this.x = x;\n    this.y = y;\n    this.value = value;\n    this.lifetime = 5000; // 5 seconds lifetime\n    this.createTime = performance.now();\n    this.size = 8;\n    this.hitRadius = 35; // Bigger radius for hit detection\n\n    // Base movement\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.1;\n    this.vx = Math.cos(angle) * speed;\n    this.vy = Math.sin(angle) * speed;\n\n    // Wave motion parameters\n    this.waveAmplitude = 2 + Math.random() * 0.5; // Random wave size\n    this.waveFrequency = 0.005 + Math.random() * 0.01; // Random wave frequency\n    this.waveOffset = Math.random() * Math.PI * 2; // Random wave phase\n    this.baseX = x; // Keep track of base position\n    this.baseY = y;\n    this.time = 0;\n  }\n\n  update(currentTime) {\n    this.time += 16; // Increment time (assuming ~60fps)\n\n    // Update base position with velocity\n    this.baseX += this.vx;\n    this.baseY += this.vy;\n\n    // Add wave motion\n    this.x =\n      this.baseX +\n      Math.sin(this.time * this.waveFrequency + this.waveOffset) *\n        this.waveAmplitude;\n    this.y =\n      this.baseY +\n      Math.cos(this.time * this.waveFrequency + this.waveOffset) *\n        this.waveAmplitude;\n\n    // Slow down movement\n    // this.vx *= 0.98;\n    // this.vy *= 0.98;\n    // this.waveAmplitude *= 0.99; // Gradually reduce wave size\n\n    // Calculate remaining lifetime\n    const age = currentTime - this.createTime;\n    return age < this.lifetime;\n  }\n\n  draw(ctx, currentTime) {\n    const age = currentTime - this.createTime;\n    const remainingTime = this.lifetime - age;\n\n    // Start blinking when less than 1.5 seconds remaining\n    if (remainingTime < 1500) {\n      // Blink faster as time runs out\n      const blinkRate = 100 + (remainingTime / 1500) * 400;\n      if (Math.floor(currentTime / blinkRate) % 2 === 0) {\n        return; // Skip drawing to create blink effect\n      }\n    }\n\n    if (DEBUG) {\n      // Draw hit area\n      ctx.strokeStyle = \"rgba(255, 215, 0, 0.3)\"; // Semi-transparent gold\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, this.hitRadius, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n\n    // Draw coin\n    ctx.fillStyle = \"#FFD700\"; // Gold color\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Draw value\n    ctx.fillStyle = \"black\";\n    ctx.font = FONT.SMALL.full;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(`$`, this.x, this.y);\n  }\n\n  isClicked(clickX, clickY) {\n    const dx = clickX - this.x;\n    const dy = clickY - this.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < this.hitRadius; // Use bigger radius for hit detection\n  }\n}\n\nclass LevelManager {\n  constructor() {\n    this.currentLevel = 0;\n    this.levelStartTime = 0;\n    this.waveStates = new Map();\n    this.allWavesComplete = false;\n  }\n\n  startLevel(levelIndex) {\n    this.currentLevel = levelIndex;\n    this.levelStartTime = performance.now();\n    this.waveStates = new Map();\n    this.allWavesComplete = false;\n\n    // Initialize wave states\n    LEVELS[levelIndex].waves.forEach((wave, index) => {\n      this.waveStates.set(index, {\n        meteorsSpawned: 0,\n        nextSpawnTime: wave.startTime,\n      });\n    });\n  }\n\n  update(currentTime, meteors) {\n    if (this.currentLevel >= LEVELS.length) return false;\n\n    const level = LEVELS[this.currentLevel];\n    const levelTime = currentTime - this.levelStartTime;\n\n    // Check if level time is exceeded\n    if (levelTime >= level.duration) {\n      this.allWavesComplete = true;\n      return false;\n    }\n\n    // Update each wave\n    level.waves.forEach((wave, waveIndex) => {\n      const state = this.waveStates.get(waveIndex);\n\n      if (\n        levelTime >= state.nextSpawnTime &&\n        state.meteorsSpawned < wave.count\n      ) {\n        meteors.push(\n          new Meteor(\n            Math.floor(Math.random() * LANES),\n            METEOR_TYPES[wave.type],\n          ),\n        );\n\n        state.meteorsSpawned++;\n        state.nextSpawnTime = levelTime + wave.spacing;\n      }\n    });\n\n    return true;\n  }\n\n  isLevelComplete(meteors) {\n    return this.allWavesComplete && meteors.length === 0;\n  }\n\n  getLevelProgress() {\n    const levelTime = performance.now() - this.levelStartTime;\n    const duration = LEVELS[this.currentLevel].duration;\n    return Math.min(levelTime / duration, 1);\n  }\n}\n\nclass Game {\n  constructor() {\n    this.canvas = document.getElementById(\"canvas\");\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.lastTime = 0;\n    this.meteors = [];\n    this.coins = [];\n\n    // Initialize game dimensions and scaling\n    this.initializeCanvas();\n    window.addEventListener(\"resize\", () => this.initializeCanvas());\n\n    // Start game loop\n    requestAnimationFrame((timestamp) => this.gameLoop(timestamp));\n\n    // Add test meteor in middle lane\n    this.testMeteor = new Meteor(2); // Lane 3 (0-based index)\n\n    // Add game state and button handling\n    this.gameState = GAME_STATES.MENU;\n    this.setupEventListeners();\n\n    // Create buttons\n    const buttonWidth = 100;\n    const buttonHeight = 50;\n    const buttonX = GAME_WIDTH / 2 - buttonWidth / 2;\n    const buttonY = GAME_HEIGHT / 2 - buttonHeight / 2;\n\n    this.startButton = new Button(\n      buttonX,\n      buttonY,\n      buttonWidth,\n      buttonHeight,\n      \"Start Game\",\n    );\n    this.retryButton = new Button(\n      buttonX,\n      buttonY,\n      buttonWidth,\n      buttonHeight,\n      \"Try Again\",\n    );\n    this.gameOverText = new Button(\n      GAME_WIDTH / 2 - 100,\n      GAME_HEIGHT / 2 - 100,\n      200,\n      50,\n      \"Game Over!\",\n      \"transparent\",\n      \"red\",\n      24,\n    );\n\n    // Initialize currency and defense options\n    this.currency = INITIAL_CURRENCY;\n    this.defenseOptions = this.createDefenseOptions();\n    this.selectedDefense = null;\n\n    // Initialize the defense grid\n    this.defenseGrid = this.createDefenseGrid();\n\n    this.levelManager = new LevelManager();\n\n    // Add new buttons\n    this.nextLevelButton = new Button(\n      GAME_WIDTH / 2 - 60,\n      GAME_HEIGHT / 2 + 50,\n      120,\n      40,\n      \"Next Level\",\n    );\n\n    this.levelCompleteText = new Button(\n      GAME_WIDTH / 2 - 100,\n      GAME_HEIGHT / 2 - 50,\n      200,\n      50,\n      \"Level Complete!\",\n      \"transparent\",\n      \"#4CAF50\",\n      24,\n    );\n\n    this.gameCompleteText = new Button(\n      GAME_WIDTH / 2 - 100,\n      GAME_HEIGHT / 2 - 50,\n      200,\n      50,\n      \"Game Complete!\",\n      \"transparent\",\n      \"#4CAF50\",\n      24,\n    );\n  }\n\n  initializeCanvas() {\n    // Calculate scaling to fit viewport while maintaining aspect ratio\n    const viewportWidth = window.innerWidth;\n    const viewportHeight = window.innerHeight;\n    const scale = Math.min(\n      viewportWidth / GAME_WIDTH,\n      viewportHeight / GAME_HEIGHT,\n    );\n\n    this.canvas.width = GAME_WIDTH;\n    this.canvas.height = GAME_HEIGHT;\n\n    // Scale canvas using CSS\n    this.canvas.style.width = `${GAME_WIDTH * scale}px`;\n    this.canvas.style.height = `${GAME_HEIGHT * scale}px`;\n  }\n\n  setupEventListeners() {\n    this.canvas.addEventListener(\"click\", (e) => {\n      const rect = this.canvas.getBoundingClientRect();\n      const scale = this.canvas.width / rect.width;\n      const x = (e.clientX - rect.left) * scale;\n      const y = (e.clientY - rect.top) * scale;\n\n      if (this.gameState === GAME_STATES.MENU) {\n        if (this.startButton.isClicked(x, y)) {\n          this.startGame();\n        }\n      } else if (this.gameState === GAME_STATES.GAME_OVER) {\n        if (this.retryButton.isClicked(x, y)) {\n          this.startGame();\n        }\n      } else if (this.gameState === GAME_STATES.LEVEL_COMPLETE) {\n        if (this.nextLevelButton.isClicked(x, y)) {\n          this.startNextLevel();\n        }\n      } else if (this.gameState === GAME_STATES.PLAYING) {\n        // Check for coin collection first\n        let coinCollected = false;\n        for (let i = this.coins.length - 1; i >= 0; i--) {\n          const coin = this.coins[i];\n          if (coin.isClicked(x, y)) {\n            // Add coin value to currency\n            this.currency += coin.value;\n            // Remove coin\n            this.coins.splice(i, 1);\n            coinCollected = true;\n            break; // Only collect one coin per click\n          }\n        }\n\n        // Only check defense interactions if we didn't collect a coin\n        if (!coinCollected) {\n          // Check if defense option was clicked\n          this.defenseOptions.forEach((option) => {\n            if (option.isClicked(x, y)) {\n              if (this.currency >= option.type.cost) {\n                this.selectedDefense = option.type;\n                console.log(`Selected ${option.type.name} defense`);\n              } else {\n                console.log(\"Not enough currency!\");\n              }\n            }\n          });\n\n          // Check if grid spot was clicked\n          if (this.selectedDefense) {\n            const spot = this.getSpotAtPosition(x, y);\n            if (spot && spot.isEmpty()) {\n              if (this.currency >= this.selectedDefense.cost) {\n                spot.placeDefense(this.selectedDefense);\n                this.currency -= this.selectedDefense.cost;\n              }\n            }\n          }\n        }\n      }\n    });\n  }\n\n  startGame() {\n    this.gameState = GAME_STATES.PLAYING;\n    this.meteors = [];\n    this.coins = [];\n    this.currency = INITIAL_CURRENCY;\n    this.selectedDefense = null;\n    this.levelManager.startLevel(0);\n\n    // Reset defense grid\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        this.defenseGrid[row][lane].removeDefense();\n      }\n    }\n  }\n\n  startNextLevel() {\n    this.meteors = [];\n    this.coins = [];\n    this.currency = INITIAL_CURRENCY;\n    this.selectedDefense = null;\n\n    // Reset defense grid\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        this.defenseGrid[row][lane].removeDefense();\n      }\n    }\n\n    this.levelManager.startLevel(this.levelManager.currentLevel + 1);\n    this.gameState = GAME_STATES.PLAYING;\n  }\n\n  gameLoop(timestamp) {\n    // Calculate delta time\n    const deltaTime = timestamp - this.lastTime;\n    this.lastTime = timestamp;\n\n    // Clear canvas\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    // Update and draw game elements\n    this.update(deltaTime);\n    this.draw();\n\n    // Continue game loop\n    requestAnimationFrame((timestamp) => this.gameLoop(timestamp));\n  }\n\n  drawBackground() {\n    // Draw game area border\n    this.ctx.strokeStyle = \"#333\";\n    this.ctx.strokeRect(\n      PADDING_LEFT,\n      PADDING_TOP,\n      this.gameAreaWidth,\n      this.gameAreaHeight,\n    );\n\n    // Draw lanes\n    for (let i = 0; i <= LANES; i++) {\n      const x = PADDING_LEFT + i * this.laneWidth;\n      this.ctx.beginPath();\n      this.ctx.moveTo(x, PADDING_TOP);\n      this.ctx.lineTo(x, GAME_HEIGHT - PADDING_BOTTOM);\n      this.ctx.stroke();\n    }\n\n    // Draw padding areas (for visualization)\n    this.ctx.fillStyle = \"#222\";\n    // Top padding\n    this.ctx.fillRect(0, 0, GAME_WIDTH, PADDING_TOP);\n    // Bottom padding\n    this.ctx.fillRect(\n      0,\n      GAME_HEIGHT - PADDING_BOTTOM,\n      GAME_WIDTH,\n      PADDING_BOTTOM,\n    );\n    // Left padding\n    this.ctx.fillRect(0, PADDING_TOP, PADDING_LEFT, this.gameAreaHeight);\n    // Right padding\n    this.ctx.fillRect(\n      GAME_WIDTH - PADDING_RIGHT,\n      PADDING_TOP,\n      PADDING_RIGHT,\n      this.gameAreaHeight,\n    );\n\n    // Draw defense grid\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        this.defenseGrid[row][lane].draw(this.ctx);\n      }\n    }\n  }\n\n  update(deltaTime) {\n    if (this.gameState !== GAME_STATES.PLAYING) return;\n\n    const currentTime = performance.now();\n\n    // Update all defense spots\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        this.defenseGrid[row][lane].update(\n          currentTime,\n          this.meteors,\n          this.coins,\n        );\n      }\n    }\n\n    // Update meteors and check for game over\n    this.meteors = this.meteors.filter((meteor) => {\n      meteor.update(deltaTime);\n      if (meteor.y >= GAME_HEIGHT - PADDING_BOTTOM) {\n        this.gameState = GAME_STATES.GAME_OVER;\n        return false;\n      }\n      return true;\n    });\n\n    // Update coins\n    this.coins = this.coins.filter((coin) => coin.update(currentTime));\n\n    // Update level manager\n    this.levelManager.update(currentTime, this.meteors);\n\n    // Check for level completion\n    if (this.levelManager.isLevelComplete(this.meteors)) {\n      if (this.levelManager.currentLevel >= LEVELS.length - 1) {\n        this.gameState = GAME_STATES.GAME_COMPLETE;\n      } else {\n        this.gameState = GAME_STATES.LEVEL_COMPLETE;\n      }\n    }\n  }\n\n  drawCurrency() {\n    this.ctx.fillStyle = \"white\";\n    this.ctx.font = FONT.LARGE.full;\n    this.ctx.textAlign = \"left\";\n    this.ctx.fillText(\n      `Currency: $${this.currency}`,\n      PADDING_LEFT,\n      PADDING_TOP / 2,\n    );\n  }\n\n  draw() {\n    // Draw background first\n    this.drawBackground();\n\n    if (this.gameState === GAME_STATES.MENU) {\n      this.startButton.draw(this.ctx);\n    } else if (this.gameState === GAME_STATES.PLAYING) {\n      // Draw currency\n      this.drawCurrency();\n\n      // Draw progress bar\n      this.drawProgressBar(this.ctx);\n\n      // Draw defense options\n      this.defenseOptions.forEach((option) => {\n        option.draw(\n          this.ctx,\n          this.selectedDefense && option.type.id === this.selectedDefense.id,\n          this.currency,\n        );\n      });\n\n      // Draw meteors\n      this.meteors.forEach((meteor) => meteor.draw(this.ctx));\n\n      // Draw coins\n      const currentTime = performance.now();\n      this.coins.forEach((coin) => coin.draw(this.ctx, currentTime));\n    } else if (this.gameState === GAME_STATES.LEVEL_COMPLETE) {\n      this.levelCompleteText.draw(this.ctx);\n      this.nextLevelButton.draw(this.ctx);\n    } else if (this.gameState === GAME_STATES.GAME_COMPLETE) {\n      this.gameCompleteText.draw(this.ctx);\n    } else if (this.gameState === GAME_STATES.GAME_OVER) {\n      this.gameOverText.draw(this.ctx);\n      this.retryButton.draw(this.ctx);\n    }\n  }\n\n  createDefenseOptions() {\n    return DEFENSE_TYPES.map((type, index) => {\n      const y = PADDING_TOP + 50 + index * (SPOT_SIZE + 30); // Space them vertically with room for cost\n      const x = 10; // Align to left side\n      return new DefenseOption(type, x, y);\n    });\n  }\n\n  createDefenseGrid() {\n    const grid = [];\n\n    // Create 2D array for easier position reference\n    for (let row = 0; row < GRID_ROWS; row++) {\n      const rowArray = [];\n      for (let lane = 0; lane < LANES; lane++) {\n        const x = PADDING_LEFT + lane * LANE_WIDTH + LANE_WIDTH / 2;\n        const y =\n          GAME_HEIGHT - PADDING_BOTTOM - row * SPOT_SIZE - SPOT_SIZE / 2;\n        rowArray.push(new DefenseSpot(x, y, row, lane));\n      }\n      grid.push(rowArray);\n    }\n\n    return grid;\n  }\n\n  // Helper method to get spot at specific coordinates\n  getSpotAtPosition(x, y) {\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        const spot = this.defenseGrid[row][lane];\n        if (\n          x >= spot.x - SPOT_SIZE / 2 &&\n          x <= spot.x + SPOT_SIZE / 2 &&\n          y >= spot.y - SPOT_SIZE / 2 &&\n          y <= spot.y + SPOT_SIZE / 2\n        ) {\n          return spot;\n        }\n      }\n    }\n    return null;\n  }\n\n  drawProgressBar(ctx) {\n    // Draw progress bar background\n    const barWidth = GAME_WIDTH - 100; // Leave some padding\n    const barHeight = 20;\n    const x = 50; // Padding from left\n    const y = 20; // Padding from top\n\n    // Background\n    ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n    ctx.fillRect(x, y, barWidth, barHeight);\n\n    // Progress (inverted to show remaining time)\n    const progress = 1 - this.levelManager.getLevelProgress();\n    ctx.fillStyle = progress < 0.2 ? \"#ff4444\" : \"#4CAF50\"; // Red when low on time\n    ctx.fillRect(x, y, barWidth * progress, barHeight);\n\n    // Border\n    ctx.strokeStyle = \"white\";\n    ctx.strokeRect(x, y, barWidth, barHeight);\n\n    // Level text\n    ctx.fillStyle = \"white\";\n    ctx.font = FONT.LARGE.full;\n    ctx.textAlign = \"center\";\n    ctx.fillText(\n      `${LEVELS[this.levelManager.currentLevel].name}`,\n      GAME_WIDTH / 2,\n      y + barHeight + 16,\n    );\n\n    // Time remaining\n    const timeLeft = Math.ceil(\n      (LEVELS[this.levelManager.currentLevel].duration -\n        (performance.now() - this.levelManager.levelStartTime)) /\n        1000,\n    );\n    if (timeLeft > 0) {\n      ctx.font = FONT.SMALL.full;\n      ctx.fillText(`${timeLeft}s`, GAME_WIDTH - 30, y + barHeight / 2 + 5);\n    }\n  }\n}\n\n// Start the game when the page loads\nwindow.addEventListener(\"load\", () => {\n  new Game();\n});\n"],"names":["$35da740d59af89ba$var$GRID_ROWS","Math","floor","$35da740d59af89ba$var$GAME_AREA_HEIGHT","$35da740d59af89ba$var$LEVELS","name","duration","waves","type","count","startTime","spacing","$35da740d59af89ba$var$GAME_STATES","MENU","PLAYING","LEVEL_COMPLETE","GAME_OVER","GAME_COMPLETE","$35da740d59af89ba$var$DEFENSE_TYPES","id","color","cost","damage","health","$35da740d59af89ba$var$METEOR_TYPES","speed","damageRate","$35da740d59af89ba$var$FONT","SMALL","size","family","full","LARGE","$35da740d59af89ba$var$Meteor","constructor","lane","y","isBlocked","blockingDefense","update","deltaTime","block","defense","unblock","draw","ctx","x","$35da740d59af89ba$var$PADDING_LEFT","$35da740d59af89ba$var$GAME_AREA_WIDTH","$35da740d59af89ba$var$LANE_WIDTH","fillStyle","beginPath","arc","PI","fill","strokeStyle","stroke","font","textAlign","fillText","takeDamage","$35da740d59af89ba$var$Button","width","height","text","backgroundColor","textColor","fontSize","isClicked","clickX","clickY","fillRect","textBaseline","$35da740d59af89ba$var$Projectile","checkCollision","meteor","meteorX","dx","dy","distance","sqrt","isOffScreen","$35da740d59af89ba$var$Defense","maxHealth","projectiles","lastFireTime","fireRate","blockingMeteors","isEmpty","amount","currentTime","meteors","coins","push","defenseRow","forEach","m","filter","projectile","i","length","$35da740d59af89ba$var$Coin","splice","isSelected","isInactive","lineWidth","strokeRect","globalAlpha","max","$35da740d59af89ba$var$DefenseOption","currentCurrency","$35da740d59af89ba$var$SPOT_SIZE","$35da740d59af89ba$var$DefenseSpot","row","placeDefense","defenseType","removeDefense","value","lifetime","createTime","performance","now","hitRadius","angle","random","vx","cos","vy","sin","waveAmplitude","waveFrequency","waveOffset","baseX","baseY","time","age","remainingTime","$35da740d59af89ba$var$LevelManager","currentLevel","levelStartTime","waveStates","Map","allWavesComplete","startLevel","levelIndex","wave","index","set","meteorsSpawned","nextSpawnTime","level","levelTime","waveIndex","state","get","isLevelComplete","getLevelProgress","min","$35da740d59af89ba$var$Game","canvas","document","getElementById","getContext","lastTime","initializeCanvas","window","addEventListener","requestAnimationFrame","timestamp","gameLoop","testMeteor","gameState","setupEventListeners","startButton","$35da740d59af89ba$var$GAME_WIDTH","$35da740d59af89ba$var$GAME_HEIGHT","retryButton","gameOverText","currency","defenseOptions","createDefenseOptions","selectedDefense","defenseGrid","createDefenseGrid","levelManager","nextLevelButton","levelCompleteText","gameCompleteText","scale","viewportWidth","innerWidth","viewportHeight","innerHeight","style","e","rect","getBoundingClientRect","clientX","left","clientY","top","startGame","startNextLevel","coinCollected","coin","option","console","log","spot","getSpotAtPosition","clearRect","drawBackground","gameAreaWidth","gameAreaHeight","laneWidth","moveTo","lineTo","drawCurrency","$35da740d59af89ba$var$PADDING_TOP","drawProgressBar","map","grid","rowArray","progress","barWidth","timeLeft","ceil"],"version":3,"file":"index.0fea9d28.js.map"}