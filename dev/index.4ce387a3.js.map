{"mappings":"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","sources":["<anon>","src/index.js"],"sourcesContent":["var $35da740d59af89ba$exports = {};\n// Game constants\nconst $35da740d59af89ba$var$GAME_WIDTH = 360; // Base width, will be scaled\nconst $35da740d59af89ba$var$GAME_HEIGHT = 640; // 16:9 ratio\nconst $35da740d59af89ba$var$LANES = 6;\nconst $35da740d59af89ba$var$PADDING_TOP = 80; // More space for score/level\nconst $35da740d59af89ba$var$PADDING_BOTTOM = 90; // More space for controls/UI\nconst $35da740d59af89ba$var$PADDING_LEFT = 40;\nconst $35da740d59af89ba$var$PADDING_RIGHT = 40;\nconst $35da740d59af89ba$var$INITIAL_CURRENCY = 500;\n// Game area calculations\nconst $35da740d59af89ba$var$GAME_AREA_WIDTH = $35da740d59af89ba$var$GAME_WIDTH - ($35da740d59af89ba$var$PADDING_LEFT + $35da740d59af89ba$var$PADDING_RIGHT);\nconst $35da740d59af89ba$var$GAME_AREA_HEIGHT = $35da740d59af89ba$var$GAME_HEIGHT - ($35da740d59af89ba$var$PADDING_TOP + $35da740d59af89ba$var$PADDING_BOTTOM);\nconst $35da740d59af89ba$var$LANE_WIDTH = $35da740d59af89ba$var$GAME_AREA_WIDTH / $35da740d59af89ba$var$LANES; // Width of each lane\nconst $35da740d59af89ba$var$SPOT_SIZE = $35da740d59af89ba$var$LANE_WIDTH; // Defense spots are same width as lanes\nconst $35da740d59af89ba$var$METEOR_SIZE = $35da740d59af89ba$var$LANE_WIDTH * 0.8; // Base size for meteors\nconst $35da740d59af89ba$var$GRID_ROWS = Math.floor($35da740d59af89ba$var$GAME_AREA_HEIGHT / $35da740d59af89ba$var$SPOT_SIZE);\n// Add to game constants\nconst $35da740d59af89ba$var$DEBUG = false; // Toggle for development visualization\nconst $35da740d59af89ba$var$COLORS = {\n    BACKGROUND: \"#edf1e7\",\n    TEXT: \"#000\",\n    DEFENSE_OPTION_TEXT: \"#000\",\n    DEFENSE_OPTION_TEXT_INACTIVE: \"#f00\",\n    BUTTON: \"#444\",\n    BUTTON_TEXT: \"#fff\",\n    PROGRESS_BAR: \"#4CAF50\",\n    BORDER: \"#333\",\n    DEBUG_LINE: \"rgba(0,0,0,0.1)\",\n    DEBUG_TEXT: \"#666\",\n    SELECTION: \"rgba(255,80,80,0.7)\"\n};\n// Replace the LEVELS constant with this generator\nconst $35da740d59af89ba$var$LEVELS = $35da740d59af89ba$var$generateLevels();\nfunction $35da740d59af89ba$var$generateLevels() {\n    const levels = [];\n    // Base multipliers for level-to-level scaling\n    const levelSpawnMultiplier = 0.3;\n    const levelCountMultiplier = 0.2;\n    const levelDangerMultiplier = 0.15; // New: Controls danger increase across levels\n    for(let i = 0; i < 10; i++){\n        const levelIndex = i + 1;\n        const duration = 150000; // 2min 30sec in milliseconds\n        // Level-wide difficulty multipliers\n        const baseSpawnMultiplier = 1 + i * levelSpawnMultiplier;\n        const baseCountMultiplier = 1 + i * levelCountMultiplier;\n        const baseDangerMultiplier = 1 + i * levelDangerMultiplier; // New: Base danger for this level\n        const waves = [];\n        let currentTime = 500;\n        // Track progress through level for intra-level scaling\n        while(currentTime < duration){\n            // Calculate progress through level (0 to 1)\n            const levelProgress = currentTime / duration;\n            // Increase difficulty within level (xxx% harder by end of level)\n            const intraLevelMultiplier = 1 + levelProgress * 1.2;\n            // Combined multipliers for this wave\n            const spawnMultiplier = baseSpawnMultiplier * intraLevelMultiplier;\n            const countMultiplier = baseCountMultiplier * intraLevelMultiplier;\n            // Calculate danger probability based on level progress AND overall level\n            const progressDanger = levelProgress * 0.7; // Increases from 0 to 0.7 within level\n            const levelDanger = (levelIndex - 1) * 0.1; // Increases by 0.1 per level\n            const totalDangerFactor = (progressDanger + levelDanger) * baseDangerMultiplier;\n            // Determine meteor type based on combined danger factor\n            let meteorType;\n            const random = Math.random();\n            if (random < 0.2 * totalDangerFactor) meteorType = 2; // Large meteor\n            else if (random < 0.4 * totalDangerFactor) meteorType = 1; // Medium meteor\n            else meteorType = 0; // Small meteor\n            // Base counts and spacing (adjusted for balance)\n            const baseCount = meteorType === 2 ? 1 : meteorType === 1 ? 2 : 3;\n            const count = Math.ceil(baseCount * countMultiplier);\n            const spacing = meteorType === 2 ? 2500 : meteorType === 1 ? 1500 : 1000;\n            waves.push({\n                type: meteorType,\n                count: count,\n                startTime: currentTime,\n                spacing: spacing / spawnMultiplier\n            });\n            // Wave timing\n            const waveLength = count * spacing / spawnMultiplier;\n            const breakTime = Math.max(2000 - levelProgress * 1000, 500); // Breaks get shorter\n            currentTime += waveLength + breakTime;\n        }\n        levels.push({\n            name: `Level ${levelIndex}`,\n            duration: duration,\n            waves: waves\n        });\n    }\n    return levels;\n}\nconst $35da740d59af89ba$var$GAME_STATES = {\n    LOADING: \"loading\",\n    MENU: \"menu\",\n    PLAYING: \"playing\",\n    LEVEL_COMPLETE: \"levelComplete\",\n    GAME_OVER: \"gameover\",\n    GAME_COMPLETE: \"gameComplete\"\n};\n// Add to game constants\nconst $35da740d59af89ba$var$DEFENSE_TYPES = [\n    {\n        id: 0,\n        name: \"Basic\",\n        color: \"#4CAF50\",\n        cost: 100,\n        damage: 10,\n        health: 100\n    },\n    {\n        id: 1,\n        name: \"Medium\",\n        color: \"#2196F3\",\n        cost: 200,\n        damage: 20,\n        health: 100\n    },\n    {\n        id: 2,\n        name: \"Strong\",\n        color: \"#9C27B0\",\n        cost: 300,\n        damage: 30,\n        health: 100\n    }\n];\n// Add to game constants\nconst $35da740d59af89ba$var$METEOR_TYPES = [\n    {\n        id: 0,\n        name: \"Small\",\n        color: \"#FF9999\",\n        health: 40,\n        speed: 0.05,\n        damageRate: 30,\n        rotateRate: 0.0005,\n        wiggleRate: 0.001,\n        wiggleAmount: 7,\n        sizeMultiplier: {\n            x: 1.0,\n            y: 1.0\n        },\n        coinReward: 10\n    },\n    {\n        id: 1,\n        name: \"Medium\",\n        color: \"#FF4444\",\n        health: 60,\n        speed: 0.035,\n        damageRate: 50,\n        rotateRate: 0,\n        wiggleRate: 0.03,\n        wiggleAmount: 0.03,\n        sizeMultiplier: {\n            x: 1,\n            y: 2\n        },\n        coinReward: 15\n    },\n    {\n        id: 2,\n        name: \"Large\",\n        color: \"#FF0000\",\n        health: 90,\n        speed: 0.05,\n        damageRate: 50,\n        rotateRate: 0,\n        wiggleRate: 0.03,\n        wiggleAmount: 0.03,\n        sizeMultiplier: {\n            x: 1,\n            y: 2\n        },\n        coinReward: 20\n    }\n];\n// Font definitions\nconst $35da740d59af89ba$var$FONT = {\n    SMALL: {\n        size: \"12px\",\n        family: \"Arial\",\n        get full () {\n            return `${this.size} ${this.family}`;\n        }\n    },\n    LARGE: {\n        size: \"14px\",\n        family: \"Arial\",\n        get full () {\n            return `${this.size} ${this.family}`;\n        }\n    }\n};\n// Add at the top of the file, after other constants\nconst $35da740d59af89ba$var$ASSETS = {\n    METEORS: [\n        \"/assets/img/meteor-1.png\",\n        \"/assets/img/meteor-2.png\",\n        \"/assets/img/meteor-3.png\"\n    ]\n};\n// Add new AssetLoader class\nclass $35da740d59af89ba$var$AssetLoader {\n    constructor(){\n        this.images = new Map();\n        this.totalAssets = 0;\n        this.loadedAssets = 0;\n    }\n    async loadAll() {\n        const meteorPromises = $35da740d59af89ba$var$ASSETS.METEORS.map((path, index)=>this.loadImage(`meteor-${index}`, path));\n        try {\n            await Promise.all(meteorPromises);\n            return true;\n        } catch (error) {\n            console.error(\"Error loading assets:\", error);\n            return false;\n        }\n    }\n    loadImage(key, src) {\n        return new Promise((resolve, reject)=>{\n            const img = new Image();\n            this.totalAssets++;\n            img.onload = ()=>{\n                this.images.set(key, img);\n                this.loadedAssets++;\n                resolve(img);\n            };\n            img.onerror = ()=>{\n                reject(new Error(`Failed to load image: ${src}`));\n            };\n            img.src = src;\n        });\n    }\n    getImage(key) {\n        return this.images.get(key);\n    }\n    getLoadingProgress() {\n        return this.totalAssets ? this.loadedAssets / this.totalAssets : 0;\n    }\n}\n// Add at the top of the file, after constants\nlet $35da740d59af89ba$var$game; // Global game instance\n// Test meteor\nclass $35da740d59af89ba$var$Meteor {\n    constructor(lane, type = $35da740d59af89ba$var$METEOR_TYPES[0]){\n        this.lane = lane;\n        this.type = type;\n        this.y = $35da740d59af89ba$var$PADDING_TOP;\n        this.health = type.health;\n        this.speed = type.speed;\n        this.isBlocked = false;\n        this.blockingDefense = null;\n        // Add rotation and wiggle properties\n        this.baseRotation = 0; // Base rotation from type.rotateRate\n        this.wiggleRotation = 0; // Additional rotation from wiggle motion\n        this.wiggleOffset = 0;\n        this.baseX = $35da740d59af89ba$var$PADDING_LEFT + lane * $35da740d59af89ba$var$LANE_WIDTH + $35da740d59af89ba$var$LANE_WIDTH / 2;\n    }\n    update(deltaTime) {\n        if (!this.isBlocked) {\n            this.y += this.speed * deltaTime;\n            // Update base rotation\n            this.baseRotation += this.type.rotateRate * deltaTime;\n            // Update wiggle and calculate wiggle-based rotation\n            this.wiggleOffset += this.type.wiggleRate * deltaTime;\n            // Calculate rotation based on wiggle movement (adjust 0.5 to control rotation intensity)\n            this.wiggleRotation = Math.cos(this.wiggleOffset) * this.type.wiggleAmount * 0.5;\n        }\n    }\n    block(defense) {\n        this.isBlocked = true;\n        this.blockingDefense = defense;\n    }\n    unblock() {\n        this.isBlocked = false;\n        this.blockingDefense = null;\n    }\n    draw(ctx) {\n        // Calculate wiggled x position\n        const wiggleX = this.baseX + Math.sin(this.wiggleOffset) * this.type.wiggleAmount;\n        // Get the corresponding meteor image\n        const meteorImage = $35da740d59af89ba$var$game?.assetLoader.getImage(`meteor-${this.type.id}`);\n        if (meteorImage) {\n            ctx.save(); // Save current context state\n            // Translate to meteor position\n            ctx.translate(wiggleX, this.y);\n            // Apply combined rotation (base rotation + wiggle-based rotation)\n            ctx.rotate(this.baseRotation + this.wiggleRotation);\n            // Calculate size using multiplier\n            const height = $35da740d59af89ba$var$METEOR_SIZE * this.type.sizeMultiplier.y;\n            const width = $35da740d59af89ba$var$METEOR_SIZE * this.type.sizeMultiplier.x;\n            // Draw the image centered at the translated position\n            ctx.drawImage(meteorImage, -width / 2, -height / 2, width, height);\n            ctx.restore(); // Restore context state\n        } else {\n            // Fallback to original circle drawing if image isn't loaded\n            ctx.fillStyle = this.type.color;\n            ctx.beginPath();\n            ctx.arc(wiggleX, this.y, 10, 0, Math.PI * 2);\n            ctx.fill();\n        }\n        if ($35da740d59af89ba$var$DEBUG) {\n            // Draw collision circle\n            ctx.strokeStyle = \"rgba(255,0,0,0.3)\";\n            ctx.beginPath();\n            ctx.arc(wiggleX, this.y, 10, 0, Math.PI * 2);\n            ctx.stroke();\n            // Draw health\n            ctx.fillStyle = \"white\";\n            ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n            ctx.textAlign = \"center\";\n            ctx.fillText(`${this.health}`, wiggleX, this.y);\n        }\n    }\n    takeDamage(damage) {\n        this.health -= damage;\n        return this.health <= 0;\n    }\n}\n// Add to existing constants\nclass $35da740d59af89ba$var$Button {\n    constructor(x, y, width, height, text, backgroundColor = $35da740d59af89ba$var$COLORS.BUTTON, textColor = $35da740d59af89ba$var$COLORS.BUTTON_TEXT, fontSize = 16){\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.text = text;\n        this.backgroundColor = backgroundColor;\n        this.textColor = textColor;\n        this.fontSize = fontSize;\n    }\n    isClicked(clickX, clickY) {\n        return clickX >= this.x && clickX <= this.x + this.width && clickY >= this.y && clickY <= this.y + this.height;\n    }\n    draw(ctx) {\n        // Draw button background\n        ctx.fillStyle = this.backgroundColor;\n        ctx.fillRect(this.x, this.y, this.width, this.height);\n        // Draw button text\n        ctx.fillStyle = this.textColor;\n        ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height / 2);\n    }\n}\nclass $35da740d59af89ba$var$Projectile {\n    constructor(x, y, damage){\n        this.x = x;\n        this.y = y;\n        this.speed = 0.3;\n        this.damage = damage;\n        this.size = 4;\n    }\n    update(deltaTime) {\n        this.y -= this.speed * deltaTime;\n    }\n    draw(ctx) {\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n        ctx.fill();\n        if ($35da740d59af89ba$var$DEBUG) {\n            // Draw collision circle\n            ctx.strokeStyle = \"rgba(255,255,0,0.3)\";\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n            ctx.stroke();\n        }\n    }\n    checkCollision(meteor) {\n        const meteorX = $35da740d59af89ba$var$PADDING_LEFT + meteor.lane * $35da740d59af89ba$var$LANE_WIDTH + $35da740d59af89ba$var$LANE_WIDTH / 2;\n        const dx = this.x - meteorX;\n        const dy = this.y - meteor.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        return distance < this.size + 10; // 10 is meteor radius\n    }\n    isOffScreen() {\n        return this.y < $35da740d59af89ba$var$PADDING_TOP;\n    }\n}\n// Add to game constants\nclass $35da740d59af89ba$var$Defense {\n    constructor(type = null){\n        this.type = type;\n        this.health = type ? type.health : 0;\n        this.maxHealth = type ? type.health : 0;\n        this.projectiles = [];\n        this.lastFireTime = 0;\n        this.fireRate = 1000;\n        this.blockingMeteors = []; // Add array to track blocked meteors\n    }\n    isEmpty() {\n        return this.type === null;\n    }\n    takeDamage(amount) {\n        this.health -= amount;\n        return this.health <= 0;\n    }\n    update(currentTime, x, y, meteors, coins) {\n        if (!this.isEmpty()) {\n            // Fire projectile if enough time has passed\n            if (currentTime - this.lastFireTime > this.fireRate) {\n                this.projectiles.push(new $35da740d59af89ba$var$Projectile(x, y, this.type.damage));\n                this.lastFireTime = currentTime;\n            }\n            // Check for meteor collisions with this defense\n            const defenseRow = Math.floor((y - $35da740d59af89ba$var$PADDING_TOP) / $35da740d59af89ba$var$SPOT_SIZE);\n            meteors.forEach((meteor)=>{\n                const meteorRow = Math.floor((meteor.y - $35da740d59af89ba$var$PADDING_TOP) / $35da740d59af89ba$var$SPOT_SIZE);\n                if (meteorRow === defenseRow && meteor.lane === Math.floor((x - $35da740d59af89ba$var$PADDING_LEFT) / $35da740d59af89ba$var$LANE_WIDTH)) {\n                    // Block meteor if not already blocked\n                    if (!meteor.isBlocked) {\n                        meteor.block(this);\n                        this.blockingMeteors.push(meteor); // Track this meteor\n                    }\n                    // Take damage from meteor using meteor's damage rate\n                    if (meteor.blockingDefense === this) {\n                        const destroyed = this.takeDamage(meteor.type.damageRate / 60);\n                        if (destroyed) {\n                            // Unblock all meteors this defense was blocking\n                            this.blockingMeteors.forEach((m)=>m.unblock());\n                            this.blockingMeteors = [];\n                            this.type = null; // Reset defense when destroyed\n                            this.health = 0;\n                            this.maxHealth = 0;\n                        }\n                    }\n                }\n            });\n            // Update existing projectiles and check collisions\n            this.projectiles = this.projectiles.filter((projectile)=>{\n                projectile.update(16);\n                // Check for collisions with any meteor\n                for(let i = 0; i < meteors.length; i++){\n                    const meteor = meteors[i];\n                    if (projectile.checkCollision(meteor)) {\n                        const destroyed = meteor.takeDamage(projectile.damage);\n                        if (destroyed) {\n                            // Spawn coin at meteor's position with meteor's reward value\n                            const meteorX = $35da740d59af89ba$var$PADDING_LEFT + meteor.lane * $35da740d59af89ba$var$LANE_WIDTH + $35da740d59af89ba$var$LANE_WIDTH / 2;\n                            coins.push(new $35da740d59af89ba$var$Coin(meteorX, meteor.y, meteor.type.coinReward));\n                            meteors.splice(i, 1);\n                        }\n                        return false; // Remove projectile\n                    }\n                }\n                return !projectile.isOffScreen();\n            });\n        }\n    }\n    draw(ctx, x, y, size, isSelected = false, isInactive = false) {\n        // Draw spot outline\n        ctx.strokeStyle = this.isEmpty() ? $35da740d59af89ba$var$COLORS.DEBUG_LINE : \"#888\";\n        ctx.lineWidth = 1;\n        ctx.strokeRect(x - size / 2, y - size / 2, size, size);\n        if (!this.isEmpty()) {\n            // Draw defense with health-based opacity\n            ctx.fillStyle = this.type.color;\n            if (isInactive) ctx.globalAlpha = 0.5;\n            else ctx.globalAlpha = Math.max(0.3, this.health / this.maxHealth);\n            ctx.fillRect(x - size / 2, y - size / 2, size, size);\n            ctx.globalAlpha = 1.0;\n            // Draw projectiles\n            this.projectiles.forEach((projectile)=>projectile.draw(ctx));\n            if ($35da740d59af89ba$var$DEBUG) {\n                // Draw health bar\n                ctx.fillStyle = $35da740d59af89ba$var$COLORS.TEXT;\n                ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n                ctx.textAlign = \"center\";\n                ctx.fillText(`${Math.floor(this.health / this.maxHealth * 100)}%`, x, y);\n            }\n            // Draw selection highlight\n            if (isSelected) {\n                ctx.strokeStyle = $35da740d59af89ba$var$COLORS.SELECTION;\n                ctx.lineWidth = 4;\n                ctx.strokeRect(x - size / 2, y - size / 2, size, size);\n            }\n        }\n    }\n}\nclass $35da740d59af89ba$var$DefenseOption {\n    constructor(type, x, y){\n        this.type = type;\n        this.x = x;\n        this.y = y;\n        this.defense = new $35da740d59af89ba$var$Defense(type);\n    }\n    draw(ctx, isSelected = false, currentCurrency = 0) {\n        const isInactive = currentCurrency < this.type.cost;\n        // Draw defense using Defense class\n        this.defense.draw(ctx, this.x + $35da740d59af89ba$var$SPOT_SIZE / 2, this.y + $35da740d59af89ba$var$SPOT_SIZE / 2, $35da740d59af89ba$var$SPOT_SIZE, isSelected, isInactive);\n        // Draw cost (red if can't afford)\n        ctx.fillStyle = isInactive ? $35da740d59af89ba$var$COLORS.DEFENSE_OPTION_TEXT_INACTIVE : $35da740d59af89ba$var$COLORS.DEFENSE_OPTION_TEXT;\n        ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n        ctx.textAlign = \"center\";\n        ctx.fillText(`$${this.type.cost}`, this.x + $35da740d59af89ba$var$SPOT_SIZE / 2, this.y + $35da740d59af89ba$var$SPOT_SIZE + 15);\n    }\n    isClicked(clickX, clickY) {\n        return clickX >= this.x && clickX <= this.x + $35da740d59af89ba$var$SPOT_SIZE && clickY >= this.y && clickY <= this.y + $35da740d59af89ba$var$SPOT_SIZE;\n    }\n}\nclass $35da740d59af89ba$var$DefenseSpot {\n    constructor(x, y, row, lane){\n        this.x = x;\n        this.y = y;\n        this.row = row;\n        this.lane = lane;\n        this.defense = new $35da740d59af89ba$var$Defense();\n    }\n    isEmpty() {\n        return this.defense.isEmpty();\n    }\n    placeDefense(defenseType) {\n        if (this.isEmpty()) {\n            this.defense = new $35da740d59af89ba$var$Defense(defenseType);\n            return true;\n        }\n        return false;\n    }\n    removeDefense() {\n        this.defense = new $35da740d59af89ba$var$Defense(); // Reset to empty defense\n    }\n    draw(ctx) {\n        // Draw defense (or empty spot)\n        this.defense.draw(ctx, this.x, this.y, $35da740d59af89ba$var$SPOT_SIZE);\n        if ($35da740d59af89ba$var$DEBUG) {\n            // Draw coordinates for debugging\n            ctx.fillStyle = $35da740d59af89ba$var$COLORS.DEBUG_TEXT;\n            ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n            ctx.textAlign = \"center\";\n            ctx.fillText(`${this.lane},${this.row}`, this.x, this.y);\n        }\n    }\n    update(currentTime, meteors, coins) {\n        this.defense.update(currentTime, this.x, this.y, meteors, coins);\n    }\n}\nclass $35da740d59af89ba$var$Coin {\n    constructor(x, y, value = 10){\n        this.x = x;\n        this.y = y;\n        this.value = value;\n        this.lifetime = 5000; // 5 seconds lifetime\n        this.createTime = performance.now();\n        this.hitRadius = 30; // Bigger radius for hit detection\n        // Size based on value\n        this.size = 8 + (value - 10) / 10 * 2; // Increases by 2 pixels for each 10 value\n        // Base movement\n        const angle = Math.random() * Math.PI * 2;\n        const speed = 0.3 + Math.random() * 0.1;\n        this.vx = Math.cos(angle) * speed;\n        this.vy = Math.sin(angle) * speed;\n        // Wave motion parameters\n        this.waveAmplitude = 2.2 + Math.random() * 0.2;\n        this.waveFrequency = 0.005 + Math.random() * 0.001;\n        this.waveOffset = Math.random() * Math.PI * 2;\n        this.baseX = x;\n        this.baseY = y;\n        this.time = 0;\n    }\n    draw(ctx, currentTime) {\n        const age = currentTime - this.createTime;\n        const remainingTime = this.lifetime - age;\n        // Start blinking when less than 1.5 seconds remaining\n        if (remainingTime < 1500) {\n            const blinkRate = 100 + remainingTime / 1500 * 400;\n            if (Math.floor(currentTime / blinkRate) % 2 === 0) return;\n        }\n        if ($35da740d59af89ba$var$DEBUG) {\n            // Draw hit area\n            ctx.strokeStyle = \"rgba(255, 80, 80, 0.6)\";\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.hitRadius, 0, Math.PI * 2);\n            ctx.stroke();\n        }\n        const coinX = this.x + Math.sin(this.time * this.waveFrequency + this.waveOffset) * this.waveAmplitude;\n        const coinY = this.y + Math.cos(this.time * this.waveFrequency + this.waveOffset) * this.waveAmplitude;\n        // Draw coin with gradient for more depth\n        const gradient = ctx.createRadialGradient(coinX - this.size / 3, coinY - this.size / 3, 0, coinX, coinY, this.size);\n        gradient.addColorStop(0, \"#FFD700\"); // Bright gold\n        gradient.addColorStop(1, \"#DAA520\"); // Darker gold\n        ctx.fillStyle = gradient;\n        ctx.beginPath();\n        ctx.arc(coinX, coinY, this.size, 0, Math.PI * 2);\n        ctx.fill();\n        // Add coin border\n        ctx.strokeStyle = \"#B8860B\"; // Dark gold\n        ctx.lineWidth = 1;\n        ctx.stroke();\n        // Draw value\n        ctx.fillStyle = \"black\";\n        ctx.font = `bold ${Math.max(10, this.size)}px ${$35da740d59af89ba$var$FONT.SMALL.family}`;\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(`${this.value}`, coinX, coinY);\n    }\n    update(currentTime) {\n        this.time += 16; // Increment time (assuming ~60fps)\n        // Update base position with velocity\n        this.baseX += this.vx;\n        this.baseY += this.vy;\n        // Add wave motion\n        this.x = this.baseX + Math.sin(this.time * this.waveFrequency + this.waveOffset) * this.waveAmplitude;\n        this.y = this.baseY + Math.cos(this.time * this.waveFrequency + this.waveOffset) * this.waveAmplitude;\n        // Calculate remaining lifetime\n        const age = currentTime - this.createTime;\n        return age < this.lifetime;\n    }\n    isClicked(clickX, clickY) {\n        const dx = clickX - this.x;\n        const dy = clickY - this.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        return distance < this.hitRadius;\n    }\n}\nclass $35da740d59af89ba$var$LevelManager {\n    constructor(){\n        this.currentLevel = 0;\n        this.levelStartTime = 0;\n        this.waveStates = new Map();\n        this.allWavesComplete = false;\n    }\n    startLevel(levelIndex) {\n        this.currentLevel = levelIndex;\n        this.levelStartTime = performance.now();\n        this.waveStates = new Map();\n        this.allWavesComplete = false;\n        // Initialize wave states\n        $35da740d59af89ba$var$LEVELS[levelIndex].waves.forEach((wave, index)=>{\n            this.waveStates.set(index, {\n                meteorsSpawned: 0,\n                nextSpawnTime: wave.startTime\n            });\n        });\n    }\n    update(currentTime, meteors) {\n        if (this.currentLevel >= $35da740d59af89ba$var$LEVELS.length) return false;\n        const level = $35da740d59af89ba$var$LEVELS[this.currentLevel];\n        const levelTime = currentTime - this.levelStartTime;\n        // Check if level time is exceeded\n        if (levelTime >= level.duration) {\n            this.allWavesComplete = true;\n            return false;\n        }\n        // Update each wave\n        level.waves.forEach((wave, waveIndex)=>{\n            const state = this.waveStates.get(waveIndex);\n            if (levelTime >= state.nextSpawnTime && state.meteorsSpawned < wave.count) {\n                meteors.push(new $35da740d59af89ba$var$Meteor(Math.floor(Math.random() * $35da740d59af89ba$var$LANES), $35da740d59af89ba$var$METEOR_TYPES[wave.type]));\n                state.meteorsSpawned++;\n                state.nextSpawnTime = levelTime + wave.spacing;\n            }\n        });\n        return true;\n    }\n    isLevelComplete(meteors) {\n        return this.allWavesComplete && meteors.length === 0;\n    }\n    getLevelProgress() {\n        const levelTime = performance.now() - this.levelStartTime;\n        const duration = $35da740d59af89ba$var$LEVELS[this.currentLevel].duration;\n        return Math.min(levelTime / duration, 1);\n    }\n}\nclass $35da740d59af89ba$var$Game {\n    constructor(){\n        this.canvas = document.getElementById(\"canvas\");\n        this.ctx = this.canvas.getContext(\"2d\");\n        this.lastTime = 0;\n        this.meteors = [];\n        this.coins = [];\n        this.assetLoader = new $35da740d59af89ba$var$AssetLoader();\n        this.gameState = $35da740d59af89ba$var$GAME_STATES.LOADING;\n        // Initialize game dimensions and scaling\n        this.initializeCanvas();\n        window.addEventListener(\"resize\", ()=>this.initializeCanvas());\n        // Load assets before starting the game\n        this.loadAssets();\n        // Start game loop\n        requestAnimationFrame((timestamp)=>this.gameLoop(timestamp));\n        // Add test meteor in middle lane\n        this.testMeteor = new $35da740d59af89ba$var$Meteor(2); // Lane 3 (0-based index)\n        // Add game state and button handling\n        this.gameState = $35da740d59af89ba$var$GAME_STATES.MENU;\n        this.setupEventListeners();\n        // Create buttons\n        const buttonWidth = 100;\n        const buttonHeight = 50;\n        const buttonX = $35da740d59af89ba$var$GAME_WIDTH / 2 - buttonWidth / 2;\n        const buttonY = $35da740d59af89ba$var$GAME_HEIGHT / 2 - buttonHeight / 2;\n        this.startButton = new $35da740d59af89ba$var$Button(buttonX, buttonY, buttonWidth, buttonHeight, \"Start Game\");\n        this.retryButton = new $35da740d59af89ba$var$Button(buttonX, buttonY, buttonWidth, buttonHeight, \"Try Again\");\n        this.gameOverText = new $35da740d59af89ba$var$Button($35da740d59af89ba$var$GAME_WIDTH / 2 - 100, $35da740d59af89ba$var$GAME_HEIGHT / 2 - 100, 200, 50, \"Game Over!\", \"transparent\", \"red\", 24);\n        // Initialize currency and defense options\n        this.currency = $35da740d59af89ba$var$INITIAL_CURRENCY;\n        this.defenseOptions = this.createDefenseOptions();\n        this.selectedDefense = null;\n        // Initialize the defense grid\n        this.defenseGrid = this.createDefenseGrid();\n        this.levelManager = new $35da740d59af89ba$var$LevelManager();\n        // Add new buttons\n        this.nextLevelButton = new $35da740d59af89ba$var$Button($35da740d59af89ba$var$GAME_WIDTH / 2 - 60, $35da740d59af89ba$var$GAME_HEIGHT / 2 + 50, 120, 40, \"Next Level\");\n        this.levelCompleteText = new $35da740d59af89ba$var$Button($35da740d59af89ba$var$GAME_WIDTH / 2 - 100, $35da740d59af89ba$var$GAME_HEIGHT / 2 - 50, 200, 50, \"Level Complete!\", \"transparent\", \"#4CAF50\", 24);\n        this.gameCompleteText = new $35da740d59af89ba$var$Button($35da740d59af89ba$var$GAME_WIDTH / 2 - 100, $35da740d59af89ba$var$GAME_HEIGHT / 2 - 50, 200, 50, \"Game Complete!\", \"transparent\", \"#4CAF50\", 24);\n    }\n    initializeCanvas() {\n        // Get dynamic viewport height (accounts for mobile browser UI elements)\n        const viewportWidth = window.innerWidth;\n        const viewportHeight = window.innerHeight;\n        // Calculate maximum possible game size that maintains aspect ratio\n        const gameAspectRatio = $35da740d59af89ba$var$GAME_WIDTH / $35da740d59af89ba$var$GAME_HEIGHT;\n        const viewportAspectRatio = viewportWidth / viewportHeight;\n        let scale;\n        if (viewportAspectRatio > gameAspectRatio) // Viewport is wider than game - fit to height\n        scale = viewportHeight / $35da740d59af89ba$var$GAME_HEIGHT;\n        else // Viewport is taller than game - fit to width\n        scale = viewportWidth / $35da740d59af89ba$var$GAME_WIDTH;\n        // Ensure the scaled size doesn't exceed viewport\n        scale = Math.min(scale, 1);\n        this.canvas.width = $35da740d59af89ba$var$GAME_WIDTH;\n        this.canvas.height = $35da740d59af89ba$var$GAME_HEIGHT;\n        // Apply scale through CSS\n        this.canvas.style.width = `${$35da740d59af89ba$var$GAME_WIDTH * scale}px`;\n        this.canvas.style.height = `${$35da740d59af89ba$var$GAME_HEIGHT * scale}px`;\n    }\n    setupEventListeners() {\n        this.canvas.addEventListener(\"click\", (e)=>{\n            const rect = this.canvas.getBoundingClientRect();\n            const scale = this.canvas.width / rect.width;\n            const x = (e.clientX - rect.left) * scale;\n            const y = (e.clientY - rect.top) * scale;\n            if (this.gameState === $35da740d59af89ba$var$GAME_STATES.MENU) {\n                if (this.startButton.isClicked(x, y)) this.startGame();\n            } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.GAME_OVER) {\n                if (this.retryButton.isClicked(x, y)) this.startGame();\n            } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.LEVEL_COMPLETE) {\n                if (this.nextLevelButton.isClicked(x, y)) this.startNextLevel();\n            } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.PLAYING) {\n                // Check for coin collection first\n                let coinCollected = false;\n                for(let i = this.coins.length - 1; i >= 0; i--){\n                    const coin = this.coins[i];\n                    if (coin.isClicked(x, y)) {\n                        // Add coin value to currency\n                        this.currency += coin.value;\n                        // Remove coin\n                        this.coins.splice(i, 1);\n                        coinCollected = true;\n                        break; // Only collect one coin per click\n                    }\n                }\n                // Only check defense interactions if we didn't collect a coin\n                if (!coinCollected) {\n                    // Check if defense option was clicked\n                    this.defenseOptions.forEach((option)=>{\n                        if (option.isClicked(x, y)) {\n                            if (this.currency >= option.type.cost) {\n                                this.selectedDefense = option.type;\n                                console.log(`Selected ${option.type.name} defense`);\n                            } else console.log(\"Not enough currency!\");\n                        }\n                    });\n                    // Check if grid spot was clicked\n                    if (this.selectedDefense) {\n                        const spot = this.getSpotAtPosition(x, y);\n                        if (spot && spot.isEmpty()) {\n                            if (this.currency >= this.selectedDefense.cost) {\n                                spot.placeDefense(this.selectedDefense);\n                                this.currency -= this.selectedDefense.cost;\n                                this.selectedDefense = null; // Reset selection after placing defense\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    }\n    startGame() {\n        this.gameState = $35da740d59af89ba$var$GAME_STATES.PLAYING;\n        this.meteors = [];\n        this.coins = [];\n        this.currency = $35da740d59af89ba$var$INITIAL_CURRENCY;\n        this.selectedDefense = null;\n        this.levelManager.startLevel(0);\n        // Reset defense grid\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++)this.defenseGrid[row][lane].removeDefense();\n    }\n    startNextLevel() {\n        this.meteors = [];\n        this.coins = [];\n        this.currency = $35da740d59af89ba$var$INITIAL_CURRENCY;\n        this.selectedDefense = null;\n        // Reset defense grid\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++)this.defenseGrid[row][lane].removeDefense();\n        this.levelManager.startLevel(this.levelManager.currentLevel + 1);\n        this.gameState = $35da740d59af89ba$var$GAME_STATES.PLAYING;\n    }\n    gameLoop(timestamp) {\n        // Calculate delta time\n        const deltaTime = timestamp - this.lastTime;\n        this.lastTime = timestamp;\n        // Clear canvas\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        // Update and draw game elements\n        this.update(deltaTime);\n        this.draw();\n        // Continue game loop\n        requestAnimationFrame((timestamp)=>this.gameLoop(timestamp));\n    }\n    drawBackground() {\n        // Fill entire canvas with background color first\n        this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.BACKGROUND;\n        this.ctx.fillRect(0, 0, $35da740d59af89ba$var$GAME_WIDTH, $35da740d59af89ba$var$GAME_HEIGHT);\n        // Draw game area border\n        this.ctx.strokeStyle = $35da740d59af89ba$var$COLORS.BORDER;\n        this.ctx.strokeRect($35da740d59af89ba$var$PADDING_LEFT, $35da740d59af89ba$var$PADDING_TOP, this.gameAreaWidth, this.gameAreaHeight);\n        // Draw lanes\n        for(let i = 0; i <= $35da740d59af89ba$var$LANES; i++){\n            const x = $35da740d59af89ba$var$PADDING_LEFT + i * this.laneWidth;\n            this.ctx.beginPath();\n            this.ctx.moveTo(x, $35da740d59af89ba$var$PADDING_TOP);\n            this.ctx.lineTo(x, $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM);\n            this.ctx.stroke();\n        }\n        // Draw padding areas (slightly darker shade for visual separation)\n        this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.BACKGROUND;\n        // Top padding\n        this.ctx.fillRect(0, 0, $35da740d59af89ba$var$GAME_WIDTH, $35da740d59af89ba$var$PADDING_TOP);\n        // Bottom padding\n        this.ctx.fillRect(0, $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM, $35da740d59af89ba$var$GAME_WIDTH, $35da740d59af89ba$var$PADDING_BOTTOM);\n        // Left padding\n        this.ctx.fillRect(0, $35da740d59af89ba$var$PADDING_TOP, $35da740d59af89ba$var$PADDING_LEFT, this.gameAreaHeight);\n        // Right padding\n        this.ctx.fillRect($35da740d59af89ba$var$GAME_WIDTH - $35da740d59af89ba$var$PADDING_RIGHT, $35da740d59af89ba$var$PADDING_TOP, $35da740d59af89ba$var$PADDING_RIGHT, this.gameAreaHeight);\n        // Draw defense grid\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++)this.defenseGrid[row][lane].draw(this.ctx);\n    }\n    update(deltaTime) {\n        if (this.gameState !== $35da740d59af89ba$var$GAME_STATES.PLAYING) return;\n        const currentTime = performance.now();\n        // Update all defense spots\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++)this.defenseGrid[row][lane].update(currentTime, this.meteors, this.coins);\n        // Update meteors and check for game over\n        this.meteors = this.meteors.filter((meteor)=>{\n            meteor.update(deltaTime);\n            if (meteor.y >= $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM) {\n                this.gameState = $35da740d59af89ba$var$GAME_STATES.GAME_OVER;\n                return false;\n            }\n            return true;\n        });\n        // Update coins\n        this.coins = this.coins.filter((coin)=>coin.update(currentTime));\n        // Update level manager\n        this.levelManager.update(currentTime, this.meteors);\n        // Check for level completion\n        if (this.levelManager.isLevelComplete(this.meteors)) {\n            if (this.levelManager.currentLevel >= $35da740d59af89ba$var$LEVELS.length - 1) this.gameState = $35da740d59af89ba$var$GAME_STATES.GAME_COMPLETE;\n            else this.gameState = $35da740d59af89ba$var$GAME_STATES.LEVEL_COMPLETE;\n        }\n    }\n    drawCurrency() {\n        this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.TEXT;\n        this.ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n        this.ctx.textAlign = \"left\";\n        this.ctx.fillText(`Currency: $${this.currency}`, $35da740d59af89ba$var$PADDING_LEFT / 3, $35da740d59af89ba$var$PADDING_TOP / 4 * 3);\n    }\n    draw() {\n        this.drawBackground();\n        if (this.gameState === $35da740d59af89ba$var$GAME_STATES.LOADING) this.drawLoadingScreen();\n        else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.MENU) this.startButton.draw(this.ctx);\n        else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.PLAYING) {\n            // Draw currency\n            this.drawCurrency();\n            // Draw progress bar\n            this.drawProgressBar(this.ctx);\n            // Draw defense options\n            this.defenseOptions.forEach((option)=>{\n                option.draw(this.ctx, this.selectedDefense && option.type.id === this.selectedDefense.id, this.currency);\n            });\n            // Draw meteors\n            this.meteors.forEach((meteor)=>meteor.draw(this.ctx));\n            // Draw coins\n            const currentTime = performance.now();\n            this.coins.forEach((coin)=>coin.draw(this.ctx, currentTime));\n        } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.LEVEL_COMPLETE) {\n            this.levelCompleteText.draw(this.ctx);\n            this.nextLevelButton.draw(this.ctx);\n        } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.GAME_COMPLETE) this.gameCompleteText.draw(this.ctx);\n        else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.GAME_OVER) {\n            this.gameOverText.draw(this.ctx);\n            this.retryButton.draw(this.ctx);\n        }\n    }\n    createDefenseOptions() {\n        const optionsAreaY = $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM + 20; // Position below game grid\n        const spacing = 20; // Space between options\n        const totalWidth = ($35da740d59af89ba$var$SPOT_SIZE + spacing) * $35da740d59af89ba$var$DEFENSE_TYPES.length - spacing;\n        const startX = ($35da740d59af89ba$var$GAME_WIDTH - totalWidth) / 2; // Center the options horizontally\n        return $35da740d59af89ba$var$DEFENSE_TYPES.map((type, index)=>{\n            const x = startX + index * ($35da740d59af89ba$var$SPOT_SIZE + spacing);\n            const y = optionsAreaY;\n            return new $35da740d59af89ba$var$DefenseOption(type, x, y);\n        });\n    }\n    createDefenseGrid() {\n        const grid = [];\n        // Create 2D array for easier position reference\n        for(let row = 0; row < $35da740d59af89ba$var$GRID_ROWS; row++){\n            const rowArray = [];\n            for(let lane = 0; lane < $35da740d59af89ba$var$LANES; lane++){\n                const x = $35da740d59af89ba$var$PADDING_LEFT + lane * $35da740d59af89ba$var$LANE_WIDTH + $35da740d59af89ba$var$LANE_WIDTH / 2;\n                const y = $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM - row * $35da740d59af89ba$var$SPOT_SIZE - $35da740d59af89ba$var$SPOT_SIZE / 2;\n                rowArray.push(new $35da740d59af89ba$var$DefenseSpot(x, y, row, lane));\n            }\n            grid.push(rowArray);\n        }\n        return grid;\n    }\n    // Helper method to get spot at specific coordinates\n    getSpotAtPosition(x, y) {\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++){\n            const spot = this.defenseGrid[row][lane];\n            if (x >= spot.x - $35da740d59af89ba$var$SPOT_SIZE / 2 && x <= spot.x + $35da740d59af89ba$var$SPOT_SIZE / 2 && y >= spot.y - $35da740d59af89ba$var$SPOT_SIZE / 2 && y <= spot.y + $35da740d59af89ba$var$SPOT_SIZE / 2) return spot;\n        }\n        return null;\n    }\n    drawProgressBar(ctx) {\n        // Draw progress bar background\n        const barWidth = $35da740d59af89ba$var$GAME_WIDTH - 100; // Leave some padding\n        const barHeight = 20;\n        const x = 50; // Padding from left\n        const y = 20; // Padding from top\n        // Background\n        ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n        ctx.fillRect(x, y, barWidth, barHeight);\n        // Progress (inverted to show remaining time)\n        const progress = 1 - this.levelManager.getLevelProgress();\n        ctx.fillStyle = $35da740d59af89ba$var$COLORS.PROGRESS_BAR;\n        ctx.fillRect(x, y, barWidth * progress, barHeight);\n        // Border\n        ctx.strokeStyle = $35da740d59af89ba$var$COLORS.BORDER;\n        ctx.strokeRect(x, y, barWidth, barHeight);\n        // Level text\n        ctx.fillStyle = $35da740d59af89ba$var$COLORS.TEXT;\n        ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n        ctx.textAlign = \"center\";\n        ctx.fillText(`${$35da740d59af89ba$var$LEVELS[this.levelManager.currentLevel].name}`, $35da740d59af89ba$var$GAME_WIDTH / 2, y + barHeight + 16);\n        // Time remaining\n        const timeLeft = Math.ceil(($35da740d59af89ba$var$LEVELS[this.levelManager.currentLevel].duration - (performance.now() - this.levelManager.levelStartTime)) / 1000);\n        if (timeLeft > 0) {\n            ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n            ctx.fillText(`${timeLeft}s`, $35da740d59af89ba$var$GAME_WIDTH - 30, y + barHeight / 2 + 5);\n        }\n    }\n    async loadAssets() {\n        const success = await this.assetLoader.loadAll();\n        if (success) this.gameState = $35da740d59af89ba$var$GAME_STATES.MENU;\n        else console.error(\"Failed to load assets\");\n    }\n    drawLoadingScreen() {\n        const progress = this.assetLoader.getLoadingProgress();\n        // Draw loading bar\n        const barWidth = 200;\n        const barHeight = 20;\n        const x = ($35da740d59af89ba$var$GAME_WIDTH - barWidth) / 2;\n        const y = $35da740d59af89ba$var$GAME_HEIGHT / 2;\n        // Background\n        this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.BUTTON;\n        this.ctx.fillRect(x, y, barWidth, barHeight);\n        // Progress\n        this.ctx.fillStyle = \"#4CAF50\";\n        this.ctx.fillRect(x, y, barWidth * progress, barHeight);\n        // Border\n        this.ctx.strokeStyle = $35da740d59af89ba$var$COLORS.TEXT;\n        this.ctx.strokeRect(x, y, barWidth, barHeight);\n        // Loading text\n        this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.TEXT;\n        this.ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n        this.ctx.textAlign = \"center\";\n        this.ctx.fillText(\"Loading...\", $35da740d59af89ba$var$GAME_WIDTH / 2, y - 20);\n        this.ctx.fillText(`${Math.floor(progress * 100)}%`, $35da740d59af89ba$var$GAME_WIDTH / 2, y + 40);\n    }\n}\n// Start the game when the page loads\nwindow.addEventListener(\"load\", ()=>{\n    $35da740d59af89ba$var$game = new $35da740d59af89ba$var$Game();\n});\n\n\n//# sourceMappingURL=index.4ce387a3.js.map\n","// Game constants\nconst GAME_WIDTH = 360; // Base width, will be scaled\nconst GAME_HEIGHT = 640; // 16:9 ratio\nconst LANES = 6;\nconst PADDING_TOP = 80; // More space for score/level\nconst PADDING_BOTTOM = 90; // More space for controls/UI\nconst PADDING_LEFT = 40;\nconst PADDING_RIGHT = 40;\n\nconst INITIAL_CURRENCY = 500;\n\n// Game area calculations\nconst GAME_AREA_WIDTH = GAME_WIDTH - (PADDING_LEFT + PADDING_RIGHT);\nconst GAME_AREA_HEIGHT = GAME_HEIGHT - (PADDING_TOP + PADDING_BOTTOM);\nconst LANE_WIDTH = GAME_AREA_WIDTH / LANES; // Width of each lane\nconst SPOT_SIZE = LANE_WIDTH; // Defense spots are same width as lanes\nconst METEOR_SIZE = LANE_WIDTH * 0.8; // Base size for meteors\nconst GRID_ROWS = Math.floor(GAME_AREA_HEIGHT / SPOT_SIZE);\n\n// Add to game constants\nconst DEBUG = false; // Toggle for development visualization\n\nconst COLORS = {\n  BACKGROUND: \"#edf1e7\",\n  TEXT: \"#000\",\n  DEFENSE_OPTION_TEXT: \"#000\",\n  DEFENSE_OPTION_TEXT_INACTIVE: \"#f00\",\n  BUTTON: \"#444\",\n  BUTTON_TEXT: \"#fff\",\n  PROGRESS_BAR: \"#4CAF50\",\n  BORDER: \"#333\",\n  DEBUG_LINE: \"rgba(0,0,0,0.1)\",\n  DEBUG_TEXT: \"#666\",\n  SELECTION: \"rgba(255,80,80,0.7)\",\n};\n\n// Replace the LEVELS constant with this generator\nconst LEVELS = generateLevels();\n\nfunction generateLevels() {\n  const levels = [];\n\n  // Base multipliers for level-to-level scaling\n  const levelSpawnMultiplier = 0.3;\n  const levelCountMultiplier = 0.2;\n  const levelDangerMultiplier = 0.15; // New: Controls danger increase across levels\n\n  for (let i = 0; i < 10; i++) {\n    const levelIndex = i + 1;\n    const duration = 150000; // 2min 30sec in milliseconds\n\n    // Level-wide difficulty multipliers\n    const baseSpawnMultiplier = 1 + i * levelSpawnMultiplier;\n    const baseCountMultiplier = 1 + i * levelCountMultiplier;\n    const baseDangerMultiplier = 1 + i * levelDangerMultiplier; // New: Base danger for this level\n\n    const waves = [];\n    let currentTime = 500;\n\n    // Track progress through level for intra-level scaling\n    while (currentTime < duration) {\n      // Calculate progress through level (0 to 1)\n      const levelProgress = currentTime / duration;\n      \n      // Increase difficulty within level (xxx% harder by end of level)\n      const intraLevelMultiplier = 1 + levelProgress * 1.2;\n\n      // Combined multipliers for this wave\n      const spawnMultiplier = baseSpawnMultiplier * intraLevelMultiplier;\n      const countMultiplier = baseCountMultiplier * intraLevelMultiplier;\n\n      // Calculate danger probability based on level progress AND overall level\n      const progressDanger = levelProgress * 0.7; // Increases from 0 to 0.7 within level\n      const levelDanger = (levelIndex - 1) * 0.1; // Increases by 0.1 per level\n      const totalDangerFactor = (progressDanger + levelDanger) * baseDangerMultiplier;\n\n      // Determine meteor type based on combined danger factor\n      let meteorType;\n      const random = Math.random();\n      \n      if (random < 0.2 * totalDangerFactor) {\n        meteorType = 2; // Large meteor\n      } else if (random < 0.4 * totalDangerFactor) {\n        meteorType = 1; // Medium meteor\n      } else {\n        meteorType = 0; // Small meteor\n      }\n\n      // Base counts and spacing (adjusted for balance)\n      const baseCount = meteorType === 2 ? 1 : meteorType === 1 ? 2 : 3;\n      const count = Math.ceil(baseCount * countMultiplier);\n      const spacing = meteorType === 2 ? 2500 : meteorType === 1 ? 1500 : 1000;\n\n      waves.push({\n        type: meteorType,\n        count: count,\n        startTime: currentTime,\n        spacing: spacing / spawnMultiplier,\n      });\n\n      // Wave timing\n      const waveLength = (count * spacing) / spawnMultiplier;\n      const breakTime = Math.max(2000 - levelProgress * 1000, 500); // Breaks get shorter\n      currentTime += waveLength + breakTime;\n    }\n\n    levels.push({\n      name: `Level ${levelIndex}`,\n      duration: duration,\n      waves: waves,\n    });\n  }\n\n  return levels;\n}\n\nconst GAME_STATES = {\n  LOADING: \"loading\",\n  MENU: \"menu\",\n  PLAYING: \"playing\",\n  LEVEL_COMPLETE: \"levelComplete\",\n  GAME_OVER: \"gameover\",\n  GAME_COMPLETE: \"gameComplete\",\n};\n\n// Add to game constants\nconst DEFENSE_TYPES = [\n  {\n    id: 0,\n    name: \"Basic\",\n    color: \"#4CAF50\",\n    cost: 100,\n    damage: 10,\n    health: 100,\n  },\n  {\n    id: 1,\n    name: \"Medium\",\n    color: \"#2196F3\",\n    cost: 200,\n    damage: 20,\n    health: 100,\n  },\n  {\n    id: 2,\n    name: \"Strong\",\n    color: \"#9C27B0\",\n    cost: 300,\n    damage: 30,\n    health: 100,\n  },\n];\n\n// Add to game constants\nconst METEOR_TYPES = [\n  {\n    id: 0,\n    name: \"Small\",\n    color: \"#FF9999\",\n    health: 40,\n    speed: 0.05,\n    damageRate: 30,\n    rotateRate: 0.0005,\n    wiggleRate: 0.001,\n    wiggleAmount: 7,\n    sizeMultiplier: { x: 1.0, y: 1.0 },\n    coinReward: 10, // 1 coin\n  },\n  {\n    id: 1,\n    name: \"Medium\",\n    color: \"#FF4444\",\n    health: 60,\n    speed: 0.035,\n    damageRate: 50,\n    rotateRate: 0,\n    wiggleRate: 0.03,\n    wiggleAmount: 0.03,\n    sizeMultiplier: { x: 1, y: 2 },\n    coinReward: 15, // 2 coins\n  },\n  {\n    id: 2,\n    name: \"Large\",\n    color: \"#FF0000\",\n    health: 90,\n    speed: 0.05,\n    damageRate: 50,\n    rotateRate: 0,\n    wiggleRate: 0.03,\n    wiggleAmount: 0.03,\n    sizeMultiplier: { x: 1, y: 2 },\n    coinReward: 20, // 3 coins\n  },\n];\n\n// Font definitions\nconst FONT = {\n  SMALL: {\n    size: \"12px\",\n    family: \"Arial\",\n    get full() {\n      return `${this.size} ${this.family}`;\n    },\n  },\n  LARGE: {\n    size: \"14px\",\n    family: \"Arial\",\n    get full() {\n      return `${this.size} ${this.family}`;\n    },\n  },\n};\n\n// Add at the top of the file, after other constants\nconst ASSETS = {\n  METEORS: [\n    \"/assets/img/meteor-1.png\",\n    \"/assets/img/meteor-2.png\",\n    \"/assets/img/meteor-3.png\",\n  ],\n};\n\n// Add new AssetLoader class\nclass AssetLoader {\n  constructor() {\n    this.images = new Map();\n    this.totalAssets = 0;\n    this.loadedAssets = 0;\n  }\n\n  async loadAll() {\n    const meteorPromises = ASSETS.METEORS.map((path, index) =>\n      this.loadImage(`meteor-${index}`, path),\n    );\n\n    try {\n      await Promise.all(meteorPromises);\n      return true;\n    } catch (error) {\n      console.error(\"Error loading assets:\", error);\n      return false;\n    }\n  }\n\n  loadImage(key, src) {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      this.totalAssets++;\n\n      img.onload = () => {\n        this.images.set(key, img);\n        this.loadedAssets++;\n        resolve(img);\n      };\n\n      img.onerror = () => {\n        reject(new Error(`Failed to load image: ${src}`));\n      };\n\n      img.src = src;\n    });\n  }\n\n  getImage(key) {\n    return this.images.get(key);\n  }\n\n  getLoadingProgress() {\n    return this.totalAssets ? this.loadedAssets / this.totalAssets : 0;\n  }\n}\n\n// Add at the top of the file, after constants\nlet game; // Global game instance\n\n// Test meteor\nclass Meteor {\n  constructor(lane, type = METEOR_TYPES[0]) {\n    this.lane = lane;\n    this.type = type;\n    this.y = PADDING_TOP;\n    this.health = type.health;\n    this.speed = type.speed;\n    this.isBlocked = false;\n    this.blockingDefense = null;\n\n    // Add rotation and wiggle properties\n    this.baseRotation = 0; // Base rotation from type.rotateRate\n    this.wiggleRotation = 0; // Additional rotation from wiggle motion\n    this.wiggleOffset = 0;\n    this.baseX = PADDING_LEFT + lane * LANE_WIDTH + LANE_WIDTH / 2;\n  }\n\n  update(deltaTime) {\n    if (!this.isBlocked) {\n      this.y += this.speed * deltaTime;\n\n      // Update base rotation\n      this.baseRotation += this.type.rotateRate * deltaTime;\n\n      // Update wiggle and calculate wiggle-based rotation\n      this.wiggleOffset += this.type.wiggleRate * deltaTime;\n      // Calculate rotation based on wiggle movement (adjust 0.5 to control rotation intensity)\n      this.wiggleRotation =\n        Math.cos(this.wiggleOffset) * this.type.wiggleAmount * 0.5;\n    }\n  }\n\n  block(defense) {\n    this.isBlocked = true;\n    this.blockingDefense = defense;\n  }\n\n  unblock() {\n    this.isBlocked = false;\n    this.blockingDefense = null;\n  }\n\n  draw(ctx) {\n    // Calculate wiggled x position\n    const wiggleX =\n      this.baseX + Math.sin(this.wiggleOffset) * this.type.wiggleAmount;\n\n    // Get the corresponding meteor image\n    const meteorImage = game?.assetLoader.getImage(`meteor-${this.type.id}`);\n\n    if (meteorImage) {\n      ctx.save(); // Save current context state\n\n      // Translate to meteor position\n      ctx.translate(wiggleX, this.y);\n\n      // Apply combined rotation (base rotation + wiggle-based rotation)\n      ctx.rotate(this.baseRotation + this.wiggleRotation);\n\n      // Calculate size using multiplier\n      const height = METEOR_SIZE * this.type.sizeMultiplier.y;\n      const width = METEOR_SIZE * this.type.sizeMultiplier.x;\n\n      // Draw the image centered at the translated position\n      ctx.drawImage(meteorImage, -width / 2, -height / 2, width, height);\n\n      ctx.restore(); // Restore context state\n    } else {\n      // Fallback to original circle drawing if image isn't loaded\n      ctx.fillStyle = this.type.color;\n      ctx.beginPath();\n      ctx.arc(wiggleX, this.y, 10, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    if (DEBUG) {\n      // Draw collision circle\n      ctx.strokeStyle = \"rgba(255,0,0,0.3)\";\n      ctx.beginPath();\n      ctx.arc(wiggleX, this.y, 10, 0, Math.PI * 2);\n      ctx.stroke();\n\n      // Draw health\n      ctx.fillStyle = \"white\";\n      ctx.font = FONT.SMALL.full;\n      ctx.textAlign = \"center\";\n      ctx.fillText(`${this.health}`, wiggleX, this.y);\n    }\n  }\n\n  takeDamage(damage) {\n    this.health -= damage;\n    return this.health <= 0;\n  }\n}\n\n// Add to existing constants\nclass Button {\n  constructor(\n    x,\n    y,\n    width,\n    height,\n    text,\n    backgroundColor = COLORS.BUTTON,\n    textColor = COLORS.BUTTON_TEXT,\n    fontSize = 16,\n  ) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.text = text;\n    this.backgroundColor = backgroundColor;\n    this.textColor = textColor;\n    this.fontSize = fontSize;\n  }\n\n  isClicked(clickX, clickY) {\n    return (\n      clickX >= this.x &&\n      clickX <= this.x + this.width &&\n      clickY >= this.y &&\n      clickY <= this.y + this.height\n    );\n  }\n\n  draw(ctx) {\n    // Draw button background\n    ctx.fillStyle = this.backgroundColor;\n    ctx.fillRect(this.x, this.y, this.width, this.height);\n\n    // Draw button text\n    ctx.fillStyle = this.textColor;\n    ctx.font = FONT.LARGE.full;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height / 2);\n  }\n}\n\nclass Projectile {\n  constructor(x, y, damage) {\n    this.x = x;\n    this.y = y;\n    this.speed = 0.3;\n    this.damage = damage;\n    this.size = 4;\n  }\n\n  update(deltaTime) {\n    this.y -= this.speed * deltaTime;\n  }\n\n  draw(ctx) {\n    ctx.fillStyle = \"black\";\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n    ctx.fill();\n\n    if (DEBUG) {\n      // Draw collision circle\n      ctx.strokeStyle = \"rgba(255,255,0,0.3)\";\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n  }\n\n  checkCollision(meteor) {\n    const meteorX = PADDING_LEFT + meteor.lane * LANE_WIDTH + LANE_WIDTH / 2;\n    const dx = this.x - meteorX;\n    const dy = this.y - meteor.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < this.size + 10; // 10 is meteor radius\n  }\n\n  isOffScreen() {\n    return this.y < PADDING_TOP;\n  }\n}\n\n// Add to game constants\nclass Defense {\n  constructor(type = null) {\n    this.type = type;\n    this.health = type ? type.health : 0;\n    this.maxHealth = type ? type.health : 0;\n    this.projectiles = [];\n    this.lastFireTime = 0;\n    this.fireRate = 1000;\n    this.blockingMeteors = []; // Add array to track blocked meteors\n  }\n\n  isEmpty() {\n    return this.type === null;\n  }\n\n  takeDamage(amount) {\n    this.health -= amount;\n    return this.health <= 0;\n  }\n\n  update(currentTime, x, y, meteors, coins) {\n    if (!this.isEmpty()) {\n      // Fire projectile if enough time has passed\n      if (currentTime - this.lastFireTime > this.fireRate) {\n        this.projectiles.push(new Projectile(x, y, this.type.damage));\n        this.lastFireTime = currentTime;\n      }\n\n      // Check for meteor collisions with this defense\n      const defenseRow = Math.floor((y - PADDING_TOP) / SPOT_SIZE);\n      meteors.forEach((meteor) => {\n        const meteorRow = Math.floor((meteor.y - PADDING_TOP) / SPOT_SIZE);\n        if (\n          meteorRow === defenseRow &&\n          meteor.lane === Math.floor((x - PADDING_LEFT) / LANE_WIDTH)\n        ) {\n          // Block meteor if not already blocked\n          if (!meteor.isBlocked) {\n            meteor.block(this);\n            this.blockingMeteors.push(meteor); // Track this meteor\n          }\n\n          // Take damage from meteor using meteor's damage rate\n          if (meteor.blockingDefense === this) {\n            const destroyed = this.takeDamage(meteor.type.damageRate / 60);\n            if (destroyed) {\n              // Unblock all meteors this defense was blocking\n              this.blockingMeteors.forEach((m) => m.unblock());\n              this.blockingMeteors = [];\n              this.type = null; // Reset defense when destroyed\n              this.health = 0;\n              this.maxHealth = 0;\n            }\n          }\n        }\n      });\n\n      // Update existing projectiles and check collisions\n      this.projectiles = this.projectiles.filter((projectile) => {\n        projectile.update(16);\n\n        // Check for collisions with any meteor\n        for (let i = 0; i < meteors.length; i++) {\n          const meteor = meteors[i];\n          if (projectile.checkCollision(meteor)) {\n            const destroyed = meteor.takeDamage(projectile.damage);\n            if (destroyed) {\n              // Spawn coin at meteor's position with meteor's reward value\n              const meteorX =\n                PADDING_LEFT + meteor.lane * LANE_WIDTH + LANE_WIDTH / 2;\n              coins.push(new Coin(meteorX, meteor.y, meteor.type.coinReward));\n              meteors.splice(i, 1);\n            }\n            return false; // Remove projectile\n          }\n        }\n\n        return !projectile.isOffScreen();\n      });\n    }\n  }\n\n  draw(ctx, x, y, size, isSelected = false, isInactive = false) {\n    // Draw spot outline\n    ctx.strokeStyle = this.isEmpty() ? COLORS.DEBUG_LINE : \"#888\";\n    ctx.lineWidth = 1;\n    ctx.strokeRect(x - size / 2, y - size / 2, size, size);\n\n    if (!this.isEmpty()) {\n      // Draw defense with health-based opacity\n      ctx.fillStyle = this.type.color;\n      if (isInactive) {\n        ctx.globalAlpha = 0.5;\n      } else {\n        ctx.globalAlpha = Math.max(0.3, this.health / this.maxHealth);\n      }\n      ctx.fillRect(x - size / 2, y - size / 2, size, size);\n      ctx.globalAlpha = 1.0;\n\n      // Draw projectiles\n      this.projectiles.forEach((projectile) => projectile.draw(ctx));\n\n      if (DEBUG) {\n        // Draw health bar\n        ctx.fillStyle = COLORS.TEXT;\n        ctx.font = FONT.SMALL.full;\n        ctx.textAlign = \"center\";\n        ctx.fillText(\n          `${Math.floor((this.health / this.maxHealth) * 100)}%`,\n          x,\n          y,\n        );\n      }\n\n      // Draw selection highlight\n      if (isSelected) {\n        ctx.strokeStyle = COLORS.SELECTION;\n        ctx.lineWidth = 4;\n        ctx.strokeRect(x - size / 2, y - size / 2, size, size);\n      }\n    }\n  }\n}\n\nclass DefenseOption {\n  constructor(type, x, y) {\n    this.type = type;\n    this.x = x;\n    this.y = y;\n    this.defense = new Defense(type);\n  }\n\n  draw(ctx, isSelected = false, currentCurrency = 0) {\n    const isInactive = currentCurrency < this.type.cost;\n\n    // Draw defense using Defense class\n    this.defense.draw(\n      ctx,\n      this.x + SPOT_SIZE / 2,\n      this.y + SPOT_SIZE / 2,\n      SPOT_SIZE,\n      isSelected,\n      isInactive,\n    );\n\n    // Draw cost (red if can't afford)\n    ctx.fillStyle = isInactive\n      ? COLORS.DEFENSE_OPTION_TEXT_INACTIVE\n      : COLORS.DEFENSE_OPTION_TEXT;\n    ctx.font = FONT.LARGE.full;\n    ctx.textAlign = \"center\";\n    ctx.fillText(\n      `$${this.type.cost}`,\n      this.x + SPOT_SIZE / 2,\n      this.y + SPOT_SIZE + 15,\n    );\n  }\n\n  isClicked(clickX, clickY) {\n    return (\n      clickX >= this.x &&\n      clickX <= this.x + SPOT_SIZE &&\n      clickY >= this.y &&\n      clickY <= this.y + SPOT_SIZE\n    );\n  }\n}\n\nclass DefenseSpot {\n  constructor(x, y, row, lane) {\n    this.x = x;\n    this.y = y;\n    this.row = row;\n    this.lane = lane;\n    this.defense = new Defense();\n  }\n\n  isEmpty() {\n    return this.defense.isEmpty();\n  }\n\n  placeDefense(defenseType) {\n    if (this.isEmpty()) {\n      this.defense = new Defense(defenseType);\n      return true;\n    }\n    return false;\n  }\n\n  removeDefense() {\n    this.defense = new Defense(); // Reset to empty defense\n  }\n\n  draw(ctx) {\n    // Draw defense (or empty spot)\n    this.defense.draw(ctx, this.x, this.y, SPOT_SIZE);\n\n    if (DEBUG) {\n      // Draw coordinates for debugging\n      ctx.fillStyle = COLORS.DEBUG_TEXT;\n      ctx.font = FONT.SMALL.full;\n      ctx.textAlign = \"center\";\n      ctx.fillText(`${this.lane},${this.row}`, this.x, this.y);\n    }\n  }\n\n  update(currentTime, meteors, coins) {\n    this.defense.update(currentTime, this.x, this.y, meteors, coins);\n  }\n}\n\nclass Coin {\n  constructor(x, y, value = 10) {\n    this.x = x;\n    this.y = y;\n    this.value = value;\n    this.lifetime = 5000; // 5 seconds lifetime\n    this.createTime = performance.now();\n    this.hitRadius = 30; // Bigger radius for hit detection\n\n    // Size based on value\n    this.size = 8 + ((value - 10) / 10) * 2; // Increases by 2 pixels for each 10 value\n\n    // Base movement\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.1;\n    this.vx = Math.cos(angle) * speed;\n    this.vy = Math.sin(angle) * speed;\n\n    // Wave motion parameters\n    this.waveAmplitude = 2.2 + Math.random() * 0.2;\n    this.waveFrequency = 0.005 + Math.random() * 0.001;\n    this.waveOffset = Math.random() * Math.PI * 2;\n    this.baseX = x;\n    this.baseY = y;\n    this.time = 0;\n  }\n\n  draw(ctx, currentTime) {\n    const age = currentTime - this.createTime;\n    const remainingTime = this.lifetime - age;\n\n    // Start blinking when less than 1.5 seconds remaining\n    if (remainingTime < 1500) {\n      const blinkRate = 100 + (remainingTime / 1500) * 400;\n      if (Math.floor(currentTime / blinkRate) % 2 === 0) {\n        return;\n      }\n    }\n\n    if (DEBUG) {\n      // Draw hit area\n      ctx.strokeStyle = \"rgba(255, 80, 80, 0.6)\";\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, this.hitRadius, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n\n    const coinX =\n      this.x +\n      Math.sin(this.time * this.waveFrequency + this.waveOffset) *\n        this.waveAmplitude;\n    const coinY =\n      this.y +\n      Math.cos(this.time * this.waveFrequency + this.waveOffset) *\n        this.waveAmplitude;\n\n    // Draw coin with gradient for more depth\n    const gradient = ctx.createRadialGradient(\n      coinX - this.size / 3,\n      coinY - this.size / 3,\n      0,\n      coinX,\n      coinY,\n      this.size,\n    );\n    gradient.addColorStop(0, \"#FFD700\"); // Bright gold\n    gradient.addColorStop(1, \"#DAA520\"); // Darker gold\n\n    ctx.fillStyle = gradient;\n    ctx.beginPath();\n    ctx.arc(coinX, coinY, this.size, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Add coin border\n    ctx.strokeStyle = \"#B8860B\"; // Dark gold\n    ctx.lineWidth = 1;\n    ctx.stroke();\n\n    // Draw value\n    ctx.fillStyle = \"black\";\n    ctx.font = `bold ${Math.max(10, this.size)}px ${FONT.SMALL.family}`;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(`${this.value}`, coinX, coinY);\n  }\n\n  update(currentTime) {\n    this.time += 16; // Increment time (assuming ~60fps)\n\n    // Update base position with velocity\n    this.baseX += this.vx;\n    this.baseY += this.vy;\n\n    // Add wave motion\n    this.x =\n      this.baseX +\n      Math.sin(this.time * this.waveFrequency + this.waveOffset) *\n        this.waveAmplitude;\n    this.y =\n      this.baseY +\n      Math.cos(this.time * this.waveFrequency + this.waveOffset) *\n        this.waveAmplitude;\n\n    // Calculate remaining lifetime\n    const age = currentTime - this.createTime;\n    return age < this.lifetime;\n  }\n\n  isClicked(clickX, clickY) {\n    const dx = clickX - this.x;\n    const dy = clickY - this.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < this.hitRadius;\n  }\n}\n\nclass LevelManager {\n  constructor() {\n    this.currentLevel = 0;\n    this.levelStartTime = 0;\n    this.waveStates = new Map();\n    this.allWavesComplete = false;\n  }\n\n  startLevel(levelIndex) {\n    this.currentLevel = levelIndex;\n    this.levelStartTime = performance.now();\n    this.waveStates = new Map();\n    this.allWavesComplete = false;\n\n    // Initialize wave states\n    LEVELS[levelIndex].waves.forEach((wave, index) => {\n      this.waveStates.set(index, {\n        meteorsSpawned: 0,\n        nextSpawnTime: wave.startTime,\n      });\n    });\n  }\n\n  update(currentTime, meteors) {\n    if (this.currentLevel >= LEVELS.length) return false;\n\n    const level = LEVELS[this.currentLevel];\n    const levelTime = currentTime - this.levelStartTime;\n\n    // Check if level time is exceeded\n    if (levelTime >= level.duration) {\n      this.allWavesComplete = true;\n      return false;\n    }\n\n    // Update each wave\n    level.waves.forEach((wave, waveIndex) => {\n      const state = this.waveStates.get(waveIndex);\n\n      if (\n        levelTime >= state.nextSpawnTime &&\n        state.meteorsSpawned < wave.count\n      ) {\n        meteors.push(\n          new Meteor(\n            Math.floor(Math.random() * LANES),\n            METEOR_TYPES[wave.type],\n          ),\n        );\n\n        state.meteorsSpawned++;\n        state.nextSpawnTime = levelTime + wave.spacing;\n      }\n    });\n\n    return true;\n  }\n\n  isLevelComplete(meteors) {\n    return this.allWavesComplete && meteors.length === 0;\n  }\n\n  getLevelProgress() {\n    const levelTime = performance.now() - this.levelStartTime;\n    const duration = LEVELS[this.currentLevel].duration;\n    return Math.min(levelTime / duration, 1);\n  }\n}\n\nclass Game {\n  constructor() {\n    this.canvas = document.getElementById(\"canvas\");\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.lastTime = 0;\n    this.meteors = [];\n    this.coins = [];\n    this.assetLoader = new AssetLoader();\n    this.gameState = GAME_STATES.LOADING;\n\n    // Initialize game dimensions and scaling\n    this.initializeCanvas();\n    window.addEventListener(\"resize\", () => this.initializeCanvas());\n\n    // Load assets before starting the game\n    this.loadAssets();\n\n    // Start game loop\n    requestAnimationFrame((timestamp) => this.gameLoop(timestamp));\n\n    // Add test meteor in middle lane\n    this.testMeteor = new Meteor(2); // Lane 3 (0-based index)\n\n    // Add game state and button handling\n    this.gameState = GAME_STATES.MENU;\n    this.setupEventListeners();\n\n    // Create buttons\n    const buttonWidth = 100;\n    const buttonHeight = 50;\n    const buttonX = GAME_WIDTH / 2 - buttonWidth / 2;\n    const buttonY = GAME_HEIGHT / 2 - buttonHeight / 2;\n\n    this.startButton = new Button(\n      buttonX,\n      buttonY,\n      buttonWidth,\n      buttonHeight,\n      \"Start Game\",\n    );\n    this.retryButton = new Button(\n      buttonX,\n      buttonY,\n      buttonWidth,\n      buttonHeight,\n      \"Try Again\",\n    );\n    this.gameOverText = new Button(\n      GAME_WIDTH / 2 - 100,\n      GAME_HEIGHT / 2 - 100,\n      200,\n      50,\n      \"Game Over!\",\n      \"transparent\",\n      \"red\",\n      24,\n    );\n\n    // Initialize currency and defense options\n    this.currency = INITIAL_CURRENCY;\n    this.defenseOptions = this.createDefenseOptions();\n    this.selectedDefense = null;\n\n    // Initialize the defense grid\n    this.defenseGrid = this.createDefenseGrid();\n\n    this.levelManager = new LevelManager();\n\n    // Add new buttons\n    this.nextLevelButton = new Button(\n      GAME_WIDTH / 2 - 60,\n      GAME_HEIGHT / 2 + 50,\n      120,\n      40,\n      \"Next Level\",\n    );\n\n    this.levelCompleteText = new Button(\n      GAME_WIDTH / 2 - 100,\n      GAME_HEIGHT / 2 - 50,\n      200,\n      50,\n      \"Level Complete!\",\n      \"transparent\",\n      \"#4CAF50\",\n      24,\n    );\n\n    this.gameCompleteText = new Button(\n      GAME_WIDTH / 2 - 100,\n      GAME_HEIGHT / 2 - 50,\n      200,\n      50,\n      \"Game Complete!\",\n      \"transparent\",\n      \"#4CAF50\",\n      24,\n    );\n  }\n\n  initializeCanvas() {\n    // Get dynamic viewport height (accounts for mobile browser UI elements)\n    const viewportWidth = window.innerWidth;\n    const viewportHeight = window.innerHeight;\n\n    // Calculate maximum possible game size that maintains aspect ratio\n    const gameAspectRatio = GAME_WIDTH / GAME_HEIGHT;\n    const viewportAspectRatio = viewportWidth / viewportHeight;\n\n    let scale;\n    if (viewportAspectRatio > gameAspectRatio) {\n      // Viewport is wider than game - fit to height\n      scale = viewportHeight / GAME_HEIGHT;\n    } else {\n      // Viewport is taller than game - fit to width\n      scale = viewportWidth / GAME_WIDTH;\n    }\n\n    // Ensure the scaled size doesn't exceed viewport\n    scale = Math.min(scale, 1);\n\n    this.canvas.width = GAME_WIDTH;\n    this.canvas.height = GAME_HEIGHT;\n\n    // Apply scale through CSS\n    this.canvas.style.width = `${GAME_WIDTH * scale}px`;\n    this.canvas.style.height = `${GAME_HEIGHT * scale}px`;\n  }\n\n  setupEventListeners() {\n    this.canvas.addEventListener(\"click\", (e) => {\n      const rect = this.canvas.getBoundingClientRect();\n      const scale = this.canvas.width / rect.width;\n      const x = (e.clientX - rect.left) * scale;\n      const y = (e.clientY - rect.top) * scale;\n\n      if (this.gameState === GAME_STATES.MENU) {\n        if (this.startButton.isClicked(x, y)) {\n          this.startGame();\n        }\n      } else if (this.gameState === GAME_STATES.GAME_OVER) {\n        if (this.retryButton.isClicked(x, y)) {\n          this.startGame();\n        }\n      } else if (this.gameState === GAME_STATES.LEVEL_COMPLETE) {\n        if (this.nextLevelButton.isClicked(x, y)) {\n          this.startNextLevel();\n        }\n      } else if (this.gameState === GAME_STATES.PLAYING) {\n        // Check for coin collection first\n        let coinCollected = false;\n        for (let i = this.coins.length - 1; i >= 0; i--) {\n          const coin = this.coins[i];\n          if (coin.isClicked(x, y)) {\n            // Add coin value to currency\n            this.currency += coin.value;\n            // Remove coin\n            this.coins.splice(i, 1);\n            coinCollected = true;\n            break; // Only collect one coin per click\n          }\n        }\n\n        // Only check defense interactions if we didn't collect a coin\n        if (!coinCollected) {\n          // Check if defense option was clicked\n          this.defenseOptions.forEach((option) => {\n            if (option.isClicked(x, y)) {\n              if (this.currency >= option.type.cost) {\n                this.selectedDefense = option.type;\n                console.log(`Selected ${option.type.name} defense`);\n              } else {\n                console.log(\"Not enough currency!\");\n              }\n            }\n          });\n\n          // Check if grid spot was clicked\n          if (this.selectedDefense) {\n            const spot = this.getSpotAtPosition(x, y);\n            if (spot && spot.isEmpty()) {\n              if (this.currency >= this.selectedDefense.cost) {\n                spot.placeDefense(this.selectedDefense);\n                this.currency -= this.selectedDefense.cost;\n                this.selectedDefense = null; // Reset selection after placing defense\n              }\n            }\n          }\n        }\n      }\n    });\n  }\n\n  startGame() {\n    this.gameState = GAME_STATES.PLAYING;\n    this.meteors = [];\n    this.coins = [];\n    this.currency = INITIAL_CURRENCY;\n    this.selectedDefense = null;\n    this.levelManager.startLevel(0);\n\n    // Reset defense grid\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        this.defenseGrid[row][lane].removeDefense();\n      }\n    }\n  }\n\n  startNextLevel() {\n    this.meteors = [];\n    this.coins = [];\n    this.currency = INITIAL_CURRENCY;\n    this.selectedDefense = null;\n\n    // Reset defense grid\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        this.defenseGrid[row][lane].removeDefense();\n      }\n    }\n\n    this.levelManager.startLevel(this.levelManager.currentLevel + 1);\n    this.gameState = GAME_STATES.PLAYING;\n  }\n\n  gameLoop(timestamp) {\n    // Calculate delta time\n    const deltaTime = timestamp - this.lastTime;\n    this.lastTime = timestamp;\n\n    // Clear canvas\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    // Update and draw game elements\n    this.update(deltaTime);\n    this.draw();\n\n    // Continue game loop\n    requestAnimationFrame((timestamp) => this.gameLoop(timestamp));\n  }\n\n  drawBackground() {\n    // Fill entire canvas with background color first\n    this.ctx.fillStyle = COLORS.BACKGROUND;\n    this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n\n    // Draw game area border\n    this.ctx.strokeStyle = COLORS.BORDER;\n    this.ctx.strokeRect(\n      PADDING_LEFT,\n      PADDING_TOP,\n      this.gameAreaWidth,\n      this.gameAreaHeight,\n    );\n\n    // Draw lanes\n    for (let i = 0; i <= LANES; i++) {\n      const x = PADDING_LEFT + i * this.laneWidth;\n      this.ctx.beginPath();\n      this.ctx.moveTo(x, PADDING_TOP);\n      this.ctx.lineTo(x, GAME_HEIGHT - PADDING_BOTTOM);\n      this.ctx.stroke();\n    }\n\n    // Draw padding areas (slightly darker shade for visual separation)\n    this.ctx.fillStyle = COLORS.BACKGROUND;\n    // Top padding\n    this.ctx.fillRect(0, 0, GAME_WIDTH, PADDING_TOP);\n    // Bottom padding\n    this.ctx.fillRect(\n      0,\n      GAME_HEIGHT - PADDING_BOTTOM,\n      GAME_WIDTH,\n      PADDING_BOTTOM,\n    );\n    // Left padding\n    this.ctx.fillRect(0, PADDING_TOP, PADDING_LEFT, this.gameAreaHeight);\n    // Right padding\n    this.ctx.fillRect(\n      GAME_WIDTH - PADDING_RIGHT,\n      PADDING_TOP,\n      PADDING_RIGHT,\n      this.gameAreaHeight,\n    );\n\n    // Draw defense grid\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        this.defenseGrid[row][lane].draw(this.ctx);\n      }\n    }\n  }\n\n  update(deltaTime) {\n    if (this.gameState !== GAME_STATES.PLAYING) return;\n\n    const currentTime = performance.now();\n\n    // Update all defense spots\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        this.defenseGrid[row][lane].update(\n          currentTime,\n          this.meteors,\n          this.coins,\n        );\n      }\n    }\n\n    // Update meteors and check for game over\n    this.meteors = this.meteors.filter((meteor) => {\n      meteor.update(deltaTime);\n      if (meteor.y >= GAME_HEIGHT - PADDING_BOTTOM) {\n        this.gameState = GAME_STATES.GAME_OVER;\n        return false;\n      }\n      return true;\n    });\n\n    // Update coins\n    this.coins = this.coins.filter((coin) => coin.update(currentTime));\n\n    // Update level manager\n    this.levelManager.update(currentTime, this.meteors);\n\n    // Check for level completion\n    if (this.levelManager.isLevelComplete(this.meteors)) {\n      if (this.levelManager.currentLevel >= LEVELS.length - 1) {\n        this.gameState = GAME_STATES.GAME_COMPLETE;\n      } else {\n        this.gameState = GAME_STATES.LEVEL_COMPLETE;\n      }\n    }\n  }\n\n  drawCurrency() {\n    this.ctx.fillStyle = COLORS.TEXT;\n    this.ctx.font = FONT.LARGE.full;\n    this.ctx.textAlign = \"left\";\n    this.ctx.fillText(\n      `Currency: $${this.currency}`,\n      PADDING_LEFT / 3,\n      (PADDING_TOP / 4) * 3,\n    );\n  }\n\n  draw() {\n    this.drawBackground();\n\n    if (this.gameState === GAME_STATES.LOADING) {\n      this.drawLoadingScreen();\n    } else if (this.gameState === GAME_STATES.MENU) {\n      this.startButton.draw(this.ctx);\n    } else if (this.gameState === GAME_STATES.PLAYING) {\n      // Draw currency\n      this.drawCurrency();\n\n      // Draw progress bar\n      this.drawProgressBar(this.ctx);\n\n      // Draw defense options\n      this.defenseOptions.forEach((option) => {\n        option.draw(\n          this.ctx,\n          this.selectedDefense && option.type.id === this.selectedDefense.id,\n          this.currency,\n        );\n      });\n\n      // Draw meteors\n      this.meteors.forEach((meteor) => meteor.draw(this.ctx));\n\n      // Draw coins\n      const currentTime = performance.now();\n      this.coins.forEach((coin) => coin.draw(this.ctx, currentTime));\n    } else if (this.gameState === GAME_STATES.LEVEL_COMPLETE) {\n      this.levelCompleteText.draw(this.ctx);\n      this.nextLevelButton.draw(this.ctx);\n    } else if (this.gameState === GAME_STATES.GAME_COMPLETE) {\n      this.gameCompleteText.draw(this.ctx);\n    } else if (this.gameState === GAME_STATES.GAME_OVER) {\n      this.gameOverText.draw(this.ctx);\n      this.retryButton.draw(this.ctx);\n    }\n  }\n\n  createDefenseOptions() {\n    const optionsAreaY = GAME_HEIGHT - PADDING_BOTTOM + 20; // Position below game grid\n    const spacing = 20; // Space between options\n    const totalWidth = (SPOT_SIZE + spacing) * DEFENSE_TYPES.length - spacing;\n    const startX = (GAME_WIDTH - totalWidth) / 2; // Center the options horizontally\n\n    return DEFENSE_TYPES.map((type, index) => {\n      const x = startX + index * (SPOT_SIZE + spacing);\n      const y = optionsAreaY;\n      return new DefenseOption(type, x, y);\n    });\n  }\n\n  createDefenseGrid() {\n    const grid = [];\n\n    // Create 2D array for easier position reference\n    for (let row = 0; row < GRID_ROWS; row++) {\n      const rowArray = [];\n      for (let lane = 0; lane < LANES; lane++) {\n        const x = PADDING_LEFT + lane * LANE_WIDTH + LANE_WIDTH / 2;\n        const y =\n          GAME_HEIGHT - PADDING_BOTTOM - row * SPOT_SIZE - SPOT_SIZE / 2;\n        rowArray.push(new DefenseSpot(x, y, row, lane));\n      }\n      grid.push(rowArray);\n    }\n\n    return grid;\n  }\n\n  // Helper method to get spot at specific coordinates\n  getSpotAtPosition(x, y) {\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        const spot = this.defenseGrid[row][lane];\n        if (\n          x >= spot.x - SPOT_SIZE / 2 &&\n          x <= spot.x + SPOT_SIZE / 2 &&\n          y >= spot.y - SPOT_SIZE / 2 &&\n          y <= spot.y + SPOT_SIZE / 2\n        ) {\n          return spot;\n        }\n      }\n    }\n    return null;\n  }\n\n  drawProgressBar(ctx) {\n    // Draw progress bar background\n    const barWidth = GAME_WIDTH - 100; // Leave some padding\n    const barHeight = 20;\n    const x = 50; // Padding from left\n    const y = 20; // Padding from top\n\n    // Background\n    ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n    ctx.fillRect(x, y, barWidth, barHeight);\n\n    // Progress (inverted to show remaining time)\n    const progress = 1 - this.levelManager.getLevelProgress();\n    ctx.fillStyle = COLORS.PROGRESS_BAR;\n    ctx.fillRect(x, y, barWidth * progress, barHeight);\n\n    // Border\n    ctx.strokeStyle = COLORS.BORDER;\n    ctx.strokeRect(x, y, barWidth, barHeight);\n\n    // Level text\n    ctx.fillStyle = COLORS.TEXT;\n    ctx.font = FONT.LARGE.full;\n    ctx.textAlign = \"center\";\n    ctx.fillText(\n      `${LEVELS[this.levelManager.currentLevel].name}`,\n      GAME_WIDTH / 2,\n      y + barHeight + 16,\n    );\n\n    // Time remaining\n    const timeLeft = Math.ceil(\n      (LEVELS[this.levelManager.currentLevel].duration -\n        (performance.now() - this.levelManager.levelStartTime)) /\n        1000,\n    );\n    if (timeLeft > 0) {\n      ctx.font = FONT.SMALL.full;\n      ctx.fillText(`${timeLeft}s`, GAME_WIDTH - 30, y + barHeight / 2 + 5);\n    }\n  }\n\n  async loadAssets() {\n    const success = await this.assetLoader.loadAll();\n    if (success) {\n      this.gameState = GAME_STATES.MENU;\n    } else {\n      console.error(\"Failed to load assets\");\n      // You might want to show an error message to the user\n    }\n  }\n\n  drawLoadingScreen() {\n    const progress = this.assetLoader.getLoadingProgress();\n\n    // Draw loading bar\n    const barWidth = 200;\n    const barHeight = 20;\n    const x = (GAME_WIDTH - barWidth) / 2;\n    const y = GAME_HEIGHT / 2;\n\n    // Background\n    this.ctx.fillStyle = COLORS.BUTTON;\n    this.ctx.fillRect(x, y, barWidth, barHeight);\n\n    // Progress\n    this.ctx.fillStyle = \"#4CAF50\";\n    this.ctx.fillRect(x, y, barWidth * progress, barHeight);\n\n    // Border\n    this.ctx.strokeStyle = COLORS.TEXT;\n    this.ctx.strokeRect(x, y, barWidth, barHeight);\n\n    // Loading text\n    this.ctx.fillStyle = COLORS.TEXT;\n    this.ctx.font = FONT.LARGE.full;\n    this.ctx.textAlign = \"center\";\n    this.ctx.fillText(\"Loading...\", GAME_WIDTH / 2, y - 20);\n    this.ctx.fillText(`${Math.floor(progress * 100)}%`, GAME_WIDTH / 2, y + 40);\n  }\n}\n\n// Start the game when the page loads\nwindow.addEventListener(\"load\", () => {\n  game = new Game();\n});\n"],"names":["$35da740d59af89ba$var$game","$35da740d59af89ba$var$GRID_ROWS","Math","floor","$35da740d59af89ba$var$GAME_AREA_HEIGHT","$35da740d59af89ba$var$COLORS","BACKGROUND","TEXT","DEFENSE_OPTION_TEXT","DEFENSE_OPTION_TEXT_INACTIVE","BUTTON","BUTTON_TEXT","PROGRESS_BAR","BORDER","DEBUG_LINE","SELECTION","$35da740d59af89ba$var$LEVELS","$35da740d59af89ba$var$generateLevels","levels","i","levelIndex","baseSpawnMultiplier","baseCountMultiplier","baseDangerMultiplier","waves","currentTime","meteorType","levelProgress","intraLevelMultiplier","spawnMultiplier","countMultiplier","totalDangerFactor","progressDanger","random","count","ceil","baseCount","spacing","push","type","startTime","waveLength","max","name","duration","$35da740d59af89ba$var$GAME_STATES","LOADING","MENU","PLAYING","LEVEL_COMPLETE","GAME_OVER","GAME_COMPLETE","$35da740d59af89ba$var$DEFENSE_TYPES","id","color","cost","damage","health","$35da740d59af89ba$var$METEOR_TYPES","speed","damageRate","rotateRate","wiggleRate","wiggleAmount","sizeMultiplier","x","y","coinReward","$35da740d59af89ba$var$FONT","SMALL","size","family","full","LARGE","$35da740d59af89ba$var$AssetLoader","constructor","images","Map","totalAssets","loadedAssets","loadAll","meteorPromises","$35da740d59af89ba$var$ASSETS","map","path","index","loadImage","Promise","all","error","console","key","src","resolve","reject","img","Image","onload","set","onerror","Error","getImage","get","getLoadingProgress","$35da740d59af89ba$var$Meteor","lane","isBlocked","blockingDefense","baseRotation","wiggleRotation","wiggleOffset","baseX","$35da740d59af89ba$var$PADDING_LEFT","$35da740d59af89ba$var$GAME_AREA_WIDTH","$35da740d59af89ba$var$LANE_WIDTH","update","deltaTime","cos","block","defense","unblock","draw","ctx","wiggleX","sin","meteorImage","assetLoader","save","translate","rotate","height","$35da740d59af89ba$var$METEOR_SIZE","width","drawImage","restore","fillStyle","beginPath","arc","PI","fill","takeDamage","$35da740d59af89ba$var$Button","text","backgroundColor","textColor","fontSize","isClicked","clickX","clickY","fillRect","font","textAlign","textBaseline","fillText","$35da740d59af89ba$var$Projectile","checkCollision","meteor","meteorX","dx","dy","distance","sqrt","isOffScreen","$35da740d59af89ba$var$Defense","maxHealth","projectiles","lastFireTime","fireRate","blockingMeteors","isEmpty","amount","meteors","coins","defenseRow","forEach","m","filter","projectile","length","$35da740d59af89ba$var$Coin","splice","isSelected","isInactive","strokeStyle","lineWidth","strokeRect","globalAlpha","$35da740d59af89ba$var$DefenseOption","currentCurrency","$35da740d59af89ba$var$SPOT_SIZE","$35da740d59af89ba$var$DefenseSpot","row","placeDefense","defenseType","removeDefense","value","lifetime","createTime","performance","now","hitRadius","angle","vx","vy","waveAmplitude","waveFrequency","waveOffset","baseY","time","age","remainingTime","coinX","coinY","gradient","createRadialGradient","addColorStop","stroke","$35da740d59af89ba$var$LevelManager","currentLevel","levelStartTime","waveStates","allWavesComplete","startLevel","wave","meteorsSpawned","nextSpawnTime","level","levelTime","waveIndex","state","isLevelComplete","getLevelProgress","min","$35da740d59af89ba$var$Game","canvas","document","getElementById","getContext","lastTime","gameState","initializeCanvas","window","addEventListener","loadAssets","requestAnimationFrame","timestamp","gameLoop","testMeteor","setupEventListeners","startButton","$35da740d59af89ba$var$GAME_WIDTH","$35da740d59af89ba$var$GAME_HEIGHT","retryButton","gameOverText","currency","defenseOptions","createDefenseOptions","selectedDefense","defenseGrid","createDefenseGrid","levelManager","nextLevelButton","levelCompleteText","gameCompleteText","scale","viewportWidth","innerWidth","viewportHeight","innerHeight","viewportAspectRatio","style","e","rect","getBoundingClientRect","clientX","left","clientY","top","startGame","startNextLevel","coinCollected","coin","option","log","spot","getSpotAtPosition","clearRect","drawBackground","gameAreaWidth","gameAreaHeight","laneWidth","moveTo","lineTo","drawCurrency","$35da740d59af89ba$var$PADDING_TOP","drawLoadingScreen","drawProgressBar","startX","grid","rowArray","progress","barWidth","timeLeft"],"version":3,"file":"index.4ce387a3.js.map"}