{"mappings":"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","sources":["<anon>","src/index.js"],"sourcesContent":["var $35da740d59af89ba$exports = {};\n// Game constants\nconst $35da740d59af89ba$var$GAME_WIDTH = 360; // Base width, will be scaled\nconst $35da740d59af89ba$var$GAME_HEIGHT = 640; // 16:9 ratio\nconst $35da740d59af89ba$var$LANES = 6;\nconst $35da740d59af89ba$var$PADDING_TOP = 40; // More space for score/level\nconst $35da740d59af89ba$var$PADDING_BOTTOM = 100; // More space for controls/UI\nconst $35da740d59af89ba$var$PADDING_LEFT = 40;\nconst $35da740d59af89ba$var$PADDING_RIGHT = 40;\nconst $35da740d59af89ba$var$INITIAL_CURRENCY = 500;\nconst $35da740d59af89ba$var$INITIAL_LIVES = 3;\n// Game area calculations\nconst $35da740d59af89ba$var$GAME_AREA_WIDTH = $35da740d59af89ba$var$GAME_WIDTH - ($35da740d59af89ba$var$PADDING_LEFT + $35da740d59af89ba$var$PADDING_RIGHT);\nconst $35da740d59af89ba$var$GAME_AREA_HEIGHT = $35da740d59af89ba$var$GAME_HEIGHT - ($35da740d59af89ba$var$PADDING_TOP + $35da740d59af89ba$var$PADDING_BOTTOM);\nconst $35da740d59af89ba$var$LANE_WIDTH = $35da740d59af89ba$var$GAME_AREA_WIDTH / $35da740d59af89ba$var$LANES; // Width of each lane\nconst $35da740d59af89ba$var$SPOT_SIZE = $35da740d59af89ba$var$LANE_WIDTH; // Defense spots are same width as lanes\nconst $35da740d59af89ba$var$METEOR_SIZE = $35da740d59af89ba$var$LANE_WIDTH * 0.8; // Base size for meteors\nconst $35da740d59af89ba$var$GRID_ROWS = Math.floor($35da740d59af89ba$var$GAME_AREA_HEIGHT / $35da740d59af89ba$var$SPOT_SIZE);\n// Add to game constants\nconst $35da740d59af89ba$var$DEBUG = false; // Toggle for development visualization\nconst $35da740d59af89ba$var$COLORS = {\n    BACKGROUND: \"#edf1e7\",\n    TEXT: \"#000\",\n    DEFENSE_OPTION_TEXT: \"#000\",\n    DEFENSE_OPTION_TEXT_INACTIVE: \"#f00\",\n    BUTTON: \"#444\",\n    BUTTON_TEXT: \"#fff\",\n    PROGRESS_BAR: \"#4CAF50\",\n    BORDER: \"#333\",\n    DEBUG_LINE: \"rgba(0,0,0,0.1)\",\n    DEBUG_TEXT: \"#666\",\n    SELECTION: \"rgba(255,80,80,0.7)\"\n};\n// Level generation configuration options\nconst $35da740d59af89ba$var$LEVEL_GEN_CONFIG = {\n    levelVersion: 1.3,\n    baseDuration: 30000,\n    durationIncrease: 5000,\n    maxLevels: 30,\n    difficultyMultiplier: 0.85,\n    // Meteor type weights (chance of spawning) at start and end of level\n    meteorWeights: {\n        start: {\n            small: 1,\n            medium: 0,\n            large: 0\n        },\n        end: {\n            small: 0.4,\n            medium: 0.3,\n            large: 0.3\n        }\n    },\n    // Spawn timing\n    minSpawnGap: 900,\n    minSpawnGapEnd: 300,\n    maxSpawnGap: 1500,\n    maxSpawnGapEnd: 700,\n    // Difficulty scaling\n    difficultyRamp: 1.25,\n    waveDuration: 6000,\n    waveDurationEnd: 2000,\n    waveGap: 3200,\n    waveGapEnd: 1200\n};\nfunction $35da740d59af89ba$var$generateLevels(config = $35da740d59af89ba$var$LEVEL_GEN_CONFIG) {\n    const levels = [];\n    const diff = config.difficultyMultiplier;\n    for(let levelNum = 0; levelNum < config.maxLevels; levelNum++){\n        const duration = (config.baseDuration + config.durationIncrease * levelNum) / Math.sqrt(diff);\n        const meteors = [];\n        let currentTime = 1000;\n        const levelDifficulty = Math.pow(config.difficultyRamp, levelNum) * diff;\n        while(currentTime < duration - 2000){\n            const levelProgress = currentTime / duration;\n            const adjustedWaveDuration = $35da740d59af89ba$var$lerp(config.waveDuration / Math.sqrt(diff), config.waveDurationEnd / Math.sqrt(diff), levelProgress);\n            const waveEndTime = currentTime + adjustedWaveDuration;\n            while(currentTime < waveEndTime){\n                const waveProgress = (currentTime - (waveEndTime - adjustedWaveDuration)) / adjustedWaveDuration;\n                // Adjust weights based on difficulty (harder = more medium/large meteors)\n                const weights = {\n                    small: $35da740d59af89ba$var$lerp(config.meteorWeights.start.small, config.meteorWeights.end.small / diff, waveProgress),\n                    medium: $35da740d59af89ba$var$lerp(config.meteorWeights.start.medium, config.meteorWeights.end.medium * diff, waveProgress),\n                    large: $35da740d59af89ba$var$lerp(config.meteorWeights.start.large, config.meteorWeights.end.large * diff, waveProgress)\n                };\n                // Select meteor type based on weights\n                const meteorType = $35da740d59af89ba$var$selectMeteorType(weights);\n                // Select random lane\n                const lane = Math.floor(Math.random() * $35da740d59af89ba$var$LANES);\n                meteors.push({\n                    type: meteorType,\n                    lane: lane,\n                    startTime: Math.floor(currentTime)\n                });\n                // Adjust spawn gaps based on difficulty (harder = faster spawns)\n                const minGap = $35da740d59af89ba$var$lerp(config.minSpawnGap / diff, config.minSpawnGapEnd / diff, waveProgress);\n                const maxGap = $35da740d59af89ba$var$lerp(config.maxSpawnGap / diff, config.maxSpawnGapEnd / diff, waveProgress);\n                currentTime += Math.random() * (maxGap - minGap) + minGap;\n            }\n            const adjustedWaveGap = $35da740d59af89ba$var$lerp(config.waveGap / diff, config.waveGapEnd / diff, levelProgress);\n            currentTime += adjustedWaveGap;\n        }\n        levels.push({\n            name: `Level ${levelNum + 1}`,\n            duration: duration,\n            meteors: meteors.sort((a, b)=>a.startTime - b.startTime)\n        });\n    }\n    return levels;\n}\n// Helper function to linearly interpolate between two values\nfunction $35da740d59af89ba$var$lerp(start, end, progress) {\n    return start + (end - start) * progress;\n}\n// Helper function to select meteor type based on weights\nfunction $35da740d59af89ba$var$selectMeteorType(weights) {\n    const total = weights.small + weights.medium + weights.large;\n    const random = Math.random() * total;\n    if (random < weights.small) return 0; // Small meteor\n    if (random < weights.small + weights.medium) return 1; // Medium meteor\n    return 2; // Large meteor\n}\n// Replace the existing LEVELS constant with generated levels\nconst $35da740d59af89ba$var$LEVELS = $35da740d59af89ba$var$generateLevels();\nconst $35da740d59af89ba$var$GAME_STATES = {\n    LOADING: \"loading\",\n    MENU: \"menu\",\n    PLAYING: \"playing\",\n    LIFE_LOST: \"lifeLost\",\n    LEVEL_COMPLETE: \"levelComplete\",\n    GAME_OVER: \"gameover\",\n    GAME_COMPLETE: \"gameComplete\"\n};\n// Add to game constants\nconst $35da740d59af89ba$var$DEFENSE_TYPES = [\n    {\n        id: 0,\n        name: \"Basic\",\n        color: \"#4CAF50\",\n        cost: 100,\n        damage: 10,\n        health: 100\n    },\n    {\n        id: 1,\n        name: \"Medium\",\n        color: \"#2196F3\",\n        cost: 150,\n        damage: 20,\n        health: 100\n    },\n    {\n        id: 2,\n        name: \"Strong\",\n        color: \"#9C27B0\",\n        cost: 200,\n        damage: 30,\n        health: 100\n    }\n];\n// Add to game constants\nconst $35da740d59af89ba$var$METEOR_TYPES = [\n    {\n        id: 0,\n        name: \"Small\",\n        color: \"#FF9999\",\n        health: 30,\n        speed: 0.05,\n        damageRate: 30,\n        rotateRate: 0.0005,\n        wiggleRate: 0.001,\n        wiggleAmount: 7,\n        sizeMultiplier: {\n            x: 1.0,\n            y: 1.0\n        },\n        coinReward: 20\n    },\n    {\n        id: 1,\n        name: \"Medium\",\n        color: \"#FF4444\",\n        health: 50,\n        speed: 0.035,\n        damageRate: 50,\n        rotateRate: 0,\n        wiggleRate: 0.03,\n        wiggleAmount: 0.03,\n        sizeMultiplier: {\n            x: 1,\n            y: 2\n        },\n        coinReward: 40\n    },\n    {\n        id: 2,\n        name: \"Large\",\n        color: \"#FF0000\",\n        health: 70,\n        speed: 0.05,\n        damageRate: 50,\n        rotateRate: 0,\n        wiggleRate: 0.03,\n        wiggleAmount: 0.03,\n        sizeMultiplier: {\n            x: 1,\n            y: 2\n        },\n        coinReward: 50\n    }\n];\n// Font definitions\nconst $35da740d59af89ba$var$FONT = {\n    SMALL: {\n        size: \"12px\",\n        family: \"Arial\",\n        get full () {\n            return `${this.size} ${this.family}`;\n        }\n    },\n    LARGE: {\n        size: \"14px\",\n        family: \"Arial\",\n        get full () {\n            return `${this.size} ${this.family}`;\n        }\n    }\n};\n// Add at the top of the file, after other constants\nconst $35da740d59af89ba$var$ASSETS = {\n    METEORS: [\n        \"/assets/img/meteor-1.png\",\n        \"/assets/img/meteor-2.png\",\n        \"/assets/img/meteor-3.png\"\n    ]\n};\n// Add new AssetLoader class\nclass $35da740d59af89ba$var$AssetLoader {\n    constructor(){\n        this.images = new Map();\n        this.totalAssets = 0;\n        this.loadedAssets = 0;\n    }\n    async loadAll() {\n        const meteorPromises = $35da740d59af89ba$var$ASSETS.METEORS.map((path, index)=>this.loadImage(`meteor-${index}`, path));\n        try {\n            await Promise.all(meteorPromises);\n            return true;\n        } catch (error) {\n            console.error(\"Error loading assets:\", error);\n            return false;\n        }\n    }\n    loadImage(key, src) {\n        return new Promise((resolve, reject)=>{\n            const img = new Image();\n            this.totalAssets++;\n            img.onload = ()=>{\n                this.images.set(key, img);\n                this.loadedAssets++;\n                resolve(img);\n            };\n            img.onerror = ()=>{\n                reject(new Error(`Failed to load image: ${src}`));\n            };\n            img.src = src;\n        });\n    }\n    getImage(key) {\n        return this.images.get(key);\n    }\n    getLoadingProgress() {\n        return this.totalAssets ? this.loadedAssets / this.totalAssets : 0;\n    }\n}\n// Add at the top of the file, after constants\nlet $35da740d59af89ba$var$game; // Global game instance\n// Test meteor\nclass $35da740d59af89ba$var$Meteor {\n    constructor(lane, type = $35da740d59af89ba$var$METEOR_TYPES[0]){\n        this.lane = lane;\n        this.type = type;\n        this.y = $35da740d59af89ba$var$PADDING_TOP;\n        this.health = type.health;\n        this.speed = type.speed;\n        this.isBlocked = false;\n        this.blockingDefense = null;\n        // Add rotation and wiggle properties\n        this.baseRotation = 0; // Base rotation from type.rotateRate\n        this.wiggleRotation = 0; // Additional rotation from wiggle motion\n        this.wiggleOffset = 0;\n        this.baseX = $35da740d59af89ba$var$PADDING_LEFT + lane * $35da740d59af89ba$var$LANE_WIDTH + $35da740d59af89ba$var$LANE_WIDTH / 2;\n    }\n    update(deltaTime) {\n        if (!this.isBlocked) {\n            this.y += this.speed * deltaTime;\n            // Update base rotation\n            this.baseRotation += this.type.rotateRate * deltaTime;\n            // Update wiggle and calculate wiggle-based rotation\n            this.wiggleOffset += this.type.wiggleRate * deltaTime;\n            // Calculate rotation based on wiggle movement (adjust 0.5 to control rotation intensity)\n            this.wiggleRotation = Math.cos(this.wiggleOffset) * this.type.wiggleAmount * 0.5;\n        }\n    }\n    block(defense) {\n        this.isBlocked = true;\n        this.blockingDefense = defense;\n    }\n    unblock() {\n        this.isBlocked = false;\n        this.blockingDefense = null;\n    }\n    draw(ctx) {\n        // Calculate wiggled x position\n        const wiggleX = this.baseX + Math.sin(this.wiggleOffset) * this.type.wiggleAmount;\n        // Get the corresponding meteor image\n        const meteorImage = $35da740d59af89ba$var$game?.assetLoader.getImage(`meteor-${this.type.id}`);\n        if (meteorImage) {\n            ctx.save(); // Save current context state\n            // Translate to meteor position\n            ctx.translate(wiggleX, this.y);\n            // Apply combined rotation (base rotation + wiggle-based rotation)\n            ctx.rotate(this.baseRotation + this.wiggleRotation);\n            // Calculate size using multiplier\n            const height = $35da740d59af89ba$var$METEOR_SIZE * this.type.sizeMultiplier.y;\n            const width = $35da740d59af89ba$var$METEOR_SIZE * this.type.sizeMultiplier.x;\n            // Draw the image centered at the translated position\n            ctx.drawImage(meteorImage, -width / 2, -height / 2, width, height);\n            ctx.restore(); // Restore context state\n        } else {\n            // Fallback to original circle drawing if image isn't loaded\n            ctx.fillStyle = this.type.color;\n            ctx.beginPath();\n            ctx.arc(wiggleX, this.y, 10, 0, Math.PI * 2);\n            ctx.fill();\n        }\n        if ($35da740d59af89ba$var$DEBUG) {\n            // Draw collision circle\n            ctx.strokeStyle = \"rgba(255,0,0,0.3)\";\n            ctx.beginPath();\n            ctx.arc(wiggleX, this.y, 10, 0, Math.PI * 2);\n            ctx.stroke();\n            // Draw health\n            ctx.fillStyle = \"white\";\n            ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n            ctx.textAlign = \"center\";\n            ctx.fillText(`${this.health}`, wiggleX, this.y);\n        }\n    }\n    takeDamage(damage) {\n        this.health -= damage;\n        return this.health <= 0;\n    }\n}\n// Add to existing constants\nclass $35da740d59af89ba$var$Button {\n    constructor(x, y, width, height, text, backgroundColor = $35da740d59af89ba$var$COLORS.BUTTON, textColor = $35da740d59af89ba$var$COLORS.BUTTON_TEXT, fontSize = 16){\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.text = text;\n        this.backgroundColor = backgroundColor;\n        this.textColor = textColor;\n        this.fontSize = fontSize;\n    }\n    isClicked(clickX, clickY) {\n        return clickX >= this.x && clickX <= this.x + this.width && clickY >= this.y && clickY <= this.y + this.height;\n    }\n    draw(ctx) {\n        // Draw button background\n        ctx.fillStyle = this.backgroundColor;\n        ctx.fillRect(this.x, this.y, this.width, this.height);\n        // Draw button text\n        ctx.fillStyle = this.textColor;\n        ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height / 2);\n    }\n}\nclass $35da740d59af89ba$var$Projectile {\n    constructor(x, y, damage){\n        this.x = x;\n        this.y = y;\n        this.speed = 0.3;\n        this.damage = damage;\n        this.size = 4;\n    }\n    update(deltaTime) {\n        this.y -= this.speed * deltaTime;\n    }\n    draw(ctx) {\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n        ctx.fill();\n        if ($35da740d59af89ba$var$DEBUG) {\n            // Draw collision circle\n            ctx.strokeStyle = \"rgba(255,255,0,0.3)\";\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n            ctx.stroke();\n        }\n    }\n    checkCollision(meteor) {\n        const meteorX = $35da740d59af89ba$var$PADDING_LEFT + meteor.lane * $35da740d59af89ba$var$LANE_WIDTH + $35da740d59af89ba$var$LANE_WIDTH / 2;\n        const dx = this.x - meteorX;\n        const dy = this.y - meteor.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        return distance < this.size + 10; // 10 is meteor radius\n    }\n    isOffScreen() {\n        return this.y < $35da740d59af89ba$var$PADDING_TOP;\n    }\n}\n// Add to game constants\nclass $35da740d59af89ba$var$Defense {\n    constructor(type = null){\n        this.type = type;\n        this.health = type ? type.health : 0;\n        this.maxHealth = type ? type.health : 0;\n        this.projectiles = [];\n        this.lastFireTime = 0;\n        this.fireRate = 1000;\n        this.blockingMeteors = []; // Add array to track blocked meteors\n    }\n    isEmpty() {\n        return this.type === null;\n    }\n    takeDamage(amount) {\n        this.health -= amount;\n        return this.health <= 0;\n    }\n    update(currentTime, x, y, meteors, coins) {\n        if (!this.isEmpty()) {\n            // Fire projectile if enough time has passed\n            if (currentTime - this.lastFireTime > this.fireRate) {\n                this.projectiles.push(new $35da740d59af89ba$var$Projectile(x, y, this.type.damage));\n                this.lastFireTime = currentTime;\n            }\n            // Check for meteor collisions with this defense\n            const defenseRow = Math.floor((y - $35da740d59af89ba$var$PADDING_TOP) / $35da740d59af89ba$var$SPOT_SIZE);\n            meteors.forEach((meteor)=>{\n                const meteorRow = Math.floor((meteor.y - $35da740d59af89ba$var$PADDING_TOP) / $35da740d59af89ba$var$SPOT_SIZE);\n                if (meteorRow === defenseRow && meteor.lane === Math.floor((x - $35da740d59af89ba$var$PADDING_LEFT) / $35da740d59af89ba$var$LANE_WIDTH)) {\n                    // Block meteor if not already blocked\n                    if (!meteor.isBlocked) {\n                        meteor.block(this);\n                        this.blockingMeteors.push(meteor); // Track this meteor\n                    }\n                    // Take damage from meteor using meteor's damage rate\n                    if (meteor.blockingDefense === this) {\n                        const destroyed = this.takeDamage(meteor.type.damageRate / 60);\n                        if (destroyed) {\n                            // Unblock all meteors this defense was blocking\n                            this.blockingMeteors.forEach((m)=>m.unblock());\n                            this.blockingMeteors = [];\n                            this.type = null; // Reset defense when destroyed\n                            this.health = 0;\n                            this.maxHealth = 0;\n                        }\n                    }\n                }\n            });\n            // Update existing projectiles and check collisions\n            this.projectiles = this.projectiles.filter((projectile)=>{\n                projectile.update(16);\n                // Check for collisions with any meteor\n                for(let i = 0; i < meteors.length; i++){\n                    const meteor = meteors[i];\n                    if (projectile.checkCollision(meteor)) {\n                        const destroyed = meteor.takeDamage(projectile.damage);\n                        if (destroyed) {\n                            // Spawn coin at meteor's position with meteor's reward value\n                            const meteorX = $35da740d59af89ba$var$PADDING_LEFT + meteor.lane * $35da740d59af89ba$var$LANE_WIDTH + $35da740d59af89ba$var$LANE_WIDTH / 2;\n                            coins.push(new $35da740d59af89ba$var$Coin(meteorX, meteor.y, meteor.type.coinReward));\n                            meteors.splice(i, 1);\n                        }\n                        return false; // Remove projectile\n                    }\n                }\n                return !projectile.isOffScreen();\n            });\n        }\n    }\n    draw(ctx, x, y, size, isSelected = false, isInactive = false) {\n        // Draw spot outline\n        ctx.strokeStyle = this.isEmpty() ? $35da740d59af89ba$var$COLORS.DEBUG_LINE : \"#888\";\n        ctx.lineWidth = 1;\n        ctx.strokeRect(x - size / 2, y - size / 2, size, size);\n        if (!this.isEmpty()) {\n            // Draw defense with health-based opacity\n            ctx.fillStyle = this.type.color;\n            if (isInactive) ctx.globalAlpha = 0.5;\n            else ctx.globalAlpha = Math.max(0.3, this.health / this.maxHealth);\n            ctx.fillRect(x - size / 2, y - size / 2, size, size);\n            ctx.globalAlpha = 1.0;\n            // Draw projectiles\n            this.projectiles.forEach((projectile)=>projectile.draw(ctx));\n            if ($35da740d59af89ba$var$DEBUG) {\n                // Draw health bar\n                ctx.fillStyle = $35da740d59af89ba$var$COLORS.TEXT;\n                ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n                ctx.textAlign = \"center\";\n                ctx.fillText(`${Math.floor(this.health / this.maxHealth * 100)}%`, x, y);\n            }\n            // Draw selection highlight\n            if (isSelected) {\n                ctx.strokeStyle = $35da740d59af89ba$var$COLORS.SELECTION;\n                ctx.lineWidth = 4;\n                ctx.strokeRect(x - size / 2, y - size / 2, size, size);\n            }\n        }\n    }\n}\nclass $35da740d59af89ba$var$DefenseOption {\n    constructor(type, x, y){\n        this.type = type;\n        this.x = x;\n        this.y = y;\n        this.defense = new $35da740d59af89ba$var$Defense(type);\n    }\n    draw(ctx, isSelected = false, currentCurrency = 0) {\n        const isInactive = currentCurrency < this.type.cost;\n        // Draw defense using Defense class\n        this.defense.draw(ctx, this.x + $35da740d59af89ba$var$SPOT_SIZE / 2, this.y + $35da740d59af89ba$var$SPOT_SIZE / 2, $35da740d59af89ba$var$SPOT_SIZE, isSelected, isInactive);\n        // Draw cost (red if can't afford)\n        ctx.fillStyle = isInactive ? $35da740d59af89ba$var$COLORS.DEFENSE_OPTION_TEXT_INACTIVE : $35da740d59af89ba$var$COLORS.DEFENSE_OPTION_TEXT;\n        ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n        ctx.textAlign = \"center\";\n        ctx.fillText(`$${this.type.cost}`, this.x + $35da740d59af89ba$var$SPOT_SIZE / 2, this.y + $35da740d59af89ba$var$SPOT_SIZE + 15);\n    }\n    isClicked(clickX, clickY) {\n        return clickX >= this.x && clickX <= this.x + $35da740d59af89ba$var$SPOT_SIZE && clickY >= this.y && clickY <= this.y + $35da740d59af89ba$var$SPOT_SIZE;\n    }\n}\nclass $35da740d59af89ba$var$DefenseSpot {\n    constructor(x, y, row, lane){\n        this.x = x;\n        this.y = y;\n        this.row = row;\n        this.lane = lane;\n        this.defense = new $35da740d59af89ba$var$Defense();\n    }\n    isEmpty() {\n        return this.defense.isEmpty();\n    }\n    placeDefense(defenseType) {\n        if (this.isEmpty()) {\n            this.defense = new $35da740d59af89ba$var$Defense(defenseType);\n            return true;\n        }\n        return false;\n    }\n    removeDefense() {\n        this.defense = new $35da740d59af89ba$var$Defense(); // Reset to empty defense\n    }\n    draw(ctx) {\n        // Draw defense (or empty spot)\n        this.defense.draw(ctx, this.x, this.y, $35da740d59af89ba$var$SPOT_SIZE);\n        if ($35da740d59af89ba$var$DEBUG) {\n            // Draw coordinates for debugging\n            ctx.fillStyle = $35da740d59af89ba$var$COLORS.DEBUG_TEXT;\n            ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n            ctx.textAlign = \"center\";\n            ctx.fillText(`${this.lane},${this.row}`, this.x, this.y);\n        }\n    }\n    update(currentTime, meteors, coins) {\n        this.defense.update(currentTime, this.x, this.y, meteors, coins);\n    }\n}\nclass $35da740d59af89ba$var$Coin {\n    constructor(x, y, value = 10){\n        this.x = x;\n        this.y = y;\n        this.value = value;\n        this.lifetime = 5000; // 5 seconds lifetime\n        this.createTime = performance.now();\n        this.hitRadius = 30; // Bigger radius for hit detection\n        // Size based on value\n        this.size = 8 + (value - 10) / 10 * 2; // Increases by 2 pixels for each 10 value\n        // Base movement\n        const angle = Math.random() * Math.PI * 2;\n        const speed = 0.3 + Math.random() * 0.1;\n        this.vx = Math.cos(angle) * speed;\n        this.vy = Math.sin(angle) * speed;\n        // Wave motion parameters\n        this.waveAmplitude = 2.2 + Math.random() * 0.2;\n        this.waveFrequency = 0.005 + Math.random() * 0.001;\n        this.waveOffset = Math.random() * Math.PI * 2;\n        this.baseX = x;\n        this.baseY = y;\n        this.time = 0;\n    }\n    draw(ctx, currentTime) {\n        const age = currentTime - this.createTime;\n        const remainingTime = this.lifetime - age;\n        // Start blinking when less than 1.5 seconds remaining\n        if (remainingTime < 1500) {\n            const blinkRate = 100 + remainingTime / 1500 * 400;\n            if (Math.floor(currentTime / blinkRate) % 2 === 0) return;\n        }\n        if ($35da740d59af89ba$var$DEBUG) {\n            // Draw hit area\n            ctx.strokeStyle = \"rgba(255, 80, 80, 0.6)\";\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.hitRadius, 0, Math.PI * 2);\n            ctx.stroke();\n        }\n        const coinX = this.x + Math.sin(this.time * this.waveFrequency + this.waveOffset) * this.waveAmplitude;\n        const coinY = this.y + Math.cos(this.time * this.waveFrequency + this.waveOffset) * this.waveAmplitude;\n        // Draw coin with gradient for more depth\n        const gradient = ctx.createRadialGradient(coinX - this.size / 3, coinY - this.size / 3, 0, coinX, coinY, this.size);\n        gradient.addColorStop(0, \"#FFD700\"); // Bright gold\n        gradient.addColorStop(1, \"#DAA520\"); // Darker gold\n        ctx.fillStyle = gradient;\n        ctx.beginPath();\n        ctx.arc(coinX, coinY, this.size, 0, Math.PI * 2);\n        ctx.fill();\n        // Add coin border\n        ctx.strokeStyle = \"#B8860B\"; // Dark gold\n        ctx.lineWidth = 1;\n        ctx.stroke();\n        // Draw value\n        ctx.fillStyle = \"black\";\n        ctx.font = `bold ${Math.max(10, this.size)}px ${$35da740d59af89ba$var$FONT.SMALL.family}`;\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(`${this.value}`, coinX, coinY);\n    }\n    update(currentTime) {\n        this.time += 16; // Increment time (assuming ~60fps)\n        // Update base position with velocity\n        this.baseX += this.vx;\n        this.baseY += this.vy;\n        // Add wave motion\n        this.x = this.baseX + Math.sin(this.time * this.waveFrequency + this.waveOffset) * this.waveAmplitude;\n        this.y = this.baseY + Math.cos(this.time * this.waveFrequency + this.waveOffset) * this.waveAmplitude;\n        // Calculate remaining lifetime\n        const age = currentTime - this.createTime;\n        return age < this.lifetime;\n    }\n    isClicked(clickX, clickY) {\n        const dx = clickX - this.x;\n        const dy = clickY - this.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        return distance < this.hitRadius;\n    }\n}\nclass $35da740d59af89ba$var$LevelManager {\n    constructor(){\n        this.currentLevel = 0;\n        this.levelStartTime = 0;\n        this.remainingMeteors = [];\n        this.allMeteorsSpawned = false;\n    }\n    startLevel(levelIndex) {\n        this.currentLevel = levelIndex;\n        this.levelStartTime = performance.now();\n        this.remainingMeteors = [\n            ...$35da740d59af89ba$var$LEVELS[levelIndex].meteors\n        ];\n        this.allMeteorsSpawned = false;\n    }\n    update(currentTime, meteors) {\n        if (this.currentLevel >= $35da740d59af89ba$var$LEVELS.length) return false;\n        const levelTime = currentTime - this.levelStartTime;\n        const level = $35da740d59af89ba$var$LEVELS[this.currentLevel];\n        // Check if level time is exceeded\n        if (levelTime >= level.duration) {\n            this.allMeteorsSpawned = true;\n            return false;\n        }\n        // Spawn meteors that are due\n        while(this.remainingMeteors.length > 0 && levelTime >= this.remainingMeteors[0].startTime){\n            const meteorData = this.remainingMeteors.shift();\n            meteors.push(new $35da740d59af89ba$var$Meteor(meteorData.lane, $35da740d59af89ba$var$METEOR_TYPES[meteorData.type]));\n        }\n        // Check if all meteors have been spawned\n        if (this.remainingMeteors.length === 0) this.allMeteorsSpawned = true;\n        return true;\n    }\n    isLevelComplete(meteors) {\n        return this.allMeteorsSpawned && meteors.length === 0;\n    }\n    getLevelProgress() {\n        const levelTime = performance.now() - this.levelStartTime;\n        const duration = $35da740d59af89ba$var$LEVELS[this.currentLevel].duration;\n        return Math.min(levelTime / duration, 1);\n    }\n}\nconst $35da740d59af89ba$var$STORAGE_KEY = \"meteorDefenseHighScore\";\nclass $35da740d59af89ba$var$Game {\n    constructor(){\n        this.canvas = document.getElementById(\"canvas\");\n        this.ctx = this.canvas.getContext(\"2d\");\n        this.lastTime = 0;\n        this.meteors = [];\n        this.coins = [];\n        this.assetLoader = new $35da740d59af89ba$var$AssetLoader();\n        this.gameState = $35da740d59af89ba$var$GAME_STATES.LOADING;\n        // Initialize game dimensions and scaling\n        this.initializeCanvas();\n        window.addEventListener(\"resize\", ()=>this.initializeCanvas());\n        // Load assets before starting the game\n        this.loadAssets();\n        // Start game loop\n        requestAnimationFrame((timestamp)=>this.gameLoop(timestamp));\n        // Add test meteor in middle lane\n        this.testMeteor = new $35da740d59af89ba$var$Meteor(2); // Lane 3 (0-based index)\n        // Add game state and button handling\n        this.gameState = $35da740d59af89ba$var$GAME_STATES.MENU;\n        this.setupEventListeners();\n        // Create buttons\n        const buttonWidth = 100;\n        const buttonHeight = 50;\n        const buttonX = $35da740d59af89ba$var$GAME_WIDTH / 2 - buttonWidth / 2;\n        const buttonY = $35da740d59af89ba$var$GAME_HEIGHT / 2 - buttonHeight / 2;\n        this.startButton = new $35da740d59af89ba$var$Button(buttonX, buttonY, buttonWidth, buttonHeight, \"Start Game\");\n        this.retryButton = new $35da740d59af89ba$var$Button(buttonX, buttonY, buttonWidth, buttonHeight, \"Try Again\");\n        this.gameOverText = new $35da740d59af89ba$var$Button($35da740d59af89ba$var$GAME_WIDTH / 2 - 100, $35da740d59af89ba$var$GAME_HEIGHT / 2 - 100, 200, 50, \"Game Over!\", \"transparent\", \"red\", 24);\n        // Initialize currency and defense options\n        this.currency = $35da740d59af89ba$var$INITIAL_CURRENCY;\n        this.defenseOptions = this.createDefenseOptions();\n        this.selectedDefense = null;\n        // Initialize the defense grid\n        this.defenseGrid = this.createDefenseGrid();\n        this.levelManager = new $35da740d59af89ba$var$LevelManager();\n        // Add new buttons\n        this.nextLevelButton = new $35da740d59af89ba$var$Button($35da740d59af89ba$var$GAME_WIDTH / 2 - 60, $35da740d59af89ba$var$GAME_HEIGHT / 2 + 50, 120, 40, \"Next Level\");\n        this.levelCompleteText = new $35da740d59af89ba$var$Button($35da740d59af89ba$var$GAME_WIDTH / 2 - 100, $35da740d59af89ba$var$GAME_HEIGHT / 2 - 50, 200, 50, \"Level Complete!\", \"transparent\", \"#4CAF50\", 24);\n        this.gameCompleteText = new $35da740d59af89ba$var$Button($35da740d59af89ba$var$GAME_WIDTH / 2 - 100, $35da740d59af89ba$var$GAME_HEIGHT / 2 - 50, 200, 50, \"Game Complete!\", \"transparent\", \"#4CAF50\", 24);\n        // Add new continue button\n        this.continueButton = new $35da740d59af89ba$var$Button($35da740d59af89ba$var$GAME_WIDTH / 2 - 60, $35da740d59af89ba$var$GAME_HEIGHT / 2 + 50, 120, 40, \"Continue\");\n        this.lifeLostText = new $35da740d59af89ba$var$Button($35da740d59af89ba$var$GAME_WIDTH / 2 - 100, $35da740d59af89ba$var$GAME_HEIGHT / 2 - 50, 200, 50, \"Life Lost!\", \"transparent\", \"#FF4444\", 24);\n        // Add lives property\n        this.lives = $35da740d59af89ba$var$INITIAL_LIVES;\n        // Add high score properties\n        this.currentScore = 0;\n        this.highScore = this.loadHighScore();\n    }\n    initializeCanvas() {\n        // Get dynamic viewport height (accounts for mobile browser UI elements)\n        const viewportWidth = window.innerWidth;\n        const viewportHeight = window.innerHeight;\n        // Calculate maximum possible game size that maintains aspect ratio\n        const gameAspectRatio = $35da740d59af89ba$var$GAME_WIDTH / $35da740d59af89ba$var$GAME_HEIGHT;\n        const viewportAspectRatio = viewportWidth / viewportHeight;\n        let scale;\n        if (viewportAspectRatio > gameAspectRatio) // Viewport is wider than game - fit to height\n        scale = viewportHeight / $35da740d59af89ba$var$GAME_HEIGHT;\n        else // Viewport is taller than game - fit to width\n        scale = viewportWidth / $35da740d59af89ba$var$GAME_WIDTH;\n        // Ensure the scaled size doesn't exceed viewport\n        scale = Math.min(scale, 1);\n        this.canvas.width = $35da740d59af89ba$var$GAME_WIDTH;\n        this.canvas.height = $35da740d59af89ba$var$GAME_HEIGHT;\n        // Apply scale through CSS\n        this.canvas.style.width = `${$35da740d59af89ba$var$GAME_WIDTH * scale}px`;\n        this.canvas.style.height = `${$35da740d59af89ba$var$GAME_HEIGHT * scale}px`;\n    }\n    setupEventListeners() {\n        this.canvas.addEventListener(\"click\", (e)=>{\n            const rect = this.canvas.getBoundingClientRect();\n            const scale = this.canvas.width / rect.width;\n            const x = (e.clientX - rect.left) * scale;\n            const y = (e.clientY - rect.top) * scale;\n            if (this.gameState === $35da740d59af89ba$var$GAME_STATES.MENU) {\n                if (this.startButton.isClicked(x, y)) this.startGame();\n            } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.GAME_OVER) {\n                if (this.retryButton.isClicked(x, y)) this.startGame();\n            } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.LEVEL_COMPLETE) {\n                if (this.nextLevelButton.isClicked(x, y)) this.startNextLevel();\n            } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.PLAYING) {\n                // Check for coin collection first\n                let coinCollected = false;\n                for(let i = this.coins.length - 1; i >= 0; i--){\n                    const coin = this.coins[i];\n                    if (coin.isClicked(x, y)) {\n                        this.currency += coin.value;\n                        this.currentScore += coin.value; // Add to current score\n                        if (this.currentScore > this.highScore) {\n                            this.highScore = this.currentScore;\n                            this.saveHighScore();\n                        }\n                        this.coins.splice(i, 1);\n                        coinCollected = true;\n                        break;\n                    }\n                }\n                // Only check defense interactions if we didn't collect a coin\n                if (!coinCollected) {\n                    // Check if defense option was clicked\n                    this.defenseOptions.forEach((option)=>{\n                        if (option.isClicked(x, y)) {\n                            if (this.selectedDefense === option.type) {\n                                // Deselect if clicking the same defense\n                                this.selectedDefense = null;\n                                console.log(\"Defense deselected\");\n                            } else if (this.currency >= option.type.cost) {\n                                this.selectedDefense = option.type;\n                                console.log(`Selected ${option.type.name} defense`);\n                            } else console.log(\"Not enough currency!\");\n                        }\n                    });\n                    // Check if grid spot was clicked\n                    if (this.selectedDefense) {\n                        const spot = this.getSpotAtPosition(x, y);\n                        if (spot && spot.isEmpty()) {\n                            if (this.currency >= this.selectedDefense.cost) {\n                                spot.placeDefense(this.selectedDefense);\n                                this.currency -= this.selectedDefense.cost;\n                                this.selectedDefense = null; // Reset selection after placing defense\n                            }\n                        }\n                    }\n                }\n            } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.LIFE_LOST) {\n                if (this.continueButton.isClicked(x, y)) this.continuePlaying();\n            }\n        });\n    }\n    startGame() {\n        this.gameState = $35da740d59af89ba$var$GAME_STATES.PLAYING;\n        this.meteors = [];\n        this.coins = [];\n        this.currency = $35da740d59af89ba$var$INITIAL_CURRENCY;\n        this.selectedDefense = null;\n        this.lives = $35da740d59af89ba$var$INITIAL_LIVES; // Reset lives when starting new game\n        this.currentScore = 0; // Reset current score\n        this.levelManager.startLevel(0);\n        // Reset defense grid\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++)this.defenseGrid[row][lane].removeDefense();\n    }\n    startNextLevel() {\n        this.meteors = [];\n        this.coins = [];\n        this.currency = $35da740d59af89ba$var$INITIAL_CURRENCY;\n        this.selectedDefense = null;\n        // Reset defense grid\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++)this.defenseGrid[row][lane].removeDefense();\n        this.levelManager.startLevel(this.levelManager.currentLevel + 1);\n        this.gameState = $35da740d59af89ba$var$GAME_STATES.PLAYING;\n    }\n    gameLoop(timestamp) {\n        // Calculate delta time\n        const deltaTime = timestamp - this.lastTime;\n        this.lastTime = timestamp;\n        // Clear canvas\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        // Update and draw game elements\n        this.update(deltaTime);\n        this.draw();\n        // Continue game loop\n        requestAnimationFrame((timestamp)=>this.gameLoop(timestamp));\n    }\n    drawBackground() {\n        // Fill entire canvas with background color first\n        this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.BACKGROUND;\n        this.ctx.fillRect(0, 0, $35da740d59af89ba$var$GAME_WIDTH, $35da740d59af89ba$var$GAME_HEIGHT);\n        // Draw game area border\n        this.ctx.strokeStyle = $35da740d59af89ba$var$COLORS.BORDER;\n        this.ctx.strokeRect($35da740d59af89ba$var$PADDING_LEFT, $35da740d59af89ba$var$PADDING_TOP, this.gameAreaWidth, this.gameAreaHeight);\n        // Draw lanes\n        for(let i = 0; i <= $35da740d59af89ba$var$LANES; i++){\n            const x = $35da740d59af89ba$var$PADDING_LEFT + i * this.laneWidth;\n            this.ctx.beginPath();\n            this.ctx.moveTo(x, $35da740d59af89ba$var$PADDING_TOP);\n            this.ctx.lineTo(x, $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM);\n            this.ctx.stroke();\n        }\n        // Draw padding areas (slightly darker shade for visual separation)\n        this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.BACKGROUND;\n        // Top padding\n        this.ctx.fillRect(0, 0, $35da740d59af89ba$var$GAME_WIDTH, $35da740d59af89ba$var$PADDING_TOP);\n        // Bottom padding\n        this.ctx.fillRect(0, $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM, $35da740d59af89ba$var$GAME_WIDTH, $35da740d59af89ba$var$PADDING_BOTTOM);\n        // Left padding\n        this.ctx.fillRect(0, $35da740d59af89ba$var$PADDING_TOP, $35da740d59af89ba$var$PADDING_LEFT, this.gameAreaHeight);\n        // Right padding\n        this.ctx.fillRect($35da740d59af89ba$var$GAME_WIDTH - $35da740d59af89ba$var$PADDING_RIGHT, $35da740d59af89ba$var$PADDING_TOP, $35da740d59af89ba$var$PADDING_RIGHT, this.gameAreaHeight);\n        // Draw defense grid\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++)this.defenseGrid[row][lane].draw(this.ctx);\n    }\n    update(deltaTime) {\n        if (this.gameState !== $35da740d59af89ba$var$GAME_STATES.PLAYING) return;\n        const currentTime = performance.now();\n        // Update all defense spots\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++)this.defenseGrid[row][lane].update(currentTime, this.meteors, this.coins);\n        // Update meteors and check for lives\n        this.meteors = this.meteors.filter((meteor)=>{\n            meteor.update(deltaTime);\n            if (meteor.y >= $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM) {\n                this.lives--;\n                if (this.lives <= 0) this.gameState = $35da740d59af89ba$var$GAME_STATES.GAME_OVER;\n                else this.gameState = $35da740d59af89ba$var$GAME_STATES.LIFE_LOST; // Show life lost screen\n                return false;\n            }\n            return true;\n        });\n        // Update coins\n        this.coins = this.coins.filter((coin)=>{\n            return coin.update(currentTime);\n        });\n        // Update level manager\n        this.levelManager.update(currentTime, this.meteors);\n        // Check for level completion\n        if (this.levelManager.isLevelComplete(this.meteors)) {\n            if (this.levelManager.currentLevel >= $35da740d59af89ba$var$LEVELS.length - 1) this.gameState = $35da740d59af89ba$var$GAME_STATES.GAME_COMPLETE;\n            else this.gameState = $35da740d59af89ba$var$GAME_STATES.LEVEL_COMPLETE;\n        }\n    }\n    drawCurrency() {\n        const currencyY = $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM + 15; // Position below game grid\n        this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.TEXT;\n        this.ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n        this.ctx.textAlign = \"center\";\n        // Draw currency centered below grid\n        this.ctx.fillText(`Currency: $${this.currency}`, $35da740d59af89ba$var$GAME_WIDTH / 2, currencyY);\n        // Draw scores in top left corner\n        this.ctx.textAlign = \"left\";\n        this.ctx.fillText(`Score: ${this.currentScore}`, $35da740d59af89ba$var$PADDING_LEFT / 3, $35da740d59af89ba$var$PADDING_TOP + 20);\n    // this.ctx.fillText(\n    //   `High Score: ${this.highScore}`,\n    //   PADDING_LEFT / 3,\n    //   (PADDING_TOP / 6) * 5,\n    // );\n    }\n    draw() {\n        this.drawBackground();\n        if (this.gameState === $35da740d59af89ba$var$GAME_STATES.LOADING) this.drawLoadingScreen();\n        else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.MENU) {\n            this.startButton.draw(this.ctx);\n            this.drawVersion();\n        } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.PLAYING) {\n            // Draw currency and lives\n            this.drawCurrency();\n            this.drawLives();\n            this.drawProgressBar(this.ctx);\n            // Draw defense options\n            this.defenseOptions.forEach((option)=>{\n                option.draw(this.ctx, this.selectedDefense && option.type.id === this.selectedDefense.id, this.currency);\n            });\n            // Draw meteors\n            this.meteors.forEach((meteor)=>meteor.draw(this.ctx));\n            // Draw coins\n            const currentTime = performance.now();\n            this.coins.forEach((coin)=>coin.draw(this.ctx, currentTime));\n            this.drawVersion();\n        } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.LIFE_LOST) {\n            // Draw the life lost screen\n            this.drawCurrency();\n            this.drawLives();\n            this.drawProgressBar(this.ctx);\n            // Add semi-transparent overlay\n            this.ctx.fillStyle = \"rgba(0, 0, 0, 0.7)\";\n            this.ctx.fillRect(0, 0, $35da740d59af89ba$var$GAME_WIDTH, $35da740d59af89ba$var$GAME_HEIGHT);\n            this.lifeLostText.draw(this.ctx);\n            this.continueButton.draw(this.ctx);\n            // Show remaining lives text\n            this.ctx.fillStyle = \"#FFF\";\n            this.ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n            this.ctx.textAlign = \"center\";\n            this.ctx.fillText(`${this.lives} ${this.lives === 1 ? \"life\" : \"lives\"} remaining`, $35da740d59af89ba$var$GAME_WIDTH / 2, $35da740d59af89ba$var$GAME_HEIGHT / 2);\n            this.drawVersion();\n        } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.LEVEL_COMPLETE) {\n            this.levelCompleteText.draw(this.ctx);\n            this.nextLevelButton.draw(this.ctx);\n            this.drawVersion();\n        } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.GAME_COMPLETE) {\n            this.gameCompleteText.draw(this.ctx);\n            this.drawVersion();\n        } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.GAME_OVER) {\n            this.gameOverText.draw(this.ctx);\n            this.retryButton.draw(this.ctx);\n            // Draw scores\n            this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.TEXT;\n            this.ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n            this.ctx.textAlign = \"center\";\n            this.ctx.fillText(`Final Score: ${this.currentScore}`, $35da740d59af89ba$var$GAME_WIDTH / 2, $35da740d59af89ba$var$GAME_HEIGHT / 2 + 50);\n            this.ctx.fillText(`High Score: ${this.highScore}`, $35da740d59af89ba$var$GAME_WIDTH / 2, $35da740d59af89ba$var$GAME_HEIGHT / 2 + 80);\n            this.drawVersion();\n        }\n    }\n    createDefenseOptions() {\n        const optionsAreaY = $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM + 30; // Move down to make room for currency\n        const spacing = 20;\n        const totalWidth = ($35da740d59af89ba$var$SPOT_SIZE + spacing) * $35da740d59af89ba$var$DEFENSE_TYPES.length - spacing;\n        const startX = ($35da740d59af89ba$var$GAME_WIDTH - totalWidth) / 2;\n        return $35da740d59af89ba$var$DEFENSE_TYPES.map((type, index)=>{\n            const x = startX + index * ($35da740d59af89ba$var$SPOT_SIZE + spacing);\n            const y = optionsAreaY;\n            return new $35da740d59af89ba$var$DefenseOption(type, x, y);\n        });\n    }\n    createDefenseGrid() {\n        const grid = [];\n        // Create 2D array for easier position reference\n        for(let row = 0; row < $35da740d59af89ba$var$GRID_ROWS; row++){\n            const rowArray = [];\n            for(let lane = 0; lane < $35da740d59af89ba$var$LANES; lane++){\n                const x = $35da740d59af89ba$var$PADDING_LEFT + lane * $35da740d59af89ba$var$LANE_WIDTH + $35da740d59af89ba$var$LANE_WIDTH / 2;\n                const y = $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM - row * $35da740d59af89ba$var$SPOT_SIZE - $35da740d59af89ba$var$SPOT_SIZE / 2;\n                rowArray.push(new $35da740d59af89ba$var$DefenseSpot(x, y, row, lane));\n            }\n            grid.push(rowArray);\n        }\n        return grid;\n    }\n    // Helper method to get spot at specific coordinates\n    getSpotAtPosition(x, y) {\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++){\n            const spot = this.defenseGrid[row][lane];\n            if (x >= spot.x - $35da740d59af89ba$var$SPOT_SIZE / 2 && x <= spot.x + $35da740d59af89ba$var$SPOT_SIZE / 2 && y >= spot.y - $35da740d59af89ba$var$SPOT_SIZE / 2 && y <= spot.y + $35da740d59af89ba$var$SPOT_SIZE / 2) return spot;\n        }\n        return null;\n    }\n    drawProgressBar(ctx) {\n        // Draw progress bar background\n        const barWidth = $35da740d59af89ba$var$GAME_WIDTH - 100; // Leave some padding\n        const barHeight = 20;\n        const x = 50; // Padding from left\n        const y = 20; // Padding from top\n        // Background\n        ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n        ctx.fillRect(x, y, barWidth, barHeight);\n        // Progress (inverted to show remaining time)\n        const progress = 1 - this.levelManager.getLevelProgress();\n        ctx.fillStyle = $35da740d59af89ba$var$COLORS.PROGRESS_BAR;\n        ctx.fillRect(x, y, barWidth * progress, barHeight);\n        // Border\n        ctx.strokeStyle = $35da740d59af89ba$var$COLORS.BORDER;\n        ctx.strokeRect(x, y, barWidth, barHeight);\n        // Level text\n        ctx.fillStyle = $35da740d59af89ba$var$COLORS.TEXT;\n        ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n        ctx.textAlign = \"center\";\n        ctx.fillText(`${$35da740d59af89ba$var$LEVELS[this.levelManager.currentLevel].name}`, $35da740d59af89ba$var$GAME_WIDTH / 2, y + barHeight + 16);\n        // Time remaining\n        const timeLeft = Math.ceil(($35da740d59af89ba$var$LEVELS[this.levelManager.currentLevel].duration - (performance.now() - this.levelManager.levelStartTime)) / 1000);\n        if (timeLeft > 0) {\n            ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n            ctx.fillText(`${timeLeft}s`, $35da740d59af89ba$var$GAME_WIDTH - 30, y + barHeight / 2 + 5);\n        }\n    }\n    async loadAssets() {\n        const success = await this.assetLoader.loadAll();\n        if (success) this.gameState = $35da740d59af89ba$var$GAME_STATES.MENU;\n        else console.error(\"Failed to load assets\");\n    }\n    drawLoadingScreen() {\n        const progress = this.assetLoader.getLoadingProgress();\n        // Draw loading bar\n        const barWidth = 200;\n        const barHeight = 20;\n        const x = ($35da740d59af89ba$var$GAME_WIDTH - barWidth) / 2;\n        const y = $35da740d59af89ba$var$GAME_HEIGHT / 2;\n        // Background\n        this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.BUTTON;\n        this.ctx.fillRect(x, y, barWidth, barHeight);\n        // Progress\n        this.ctx.fillStyle = \"#4CAF50\";\n        this.ctx.fillRect(x, y, barWidth * progress, barHeight);\n        // Border\n        this.ctx.strokeStyle = $35da740d59af89ba$var$COLORS.TEXT;\n        this.ctx.strokeRect(x, y, barWidth, barHeight);\n        // Loading text\n        this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.TEXT;\n        this.ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n        this.ctx.textAlign = \"center\";\n        this.ctx.fillText(\"Loading...\", $35da740d59af89ba$var$GAME_WIDTH / 2, y - 20);\n        this.ctx.fillText(`${Math.floor(progress * 100)}%`, $35da740d59af89ba$var$GAME_WIDTH / 2, y + 40);\n    }\n    drawLives() {\n        const heartSize = 17;\n        const spacing = 5;\n        const startX = $35da740d59af89ba$var$GAME_WIDTH - (heartSize + spacing) * $35da740d59af89ba$var$INITIAL_LIVES;\n        const y = $35da740d59af89ba$var$PADDING_TOP + 20;\n        this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.TEXT;\n        this.ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n        this.ctx.textAlign = \"right\";\n        this.ctx.fillText(\"Lives:\", startX - spacing * 2, y);\n        // Draw hearts\n        for(let i = 0; i < $35da740d59af89ba$var$INITIAL_LIVES; i++){\n            const x = startX + (heartSize + spacing) * i;\n            // Draw empty heart outline\n            this.ctx.strokeStyle = \"#FF0000\";\n            this.ctx.lineWidth = 2;\n            this.drawHeart(x, y - heartSize / 2, heartSize);\n            // Fill heart if life is remaining\n            if (i < this.lives) {\n                this.ctx.fillStyle = \"#FF0000\";\n                this.drawHeart(x, y - heartSize / 2, heartSize, true);\n            }\n        }\n    }\n    // Helper method to draw a heart\n    drawHeart(x, y, size, fill = false) {\n        const path = new Path2D();\n        path.moveTo(x, y + size / 4);\n        path.bezierCurveTo(x, y, x - size / 2, y, x - size / 2, y + size / 4);\n        path.bezierCurveTo(x - size / 2, y + size / 2, x, y + size * 3 / 4, x, y + size * 3 / 4);\n        path.bezierCurveTo(x, y + size * 3 / 4, x + size / 2, y + size / 2, x + size / 2, y + size / 4);\n        path.bezierCurveTo(x + size / 2, y, x, y, x, y + size / 4);\n        if (fill) this.ctx.fill(path);\n        else this.ctx.stroke(path);\n    }\n    // Add new method to continue playing\n    continuePlaying() {\n        this.gameState = $35da740d59af89ba$var$GAME_STATES.PLAYING;\n        // Clear any remaining meteors to give player a fresh start\n        this.meteors = [];\n    }\n    // Add after constructor\n    loadHighScore() {\n        const saved = localStorage.getItem($35da740d59af89ba$var$STORAGE_KEY);\n        return saved ? parseInt(saved, 0) : 0;\n    }\n    saveHighScore() {\n        localStorage.setItem($35da740d59af89ba$var$STORAGE_KEY, this.highScore.toString());\n    }\n    // Add new method to draw version\n    drawVersion() {\n        this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.TEXT;\n        this.ctx.font = \"11px Arial\"; // Smaller font size\n        this.ctx.textAlign = \"left\";\n        this.ctx.fillText(`v${$35da740d59af89ba$var$LEVEL_GEN_CONFIG.levelVersion}`, 5, $35da740d59af89ba$var$GAME_HEIGHT - 5); // Position in bottom left corner\n    }\n}\n// Start the game when the page loads\nwindow.addEventListener(\"load\", ()=>{\n    $35da740d59af89ba$var$game = new $35da740d59af89ba$var$Game();\n});\n\n\n//# sourceMappingURL=index.a4f6af30.js.map\n","// Game constants\nconst GAME_WIDTH = 360; // Base width, will be scaled\nconst GAME_HEIGHT = 640; // 16:9 ratio\nconst LANES = 6;\nconst PADDING_TOP = 40; // More space for score/level\nconst PADDING_BOTTOM = 100; // More space for controls/UI\nconst PADDING_LEFT = 40;\nconst PADDING_RIGHT = 40;\n\nconst INITIAL_CURRENCY = 500;\nconst INITIAL_LIVES = 3;\n\n// Game area calculations\nconst GAME_AREA_WIDTH = GAME_WIDTH - (PADDING_LEFT + PADDING_RIGHT);\nconst GAME_AREA_HEIGHT = GAME_HEIGHT - (PADDING_TOP + PADDING_BOTTOM);\nconst LANE_WIDTH = GAME_AREA_WIDTH / LANES; // Width of each lane\nconst SPOT_SIZE = LANE_WIDTH; // Defense spots are same width as lanes\nconst METEOR_SIZE = LANE_WIDTH * 0.8; // Base size for meteors\nconst GRID_ROWS = Math.floor(GAME_AREA_HEIGHT / SPOT_SIZE);\n\n// Add to game constants\nconst DEBUG = false; // Toggle for development visualization\n\nconst COLORS = {\n  BACKGROUND: \"#edf1e7\",\n  TEXT: \"#000\",\n  DEFENSE_OPTION_TEXT: \"#000\",\n  DEFENSE_OPTION_TEXT_INACTIVE: \"#f00\",\n  BUTTON: \"#444\",\n  BUTTON_TEXT: \"#fff\",\n  PROGRESS_BAR: \"#4CAF50\",\n  BORDER: \"#333\",\n  DEBUG_LINE: \"rgba(0,0,0,0.1)\",\n  DEBUG_TEXT: \"#666\",\n  SELECTION: \"rgba(255,80,80,0.7)\",\n};\n\n// Level generation configuration options\nconst LEVEL_GEN_CONFIG = {\n  levelVersion: 1.3,\n  baseDuration: 30000, // Base duration in ms\n  durationIncrease: 5000, // How much to increase duration per level (15s)\n  maxLevels: 30, // How many levels to generate\n  difficultyMultiplier: 0.85, // NEW: Global difficulty multiplier (1.0 = normal, < 1.0 easier, > 1.0 harder)\n\n  // Meteor type weights (chance of spawning) at start and end of level\n  meteorWeights: {\n    start: { small: 1, medium: 0, large: 0 },\n    end: { small: 0.4, medium: 0.3, large: 0.3 },\n  },\n\n  // Spawn timing\n  minSpawnGap: 900, // Minimum ms between meteors at start\n  minSpawnGapEnd: 300, // Minimum gap by end of level\n\n  maxSpawnGap: 1500, // Maximum ms between meteors at start\n  maxSpawnGapEnd: 700, // Maximum gap by end of level (NEW)\n\n  // Difficulty scaling\n  difficultyRamp: 1.25, // Multiplier for difficulty between levels\n  waveDuration: 6000, // Initial duration of attack waves in ms\n  waveDurationEnd: 2000, // End duration of attack waves in ms (NEW)\n  waveGap: 3200, // Initial gap between waves in ms\n  waveGapEnd: 1200, // End gap between waves in ms (NEW)\n};\n\nfunction generateLevels(config = LEVEL_GEN_CONFIG) {\n  const levels = [];\n  const diff = config.difficultyMultiplier;\n\n  for (let levelNum = 0; levelNum < config.maxLevels; levelNum++) {\n    const duration =\n      (config.baseDuration + config.durationIncrease * levelNum) /\n      Math.sqrt(diff);\n    const meteors = [];\n    let currentTime = 1000;\n\n    const levelDifficulty = Math.pow(config.difficultyRamp, levelNum) * diff;\n\n    while (currentTime < duration - 2000) {\n      const levelProgress = currentTime / duration;\n      const adjustedWaveDuration = lerp(\n        config.waveDuration / Math.sqrt(diff),\n        config.waveDurationEnd / Math.sqrt(diff),\n        levelProgress,\n      );\n\n      const waveEndTime = currentTime + adjustedWaveDuration;\n\n      while (currentTime < waveEndTime) {\n        const waveProgress =\n          (currentTime - (waveEndTime - adjustedWaveDuration)) /\n          adjustedWaveDuration;\n\n        // Adjust weights based on difficulty (harder = more medium/large meteors)\n        const weights = {\n          small: lerp(\n            config.meteorWeights.start.small,\n            config.meteorWeights.end.small / diff, // Reduce small meteors at higher difficulty\n            waveProgress,\n          ),\n          medium: lerp(\n            config.meteorWeights.start.medium,\n            config.meteorWeights.end.medium * diff, // Increase medium meteors at higher difficulty\n            waveProgress,\n          ),\n          large: lerp(\n            config.meteorWeights.start.large,\n            config.meteorWeights.end.large * diff, // Increase large meteors at higher difficulty\n            waveProgress,\n          ),\n        };\n\n        // Select meteor type based on weights\n        const meteorType = selectMeteorType(weights);\n\n        // Select random lane\n        const lane = Math.floor(Math.random() * LANES);\n\n        meteors.push({\n          type: meteorType,\n          lane: lane,\n          startTime: Math.floor(currentTime),\n        });\n\n        // Adjust spawn gaps based on difficulty (harder = faster spawns)\n        const minGap = lerp(\n          config.minSpawnGap / diff,\n          config.minSpawnGapEnd / diff,\n          waveProgress,\n        );\n        const maxGap = lerp(\n          config.maxSpawnGap / diff,\n          config.maxSpawnGapEnd / diff,\n          waveProgress,\n        );\n        currentTime += Math.random() * (maxGap - minGap) + minGap;\n      }\n\n      const adjustedWaveGap = lerp(\n        config.waveGap / diff,\n        config.waveGapEnd / diff,\n        levelProgress,\n      );\n      currentTime += adjustedWaveGap;\n    }\n\n    levels.push({\n      name: `Level ${levelNum + 1}`,\n      duration: duration,\n      meteors: meteors.sort((a, b) => a.startTime - b.startTime),\n    });\n  }\n\n  return levels;\n}\n\n// Helper function to linearly interpolate between two values\nfunction lerp(start, end, progress) {\n  return start + (end - start) * progress;\n}\n\n// Helper function to select meteor type based on weights\nfunction selectMeteorType(weights) {\n  const total = weights.small + weights.medium + weights.large;\n  const random = Math.random() * total;\n\n  if (random < weights.small) return 0; // Small meteor\n  if (random < weights.small + weights.medium) return 1; // Medium meteor\n  return 2; // Large meteor\n}\n\n// Replace the existing LEVELS constant with generated levels\nconst LEVELS = generateLevels();\n\nconst GAME_STATES = {\n  LOADING: \"loading\",\n  MENU: \"menu\",\n  PLAYING: \"playing\",\n  LIFE_LOST: \"lifeLost\",\n  LEVEL_COMPLETE: \"levelComplete\",\n  GAME_OVER: \"gameover\",\n  GAME_COMPLETE: \"gameComplete\",\n};\n\n// Add to game constants\nconst DEFENSE_TYPES = [\n  {\n    id: 0,\n    name: \"Basic\",\n    color: \"#4CAF50\",\n    cost: 100,\n    damage: 10,\n    health: 100,\n  },\n  {\n    id: 1,\n    name: \"Medium\",\n    color: \"#2196F3\",\n    cost: 150,\n    damage: 20,\n    health: 100,\n  },\n  {\n    id: 2,\n    name: \"Strong\",\n    color: \"#9C27B0\",\n    cost: 200,\n    damage: 30,\n    health: 100,\n  },\n];\n\n// Add to game constants\nconst METEOR_TYPES = [\n  {\n    id: 0,\n    name: \"Small\",\n    color: \"#FF9999\",\n    health: 30,\n    speed: 0.05,\n    damageRate: 30,\n    rotateRate: 0.0005,\n    wiggleRate: 0.001,\n    wiggleAmount: 7,\n    sizeMultiplier: { x: 1.0, y: 1.0 },\n    coinReward: 20, // 1 coin\n  },\n  {\n    id: 1,\n    name: \"Medium\",\n    color: \"#FF4444\",\n    health: 50,\n    speed: 0.035,\n    damageRate: 50,\n    rotateRate: 0,\n    wiggleRate: 0.03,\n    wiggleAmount: 0.03,\n    sizeMultiplier: { x: 1, y: 2 },\n    coinReward: 40, // 2 coins\n  },\n  {\n    id: 2,\n    name: \"Large\",\n    color: \"#FF0000\",\n    health: 70,\n    speed: 0.05,\n    damageRate: 50,\n    rotateRate: 0,\n    wiggleRate: 0.03,\n    wiggleAmount: 0.03,\n    sizeMultiplier: { x: 1, y: 2 },\n    coinReward: 50, // 3 coins\n  },\n];\n\n// Font definitions\nconst FONT = {\n  SMALL: {\n    size: \"12px\",\n    family: \"Arial\",\n    get full() {\n      return `${this.size} ${this.family}`;\n    },\n  },\n  LARGE: {\n    size: \"14px\",\n    family: \"Arial\",\n    get full() {\n      return `${this.size} ${this.family}`;\n    },\n  },\n};\n\n// Add at the top of the file, after other constants\nconst ASSETS = {\n  METEORS: [\n    \"/assets/img/meteor-1.png\",\n    \"/assets/img/meteor-2.png\",\n    \"/assets/img/meteor-3.png\",\n  ],\n};\n\n// Add new AssetLoader class\nclass AssetLoader {\n  constructor() {\n    this.images = new Map();\n    this.totalAssets = 0;\n    this.loadedAssets = 0;\n  }\n\n  async loadAll() {\n    const meteorPromises = ASSETS.METEORS.map((path, index) =>\n      this.loadImage(`meteor-${index}`, path),\n    );\n\n    try {\n      await Promise.all(meteorPromises);\n      return true;\n    } catch (error) {\n      console.error(\"Error loading assets:\", error);\n      return false;\n    }\n  }\n\n  loadImage(key, src) {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      this.totalAssets++;\n\n      img.onload = () => {\n        this.images.set(key, img);\n        this.loadedAssets++;\n        resolve(img);\n      };\n\n      img.onerror = () => {\n        reject(new Error(`Failed to load image: ${src}`));\n      };\n\n      img.src = src;\n    });\n  }\n\n  getImage(key) {\n    return this.images.get(key);\n  }\n\n  getLoadingProgress() {\n    return this.totalAssets ? this.loadedAssets / this.totalAssets : 0;\n  }\n}\n\n// Add at the top of the file, after constants\nlet game; // Global game instance\n\n// Test meteor\nclass Meteor {\n  constructor(lane, type = METEOR_TYPES[0]) {\n    this.lane = lane;\n    this.type = type;\n    this.y = PADDING_TOP;\n    this.health = type.health;\n    this.speed = type.speed;\n    this.isBlocked = false;\n    this.blockingDefense = null;\n\n    // Add rotation and wiggle properties\n    this.baseRotation = 0; // Base rotation from type.rotateRate\n    this.wiggleRotation = 0; // Additional rotation from wiggle motion\n    this.wiggleOffset = 0;\n    this.baseX = PADDING_LEFT + lane * LANE_WIDTH + LANE_WIDTH / 2;\n  }\n\n  update(deltaTime) {\n    if (!this.isBlocked) {\n      this.y += this.speed * deltaTime;\n\n      // Update base rotation\n      this.baseRotation += this.type.rotateRate * deltaTime;\n\n      // Update wiggle and calculate wiggle-based rotation\n      this.wiggleOffset += this.type.wiggleRate * deltaTime;\n      // Calculate rotation based on wiggle movement (adjust 0.5 to control rotation intensity)\n      this.wiggleRotation =\n        Math.cos(this.wiggleOffset) * this.type.wiggleAmount * 0.5;\n    }\n  }\n\n  block(defense) {\n    this.isBlocked = true;\n    this.blockingDefense = defense;\n  }\n\n  unblock() {\n    this.isBlocked = false;\n    this.blockingDefense = null;\n  }\n\n  draw(ctx) {\n    // Calculate wiggled x position\n    const wiggleX =\n      this.baseX + Math.sin(this.wiggleOffset) * this.type.wiggleAmount;\n\n    // Get the corresponding meteor image\n    const meteorImage = game?.assetLoader.getImage(`meteor-${this.type.id}`);\n\n    if (meteorImage) {\n      ctx.save(); // Save current context state\n\n      // Translate to meteor position\n      ctx.translate(wiggleX, this.y);\n\n      // Apply combined rotation (base rotation + wiggle-based rotation)\n      ctx.rotate(this.baseRotation + this.wiggleRotation);\n\n      // Calculate size using multiplier\n      const height = METEOR_SIZE * this.type.sizeMultiplier.y;\n      const width = METEOR_SIZE * this.type.sizeMultiplier.x;\n\n      // Draw the image centered at the translated position\n      ctx.drawImage(meteorImage, -width / 2, -height / 2, width, height);\n\n      ctx.restore(); // Restore context state\n    } else {\n      // Fallback to original circle drawing if image isn't loaded\n      ctx.fillStyle = this.type.color;\n      ctx.beginPath();\n      ctx.arc(wiggleX, this.y, 10, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    if (DEBUG) {\n      // Draw collision circle\n      ctx.strokeStyle = \"rgba(255,0,0,0.3)\";\n      ctx.beginPath();\n      ctx.arc(wiggleX, this.y, 10, 0, Math.PI * 2);\n      ctx.stroke();\n\n      // Draw health\n      ctx.fillStyle = \"white\";\n      ctx.font = FONT.SMALL.full;\n      ctx.textAlign = \"center\";\n      ctx.fillText(`${this.health}`, wiggleX, this.y);\n    }\n  }\n\n  takeDamage(damage) {\n    this.health -= damage;\n    return this.health <= 0;\n  }\n}\n\n// Add to existing constants\nclass Button {\n  constructor(\n    x,\n    y,\n    width,\n    height,\n    text,\n    backgroundColor = COLORS.BUTTON,\n    textColor = COLORS.BUTTON_TEXT,\n    fontSize = 16,\n  ) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.text = text;\n    this.backgroundColor = backgroundColor;\n    this.textColor = textColor;\n    this.fontSize = fontSize;\n  }\n\n  isClicked(clickX, clickY) {\n    return (\n      clickX >= this.x &&\n      clickX <= this.x + this.width &&\n      clickY >= this.y &&\n      clickY <= this.y + this.height\n    );\n  }\n\n  draw(ctx) {\n    // Draw button background\n    ctx.fillStyle = this.backgroundColor;\n    ctx.fillRect(this.x, this.y, this.width, this.height);\n\n    // Draw button text\n    ctx.fillStyle = this.textColor;\n    ctx.font = FONT.LARGE.full;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height / 2);\n  }\n}\n\nclass Projectile {\n  constructor(x, y, damage) {\n    this.x = x;\n    this.y = y;\n    this.speed = 0.3;\n    this.damage = damage;\n    this.size = 4;\n  }\n\n  update(deltaTime) {\n    this.y -= this.speed * deltaTime;\n  }\n\n  draw(ctx) {\n    ctx.fillStyle = \"black\";\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n    ctx.fill();\n\n    if (DEBUG) {\n      // Draw collision circle\n      ctx.strokeStyle = \"rgba(255,255,0,0.3)\";\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n  }\n\n  checkCollision(meteor) {\n    const meteorX = PADDING_LEFT + meteor.lane * LANE_WIDTH + LANE_WIDTH / 2;\n    const dx = this.x - meteorX;\n    const dy = this.y - meteor.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < this.size + 10; // 10 is meteor radius\n  }\n\n  isOffScreen() {\n    return this.y < PADDING_TOP;\n  }\n}\n\n// Add to game constants\nclass Defense {\n  constructor(type = null) {\n    this.type = type;\n    this.health = type ? type.health : 0;\n    this.maxHealth = type ? type.health : 0;\n    this.projectiles = [];\n    this.lastFireTime = 0;\n    this.fireRate = 1000;\n    this.blockingMeteors = []; // Add array to track blocked meteors\n  }\n\n  isEmpty() {\n    return this.type === null;\n  }\n\n  takeDamage(amount) {\n    this.health -= amount;\n    return this.health <= 0;\n  }\n\n  update(currentTime, x, y, meteors, coins) {\n    if (!this.isEmpty()) {\n      // Fire projectile if enough time has passed\n      if (currentTime - this.lastFireTime > this.fireRate) {\n        this.projectiles.push(new Projectile(x, y, this.type.damage));\n        this.lastFireTime = currentTime;\n      }\n\n      // Check for meteor collisions with this defense\n      const defenseRow = Math.floor((y - PADDING_TOP) / SPOT_SIZE);\n      meteors.forEach((meteor) => {\n        const meteorRow = Math.floor((meteor.y - PADDING_TOP) / SPOT_SIZE);\n        if (\n          meteorRow === defenseRow &&\n          meteor.lane === Math.floor((x - PADDING_LEFT) / LANE_WIDTH)\n        ) {\n          // Block meteor if not already blocked\n          if (!meteor.isBlocked) {\n            meteor.block(this);\n            this.blockingMeteors.push(meteor); // Track this meteor\n          }\n\n          // Take damage from meteor using meteor's damage rate\n          if (meteor.blockingDefense === this) {\n            const destroyed = this.takeDamage(meteor.type.damageRate / 60);\n            if (destroyed) {\n              // Unblock all meteors this defense was blocking\n              this.blockingMeteors.forEach((m) => m.unblock());\n              this.blockingMeteors = [];\n              this.type = null; // Reset defense when destroyed\n              this.health = 0;\n              this.maxHealth = 0;\n            }\n          }\n        }\n      });\n\n      // Update existing projectiles and check collisions\n      this.projectiles = this.projectiles.filter((projectile) => {\n        projectile.update(16);\n\n        // Check for collisions with any meteor\n        for (let i = 0; i < meteors.length; i++) {\n          const meteor = meteors[i];\n          if (projectile.checkCollision(meteor)) {\n            const destroyed = meteor.takeDamage(projectile.damage);\n            if (destroyed) {\n              // Spawn coin at meteor's position with meteor's reward value\n              const meteorX =\n                PADDING_LEFT + meteor.lane * LANE_WIDTH + LANE_WIDTH / 2;\n              coins.push(new Coin(meteorX, meteor.y, meteor.type.coinReward));\n              meteors.splice(i, 1);\n            }\n            return false; // Remove projectile\n          }\n        }\n\n        return !projectile.isOffScreen();\n      });\n    }\n  }\n\n  draw(ctx, x, y, size, isSelected = false, isInactive = false) {\n    // Draw spot outline\n    ctx.strokeStyle = this.isEmpty() ? COLORS.DEBUG_LINE : \"#888\";\n    ctx.lineWidth = 1;\n    ctx.strokeRect(x - size / 2, y - size / 2, size, size);\n\n    if (!this.isEmpty()) {\n      // Draw defense with health-based opacity\n      ctx.fillStyle = this.type.color;\n      if (isInactive) {\n        ctx.globalAlpha = 0.5;\n      } else {\n        ctx.globalAlpha = Math.max(0.3, this.health / this.maxHealth);\n      }\n      ctx.fillRect(x - size / 2, y - size / 2, size, size);\n      ctx.globalAlpha = 1.0;\n\n      // Draw projectiles\n      this.projectiles.forEach((projectile) => projectile.draw(ctx));\n\n      if (DEBUG) {\n        // Draw health bar\n        ctx.fillStyle = COLORS.TEXT;\n        ctx.font = FONT.SMALL.full;\n        ctx.textAlign = \"center\";\n        ctx.fillText(\n          `${Math.floor((this.health / this.maxHealth) * 100)}%`,\n          x,\n          y,\n        );\n      }\n\n      // Draw selection highlight\n      if (isSelected) {\n        ctx.strokeStyle = COLORS.SELECTION;\n        ctx.lineWidth = 4;\n        ctx.strokeRect(x - size / 2, y - size / 2, size, size);\n      }\n    }\n  }\n}\n\nclass DefenseOption {\n  constructor(type, x, y) {\n    this.type = type;\n    this.x = x;\n    this.y = y;\n    this.defense = new Defense(type);\n  }\n\n  draw(ctx, isSelected = false, currentCurrency = 0) {\n    const isInactive = currentCurrency < this.type.cost;\n\n    // Draw defense using Defense class\n    this.defense.draw(\n      ctx,\n      this.x + SPOT_SIZE / 2,\n      this.y + SPOT_SIZE / 2,\n      SPOT_SIZE,\n      isSelected,\n      isInactive,\n    );\n\n    // Draw cost (red if can't afford)\n    ctx.fillStyle = isInactive\n      ? COLORS.DEFENSE_OPTION_TEXT_INACTIVE\n      : COLORS.DEFENSE_OPTION_TEXT;\n    ctx.font = FONT.LARGE.full;\n    ctx.textAlign = \"center\";\n    ctx.fillText(\n      `$${this.type.cost}`,\n      this.x + SPOT_SIZE / 2,\n      this.y + SPOT_SIZE + 15,\n    );\n  }\n\n  isClicked(clickX, clickY) {\n    return (\n      clickX >= this.x &&\n      clickX <= this.x + SPOT_SIZE &&\n      clickY >= this.y &&\n      clickY <= this.y + SPOT_SIZE\n    );\n  }\n}\n\nclass DefenseSpot {\n  constructor(x, y, row, lane) {\n    this.x = x;\n    this.y = y;\n    this.row = row;\n    this.lane = lane;\n    this.defense = new Defense();\n  }\n\n  isEmpty() {\n    return this.defense.isEmpty();\n  }\n\n  placeDefense(defenseType) {\n    if (this.isEmpty()) {\n      this.defense = new Defense(defenseType);\n      return true;\n    }\n    return false;\n  }\n\n  removeDefense() {\n    this.defense = new Defense(); // Reset to empty defense\n  }\n\n  draw(ctx) {\n    // Draw defense (or empty spot)\n    this.defense.draw(ctx, this.x, this.y, SPOT_SIZE);\n\n    if (DEBUG) {\n      // Draw coordinates for debugging\n      ctx.fillStyle = COLORS.DEBUG_TEXT;\n      ctx.font = FONT.SMALL.full;\n      ctx.textAlign = \"center\";\n      ctx.fillText(`${this.lane},${this.row}`, this.x, this.y);\n    }\n  }\n\n  update(currentTime, meteors, coins) {\n    this.defense.update(currentTime, this.x, this.y, meteors, coins);\n  }\n}\n\nclass Coin {\n  constructor(x, y, value = 10) {\n    this.x = x;\n    this.y = y;\n    this.value = value;\n    this.lifetime = 5000; // 5 seconds lifetime\n    this.createTime = performance.now();\n    this.hitRadius = 30; // Bigger radius for hit detection\n\n    // Size based on value\n    this.size = 8 + ((value - 10) / 10) * 2; // Increases by 2 pixels for each 10 value\n\n    // Base movement\n    const angle = Math.random() * Math.PI * 2;\n    const speed = 0.3 + Math.random() * 0.1;\n    this.vx = Math.cos(angle) * speed;\n    this.vy = Math.sin(angle) * speed;\n\n    // Wave motion parameters\n    this.waveAmplitude = 2.2 + Math.random() * 0.2;\n    this.waveFrequency = 0.005 + Math.random() * 0.001;\n    this.waveOffset = Math.random() * Math.PI * 2;\n    this.baseX = x;\n    this.baseY = y;\n    this.time = 0;\n  }\n\n  draw(ctx, currentTime) {\n    const age = currentTime - this.createTime;\n    const remainingTime = this.lifetime - age;\n\n    // Start blinking when less than 1.5 seconds remaining\n    if (remainingTime < 1500) {\n      const blinkRate = 100 + (remainingTime / 1500) * 400;\n      if (Math.floor(currentTime / blinkRate) % 2 === 0) {\n        return;\n      }\n    }\n\n    if (DEBUG) {\n      // Draw hit area\n      ctx.strokeStyle = \"rgba(255, 80, 80, 0.6)\";\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, this.hitRadius, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n\n    const coinX =\n      this.x +\n      Math.sin(this.time * this.waveFrequency + this.waveOffset) *\n        this.waveAmplitude;\n    const coinY =\n      this.y +\n      Math.cos(this.time * this.waveFrequency + this.waveOffset) *\n        this.waveAmplitude;\n\n    // Draw coin with gradient for more depth\n    const gradient = ctx.createRadialGradient(\n      coinX - this.size / 3,\n      coinY - this.size / 3,\n      0,\n      coinX,\n      coinY,\n      this.size,\n    );\n    gradient.addColorStop(0, \"#FFD700\"); // Bright gold\n    gradient.addColorStop(1, \"#DAA520\"); // Darker gold\n\n    ctx.fillStyle = gradient;\n    ctx.beginPath();\n    ctx.arc(coinX, coinY, this.size, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Add coin border\n    ctx.strokeStyle = \"#B8860B\"; // Dark gold\n    ctx.lineWidth = 1;\n    ctx.stroke();\n\n    // Draw value\n    ctx.fillStyle = \"black\";\n    ctx.font = `bold ${Math.max(10, this.size)}px ${FONT.SMALL.family}`;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(`${this.value}`, coinX, coinY);\n  }\n\n  update(currentTime) {\n    this.time += 16; // Increment time (assuming ~60fps)\n\n    // Update base position with velocity\n    this.baseX += this.vx;\n    this.baseY += this.vy;\n\n    // Add wave motion\n    this.x =\n      this.baseX +\n      Math.sin(this.time * this.waveFrequency + this.waveOffset) *\n        this.waveAmplitude;\n    this.y =\n      this.baseY +\n      Math.cos(this.time * this.waveFrequency + this.waveOffset) *\n        this.waveAmplitude;\n\n    // Calculate remaining lifetime\n    const age = currentTime - this.createTime;\n    return age < this.lifetime;\n  }\n\n  isClicked(clickX, clickY) {\n    const dx = clickX - this.x;\n    const dy = clickY - this.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < this.hitRadius;\n  }\n}\n\nclass LevelManager {\n  constructor() {\n    this.currentLevel = 0;\n    this.levelStartTime = 0;\n    this.remainingMeteors = [];\n    this.allMeteorsSpawned = false;\n  }\n\n  startLevel(levelIndex) {\n    this.currentLevel = levelIndex;\n    this.levelStartTime = performance.now();\n    this.remainingMeteors = [...LEVELS[levelIndex].meteors];\n    this.allMeteorsSpawned = false;\n  }\n\n  update(currentTime, meteors) {\n    if (this.currentLevel >= LEVELS.length) return false;\n\n    const levelTime = currentTime - this.levelStartTime;\n    const level = LEVELS[this.currentLevel];\n\n    // Check if level time is exceeded\n    if (levelTime >= level.duration) {\n      this.allMeteorsSpawned = true;\n      return false;\n    }\n\n    // Spawn meteors that are due\n    while (\n      this.remainingMeteors.length > 0 &&\n      levelTime >= this.remainingMeteors[0].startTime\n    ) {\n      const meteorData = this.remainingMeteors.shift();\n      meteors.push(new Meteor(meteorData.lane, METEOR_TYPES[meteorData.type]));\n    }\n\n    // Check if all meteors have been spawned\n    if (this.remainingMeteors.length === 0) {\n      this.allMeteorsSpawned = true;\n    }\n\n    return true;\n  }\n\n  isLevelComplete(meteors) {\n    return this.allMeteorsSpawned && meteors.length === 0;\n  }\n\n  getLevelProgress() {\n    const levelTime = performance.now() - this.levelStartTime;\n    const duration = LEVELS[this.currentLevel].duration;\n    return Math.min(levelTime / duration, 1);\n  }\n}\n\nconst STORAGE_KEY = \"meteorDefenseHighScore\";\n\nclass Game {\n  constructor() {\n    this.canvas = document.getElementById(\"canvas\");\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.lastTime = 0;\n    this.meteors = [];\n    this.coins = [];\n    this.assetLoader = new AssetLoader();\n    this.gameState = GAME_STATES.LOADING;\n\n    // Initialize game dimensions and scaling\n    this.initializeCanvas();\n    window.addEventListener(\"resize\", () => this.initializeCanvas());\n\n    // Load assets before starting the game\n    this.loadAssets();\n\n    // Start game loop\n    requestAnimationFrame((timestamp) => this.gameLoop(timestamp));\n\n    // Add test meteor in middle lane\n    this.testMeteor = new Meteor(2); // Lane 3 (0-based index)\n\n    // Add game state and button handling\n    this.gameState = GAME_STATES.MENU;\n    this.setupEventListeners();\n\n    // Create buttons\n    const buttonWidth = 100;\n    const buttonHeight = 50;\n    const buttonX = GAME_WIDTH / 2 - buttonWidth / 2;\n    const buttonY = GAME_HEIGHT / 2 - buttonHeight / 2;\n\n    this.startButton = new Button(\n      buttonX,\n      buttonY,\n      buttonWidth,\n      buttonHeight,\n      \"Start Game\",\n    );\n    this.retryButton = new Button(\n      buttonX,\n      buttonY,\n      buttonWidth,\n      buttonHeight,\n      \"Try Again\",\n    );\n    this.gameOverText = new Button(\n      GAME_WIDTH / 2 - 100,\n      GAME_HEIGHT / 2 - 100,\n      200,\n      50,\n      \"Game Over!\",\n      \"transparent\",\n      \"red\",\n      24,\n    );\n\n    // Initialize currency and defense options\n    this.currency = INITIAL_CURRENCY;\n    this.defenseOptions = this.createDefenseOptions();\n    this.selectedDefense = null;\n\n    // Initialize the defense grid\n    this.defenseGrid = this.createDefenseGrid();\n\n    this.levelManager = new LevelManager();\n\n    // Add new buttons\n    this.nextLevelButton = new Button(\n      GAME_WIDTH / 2 - 60,\n      GAME_HEIGHT / 2 + 50,\n      120,\n      40,\n      \"Next Level\",\n    );\n\n    this.levelCompleteText = new Button(\n      GAME_WIDTH / 2 - 100,\n      GAME_HEIGHT / 2 - 50,\n      200,\n      50,\n      \"Level Complete!\",\n      \"transparent\",\n      \"#4CAF50\",\n      24,\n    );\n\n    this.gameCompleteText = new Button(\n      GAME_WIDTH / 2 - 100,\n      GAME_HEIGHT / 2 - 50,\n      200,\n      50,\n      \"Game Complete!\",\n      \"transparent\",\n      \"#4CAF50\",\n      24,\n    );\n\n    // Add new continue button\n    this.continueButton = new Button(\n      GAME_WIDTH / 2 - 60,\n      GAME_HEIGHT / 2 + 50,\n      120,\n      40,\n      \"Continue\",\n    );\n\n    this.lifeLostText = new Button(\n      GAME_WIDTH / 2 - 100,\n      GAME_HEIGHT / 2 - 50,\n      200,\n      50,\n      \"Life Lost!\",\n      \"transparent\",\n      \"#FF4444\",\n      24,\n    );\n\n    // Add lives property\n    this.lives = INITIAL_LIVES;\n\n    // Add high score properties\n    this.currentScore = 0;\n    this.highScore = this.loadHighScore();\n  }\n\n  initializeCanvas() {\n    // Get dynamic viewport height (accounts for mobile browser UI elements)\n    const viewportWidth = window.innerWidth;\n    const viewportHeight = window.innerHeight;\n\n    // Calculate maximum possible game size that maintains aspect ratio\n    const gameAspectRatio = GAME_WIDTH / GAME_HEIGHT;\n    const viewportAspectRatio = viewportWidth / viewportHeight;\n\n    let scale;\n    if (viewportAspectRatio > gameAspectRatio) {\n      // Viewport is wider than game - fit to height\n      scale = viewportHeight / GAME_HEIGHT;\n    } else {\n      // Viewport is taller than game - fit to width\n      scale = viewportWidth / GAME_WIDTH;\n    }\n\n    // Ensure the scaled size doesn't exceed viewport\n    scale = Math.min(scale, 1);\n\n    this.canvas.width = GAME_WIDTH;\n    this.canvas.height = GAME_HEIGHT;\n\n    // Apply scale through CSS\n    this.canvas.style.width = `${GAME_WIDTH * scale}px`;\n    this.canvas.style.height = `${GAME_HEIGHT * scale}px`;\n  }\n\n  setupEventListeners() {\n    this.canvas.addEventListener(\"click\", (e) => {\n      const rect = this.canvas.getBoundingClientRect();\n      const scale = this.canvas.width / rect.width;\n      const x = (e.clientX - rect.left) * scale;\n      const y = (e.clientY - rect.top) * scale;\n\n      if (this.gameState === GAME_STATES.MENU) {\n        if (this.startButton.isClicked(x, y)) {\n          this.startGame();\n        }\n      } else if (this.gameState === GAME_STATES.GAME_OVER) {\n        if (this.retryButton.isClicked(x, y)) {\n          this.startGame();\n        }\n      } else if (this.gameState === GAME_STATES.LEVEL_COMPLETE) {\n        if (this.nextLevelButton.isClicked(x, y)) {\n          this.startNextLevel();\n        }\n      } else if (this.gameState === GAME_STATES.PLAYING) {\n        // Check for coin collection first\n        let coinCollected = false;\n        for (let i = this.coins.length - 1; i >= 0; i--) {\n          const coin = this.coins[i];\n          if (coin.isClicked(x, y)) {\n            this.currency += coin.value;\n            this.currentScore += coin.value; // Add to current score\n            if (this.currentScore > this.highScore) {\n              this.highScore = this.currentScore;\n              this.saveHighScore();\n            }\n            this.coins.splice(i, 1);\n            coinCollected = true;\n            break;\n          }\n        }\n\n        // Only check defense interactions if we didn't collect a coin\n        if (!coinCollected) {\n          // Check if defense option was clicked\n          this.defenseOptions.forEach((option) => {\n            if (option.isClicked(x, y)) {\n              if (this.selectedDefense === option.type) {\n                // Deselect if clicking the same defense\n                this.selectedDefense = null;\n                console.log(\"Defense deselected\");\n              } else if (this.currency >= option.type.cost) {\n                this.selectedDefense = option.type;\n                console.log(`Selected ${option.type.name} defense`);\n              } else {\n                console.log(\"Not enough currency!\");\n              }\n            }\n          });\n\n          // Check if grid spot was clicked\n          if (this.selectedDefense) {\n            const spot = this.getSpotAtPosition(x, y);\n            if (spot && spot.isEmpty()) {\n              if (this.currency >= this.selectedDefense.cost) {\n                spot.placeDefense(this.selectedDefense);\n                this.currency -= this.selectedDefense.cost;\n                this.selectedDefense = null; // Reset selection after placing defense\n              }\n            }\n          }\n        }\n      } else if (this.gameState === GAME_STATES.LIFE_LOST) {\n        if (this.continueButton.isClicked(x, y)) {\n          this.continuePlaying();\n        }\n      }\n    });\n  }\n\n  startGame() {\n    this.gameState = GAME_STATES.PLAYING;\n    this.meteors = [];\n    this.coins = [];\n    this.currency = INITIAL_CURRENCY;\n    this.selectedDefense = null;\n    this.lives = INITIAL_LIVES; // Reset lives when starting new game\n    this.currentScore = 0; // Reset current score\n    this.levelManager.startLevel(0);\n\n    // Reset defense grid\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        this.defenseGrid[row][lane].removeDefense();\n      }\n    }\n  }\n\n  startNextLevel() {\n    this.meteors = [];\n    this.coins = [];\n    this.currency = INITIAL_CURRENCY;\n    this.selectedDefense = null;\n\n    // Reset defense grid\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        this.defenseGrid[row][lane].removeDefense();\n      }\n    }\n\n    this.levelManager.startLevel(this.levelManager.currentLevel + 1);\n    this.gameState = GAME_STATES.PLAYING;\n  }\n\n  gameLoop(timestamp) {\n    // Calculate delta time\n    const deltaTime = timestamp - this.lastTime;\n    this.lastTime = timestamp;\n\n    // Clear canvas\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    // Update and draw game elements\n    this.update(deltaTime);\n    this.draw();\n\n    // Continue game loop\n    requestAnimationFrame((timestamp) => this.gameLoop(timestamp));\n  }\n\n  drawBackground() {\n    // Fill entire canvas with background color first\n    this.ctx.fillStyle = COLORS.BACKGROUND;\n    this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n\n    // Draw game area border\n    this.ctx.strokeStyle = COLORS.BORDER;\n    this.ctx.strokeRect(\n      PADDING_LEFT,\n      PADDING_TOP,\n      this.gameAreaWidth,\n      this.gameAreaHeight,\n    );\n\n    // Draw lanes\n    for (let i = 0; i <= LANES; i++) {\n      const x = PADDING_LEFT + i * this.laneWidth;\n      this.ctx.beginPath();\n      this.ctx.moveTo(x, PADDING_TOP);\n      this.ctx.lineTo(x, GAME_HEIGHT - PADDING_BOTTOM);\n      this.ctx.stroke();\n    }\n\n    // Draw padding areas (slightly darker shade for visual separation)\n    this.ctx.fillStyle = COLORS.BACKGROUND;\n    // Top padding\n    this.ctx.fillRect(0, 0, GAME_WIDTH, PADDING_TOP);\n    // Bottom padding\n    this.ctx.fillRect(\n      0,\n      GAME_HEIGHT - PADDING_BOTTOM,\n      GAME_WIDTH,\n      PADDING_BOTTOM,\n    );\n    // Left padding\n    this.ctx.fillRect(0, PADDING_TOP, PADDING_LEFT, this.gameAreaHeight);\n    // Right padding\n    this.ctx.fillRect(\n      GAME_WIDTH - PADDING_RIGHT,\n      PADDING_TOP,\n      PADDING_RIGHT,\n      this.gameAreaHeight,\n    );\n\n    // Draw defense grid\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        this.defenseGrid[row][lane].draw(this.ctx);\n      }\n    }\n  }\n\n  update(deltaTime) {\n    if (this.gameState !== GAME_STATES.PLAYING) return;\n\n    const currentTime = performance.now();\n\n    // Update all defense spots\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        this.defenseGrid[row][lane].update(\n          currentTime,\n          this.meteors,\n          this.coins,\n        );\n      }\n    }\n\n    // Update meteors and check for lives\n    this.meteors = this.meteors.filter((meteor) => {\n      meteor.update(deltaTime);\n      if (meteor.y >= GAME_HEIGHT - PADDING_BOTTOM) {\n        this.lives--;\n        if (this.lives <= 0) {\n          this.gameState = GAME_STATES.GAME_OVER;\n        } else {\n          this.gameState = GAME_STATES.LIFE_LOST; // Show life lost screen\n        }\n        return false;\n      }\n      return true;\n    });\n\n    // Update coins\n    this.coins = this.coins.filter((coin) => {\n      return coin.update(currentTime);\n    });\n\n    // Update level manager\n    this.levelManager.update(currentTime, this.meteors);\n\n    // Check for level completion\n    if (this.levelManager.isLevelComplete(this.meteors)) {\n      if (this.levelManager.currentLevel >= LEVELS.length - 1) {\n        this.gameState = GAME_STATES.GAME_COMPLETE;\n      } else {\n        this.gameState = GAME_STATES.LEVEL_COMPLETE;\n      }\n    }\n  }\n\n  drawCurrency() {\n    const currencyY = GAME_HEIGHT - PADDING_BOTTOM + 15; // Position below game grid\n\n    this.ctx.fillStyle = COLORS.TEXT;\n    this.ctx.font = FONT.LARGE.full;\n    this.ctx.textAlign = \"center\";\n\n    // Draw currency centered below grid\n    this.ctx.fillText(`Currency: $${this.currency}`, GAME_WIDTH / 2, currencyY);\n\n    // Draw scores in top left corner\n    this.ctx.textAlign = \"left\";\n    this.ctx.fillText(\n      `Score: ${this.currentScore}`,\n      PADDING_LEFT / 3,\n      PADDING_TOP + 20,\n    );\n\n    // this.ctx.fillText(\n    //   `High Score: ${this.highScore}`,\n    //   PADDING_LEFT / 3,\n    //   (PADDING_TOP / 6) * 5,\n    // );\n  }\n\n  draw() {\n    this.drawBackground();\n\n    if (this.gameState === GAME_STATES.LOADING) {\n      this.drawLoadingScreen();\n    } else if (this.gameState === GAME_STATES.MENU) {\n      this.startButton.draw(this.ctx);\n      this.drawVersion();\n    } else if (this.gameState === GAME_STATES.PLAYING) {\n      // Draw currency and lives\n      this.drawCurrency();\n      this.drawLives();\n      this.drawProgressBar(this.ctx);\n\n      // Draw defense options\n      this.defenseOptions.forEach((option) => {\n        option.draw(\n          this.ctx,\n          this.selectedDefense && option.type.id === this.selectedDefense.id,\n          this.currency,\n        );\n      });\n\n      // Draw meteors\n      this.meteors.forEach((meteor) => meteor.draw(this.ctx));\n\n      // Draw coins\n      const currentTime = performance.now();\n      this.coins.forEach((coin) => coin.draw(this.ctx, currentTime));\n\n      this.drawVersion();\n    } else if (this.gameState === GAME_STATES.LIFE_LOST) {\n      // Draw the life lost screen\n      this.drawCurrency();\n      this.drawLives();\n      this.drawProgressBar(this.ctx);\n\n      // Add semi-transparent overlay\n      this.ctx.fillStyle = \"rgba(0, 0, 0, 0.7)\";\n      this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n\n      this.lifeLostText.draw(this.ctx);\n      this.continueButton.draw(this.ctx);\n\n      // Show remaining lives text\n      this.ctx.fillStyle = \"#FFF\";\n      this.ctx.font = FONT.LARGE.full;\n      this.ctx.textAlign = \"center\";\n      this.ctx.fillText(\n        `${this.lives} ${this.lives === 1 ? \"life\" : \"lives\"} remaining`,\n        GAME_WIDTH / 2,\n        GAME_HEIGHT / 2,\n      );\n\n      this.drawVersion();\n    } else if (this.gameState === GAME_STATES.LEVEL_COMPLETE) {\n      this.levelCompleteText.draw(this.ctx);\n      this.nextLevelButton.draw(this.ctx);\n      this.drawVersion();\n    } else if (this.gameState === GAME_STATES.GAME_COMPLETE) {\n      this.gameCompleteText.draw(this.ctx);\n      this.drawVersion();\n    } else if (this.gameState === GAME_STATES.GAME_OVER) {\n      this.gameOverText.draw(this.ctx);\n      this.retryButton.draw(this.ctx);\n\n      // Draw scores\n      this.ctx.fillStyle = COLORS.TEXT;\n      this.ctx.font = FONT.LARGE.full;\n      this.ctx.textAlign = \"center\";\n      this.ctx.fillText(\n        `Final Score: ${this.currentScore}`,\n        GAME_WIDTH / 2,\n        GAME_HEIGHT / 2 + 50,\n      );\n      this.ctx.fillText(\n        `High Score: ${this.highScore}`,\n        GAME_WIDTH / 2,\n        GAME_HEIGHT / 2 + 80,\n      );\n\n      this.drawVersion();\n    }\n  }\n\n  createDefenseOptions() {\n    const optionsAreaY = GAME_HEIGHT - PADDING_BOTTOM + 30; // Move down to make room for currency\n    const spacing = 20;\n    const totalWidth = (SPOT_SIZE + spacing) * DEFENSE_TYPES.length - spacing;\n    const startX = (GAME_WIDTH - totalWidth) / 2;\n\n    return DEFENSE_TYPES.map((type, index) => {\n      const x = startX + index * (SPOT_SIZE + spacing);\n      const y = optionsAreaY;\n      return new DefenseOption(type, x, y);\n    });\n  }\n\n  createDefenseGrid() {\n    const grid = [];\n\n    // Create 2D array for easier position reference\n    for (let row = 0; row < GRID_ROWS; row++) {\n      const rowArray = [];\n      for (let lane = 0; lane < LANES; lane++) {\n        const x = PADDING_LEFT + lane * LANE_WIDTH + LANE_WIDTH / 2;\n        const y =\n          GAME_HEIGHT - PADDING_BOTTOM - row * SPOT_SIZE - SPOT_SIZE / 2;\n        rowArray.push(new DefenseSpot(x, y, row, lane));\n      }\n      grid.push(rowArray);\n    }\n\n    return grid;\n  }\n\n  // Helper method to get spot at specific coordinates\n  getSpotAtPosition(x, y) {\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        const spot = this.defenseGrid[row][lane];\n        if (\n          x >= spot.x - SPOT_SIZE / 2 &&\n          x <= spot.x + SPOT_SIZE / 2 &&\n          y >= spot.y - SPOT_SIZE / 2 &&\n          y <= spot.y + SPOT_SIZE / 2\n        ) {\n          return spot;\n        }\n      }\n    }\n    return null;\n  }\n\n  drawProgressBar(ctx) {\n    // Draw progress bar background\n    const barWidth = GAME_WIDTH - 100; // Leave some padding\n    const barHeight = 20;\n    const x = 50; // Padding from left\n    const y = 20; // Padding from top\n\n    // Background\n    ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n    ctx.fillRect(x, y, barWidth, barHeight);\n\n    // Progress (inverted to show remaining time)\n    const progress = 1 - this.levelManager.getLevelProgress();\n    ctx.fillStyle = COLORS.PROGRESS_BAR;\n    ctx.fillRect(x, y, barWidth * progress, barHeight);\n\n    // Border\n    ctx.strokeStyle = COLORS.BORDER;\n    ctx.strokeRect(x, y, barWidth, barHeight);\n\n    // Level text\n    ctx.fillStyle = COLORS.TEXT;\n    ctx.font = FONT.LARGE.full;\n    ctx.textAlign = \"center\";\n    ctx.fillText(\n      `${LEVELS[this.levelManager.currentLevel].name}`,\n      GAME_WIDTH / 2,\n      y + barHeight + 16,\n    );\n\n    // Time remaining\n    const timeLeft = Math.ceil(\n      (LEVELS[this.levelManager.currentLevel].duration -\n        (performance.now() - this.levelManager.levelStartTime)) /\n        1000,\n    );\n    if (timeLeft > 0) {\n      ctx.font = FONT.SMALL.full;\n      ctx.fillText(`${timeLeft}s`, GAME_WIDTH - 30, y + barHeight / 2 + 5);\n    }\n  }\n\n  async loadAssets() {\n    const success = await this.assetLoader.loadAll();\n    if (success) {\n      this.gameState = GAME_STATES.MENU;\n    } else {\n      console.error(\"Failed to load assets\");\n      // You might want to show an error message to the user\n    }\n  }\n\n  drawLoadingScreen() {\n    const progress = this.assetLoader.getLoadingProgress();\n\n    // Draw loading bar\n    const barWidth = 200;\n    const barHeight = 20;\n    const x = (GAME_WIDTH - barWidth) / 2;\n    const y = GAME_HEIGHT / 2;\n\n    // Background\n    this.ctx.fillStyle = COLORS.BUTTON;\n    this.ctx.fillRect(x, y, barWidth, barHeight);\n\n    // Progress\n    this.ctx.fillStyle = \"#4CAF50\";\n    this.ctx.fillRect(x, y, barWidth * progress, barHeight);\n\n    // Border\n    this.ctx.strokeStyle = COLORS.TEXT;\n    this.ctx.strokeRect(x, y, barWidth, barHeight);\n\n    // Loading text\n    this.ctx.fillStyle = COLORS.TEXT;\n    this.ctx.font = FONT.LARGE.full;\n    this.ctx.textAlign = \"center\";\n    this.ctx.fillText(\"Loading...\", GAME_WIDTH / 2, y - 20);\n    this.ctx.fillText(`${Math.floor(progress * 100)}%`, GAME_WIDTH / 2, y + 40);\n  }\n\n  drawLives() {\n    const heartSize = 17;\n    const spacing = 5;\n    const startX = GAME_WIDTH - (heartSize + spacing) * INITIAL_LIVES;\n    const y = PADDING_TOP + 20;\n\n    this.ctx.fillStyle = COLORS.TEXT;\n    this.ctx.font = FONT.LARGE.full;\n    this.ctx.textAlign = \"right\";\n    this.ctx.fillText(\"Lives:\", startX - spacing * 2, y);\n\n    // Draw hearts\n    for (let i = 0; i < INITIAL_LIVES; i++) {\n      const x = startX + (heartSize + spacing) * i;\n\n      // Draw empty heart outline\n      this.ctx.strokeStyle = \"#FF0000\";\n      this.ctx.lineWidth = 2;\n      this.drawHeart(x, y - heartSize / 2, heartSize);\n\n      // Fill heart if life is remaining\n      if (i < this.lives) {\n        this.ctx.fillStyle = \"#FF0000\";\n        this.drawHeart(x, y - heartSize / 2, heartSize, true);\n      }\n    }\n  }\n\n  // Helper method to draw a heart\n  drawHeart(x, y, size, fill = false) {\n    const path = new Path2D();\n    path.moveTo(x, y + size / 4);\n    path.bezierCurveTo(x, y, x - size / 2, y, x - size / 2, y + size / 4);\n    path.bezierCurveTo(\n      x - size / 2,\n      y + size / 2,\n      x,\n      y + (size * 3) / 4,\n      x,\n      y + (size * 3) / 4,\n    );\n    path.bezierCurveTo(\n      x,\n      y + (size * 3) / 4,\n      x + size / 2,\n      y + size / 2,\n      x + size / 2,\n      y + size / 4,\n    );\n    path.bezierCurveTo(x + size / 2, y, x, y, x, y + size / 4);\n\n    if (fill) {\n      this.ctx.fill(path);\n    } else {\n      this.ctx.stroke(path);\n    }\n  }\n\n  // Add new method to continue playing\n  continuePlaying() {\n    this.gameState = GAME_STATES.PLAYING;\n    // Clear any remaining meteors to give player a fresh start\n    this.meteors = [];\n  }\n\n  // Add after constructor\n  loadHighScore() {\n    const saved = localStorage.getItem(STORAGE_KEY);\n    return saved ? parseInt(saved, 0) : 0;\n  }\n\n  saveHighScore() {\n    localStorage.setItem(STORAGE_KEY, this.highScore.toString());\n  }\n\n  // Add new method to draw version\n  drawVersion() {\n    this.ctx.fillStyle = COLORS.TEXT;\n    this.ctx.font = \"11px Arial\"; // Smaller font size\n    this.ctx.textAlign = \"left\";\n    this.ctx.fillText(`v${LEVEL_GEN_CONFIG.levelVersion}`, 5, GAME_HEIGHT - 5); // Position in bottom left corner\n  }\n}\n\n// Start the game when the page loads\nwindow.addEventListener(\"load\", () => {\n  game = new Game();\n});\n"],"names":["$35da740d59af89ba$var$game","$35da740d59af89ba$var$GRID_ROWS","Math","floor","$35da740d59af89ba$var$GAME_AREA_HEIGHT","$35da740d59af89ba$var$COLORS","BACKGROUND","TEXT","DEFENSE_OPTION_TEXT","DEFENSE_OPTION_TEXT_INACTIVE","BUTTON","BUTTON_TEXT","PROGRESS_BAR","BORDER","DEBUG_LINE","SELECTION","$35da740d59af89ba$var$LEVEL_GEN_CONFIG","levelVersion","baseDuration","durationIncrease","maxLevels","difficultyMultiplier","meteorWeights","start","small","medium","large","end","minSpawnGap","minSpawnGapEnd","maxSpawnGap","maxSpawnGapEnd","difficultyRamp","waveDuration","waveDurationEnd","waveGap","waveGapEnd","$35da740d59af89ba$var$LEVELS","$35da740d59af89ba$var$generateLevels","config","levels","diff","levelNum","duration","sqrt","meteors","currentTime","levelProgress","adjustedWaveDuration","waveEndTime","waveProgress","meteorType","$35da740d59af89ba$var$selectMeteorType","weights","random","lane","push","type","startTime","minGap","maxGap","name","sort","a","b","$35da740d59af89ba$var$GAME_STATES","LOADING","MENU","PLAYING","LIFE_LOST","LEVEL_COMPLETE","GAME_OVER","GAME_COMPLETE","$35da740d59af89ba$var$DEFENSE_TYPES","id","color","cost","damage","health","$35da740d59af89ba$var$METEOR_TYPES","speed","damageRate","rotateRate","wiggleRate","wiggleAmount","sizeMultiplier","x","y","coinReward","$35da740d59af89ba$var$FONT","SMALL","size","family","full","LARGE","$35da740d59af89ba$var$AssetLoader","constructor","images","Map","totalAssets","loadedAssets","loadAll","meteorPromises","$35da740d59af89ba$var$ASSETS","map","path","index","loadImage","Promise","all","error","console","key","src","resolve","reject","img","Image","onload","set","onerror","Error","getImage","get","getLoadingProgress","$35da740d59af89ba$var$Meteor","isBlocked","blockingDefense","baseRotation","wiggleRotation","wiggleOffset","baseX","$35da740d59af89ba$var$PADDING_LEFT","$35da740d59af89ba$var$GAME_AREA_WIDTH","$35da740d59af89ba$var$LANE_WIDTH","update","deltaTime","cos","block","defense","unblock","draw","ctx","wiggleX","sin","meteorImage","assetLoader","save","translate","rotate","height","$35da740d59af89ba$var$METEOR_SIZE","width","drawImage","restore","fillStyle","beginPath","arc","PI","fill","takeDamage","$35da740d59af89ba$var$Button","text","backgroundColor","textColor","fontSize","isClicked","clickX","clickY","fillRect","font","textAlign","textBaseline","fillText","$35da740d59af89ba$var$Projectile","checkCollision","meteor","meteorX","dx","dy","distance","isOffScreen","$35da740d59af89ba$var$Defense","maxHealth","projectiles","lastFireTime","fireRate","blockingMeteors","isEmpty","amount","coins","defenseRow","forEach","m","filter","projectile","i","length","$35da740d59af89ba$var$Coin","splice","isSelected","isInactive","strokeStyle","lineWidth","strokeRect","globalAlpha","max","$35da740d59af89ba$var$DefenseOption","currentCurrency","$35da740d59af89ba$var$SPOT_SIZE","$35da740d59af89ba$var$DefenseSpot","row","placeDefense","defenseType","removeDefense","value","lifetime","createTime","performance","now","hitRadius","angle","vx","vy","waveAmplitude","waveFrequency","waveOffset","baseY","time","age","remainingTime","coinX","coinY","gradient","createRadialGradient","addColorStop","stroke","$35da740d59af89ba$var$LevelManager","currentLevel","levelStartTime","remainingMeteors","allMeteorsSpawned","startLevel","levelIndex","levelTime","level","meteorData","shift","isLevelComplete","getLevelProgress","min","$35da740d59af89ba$var$STORAGE_KEY","$35da740d59af89ba$var$Game","canvas","document","getElementById","getContext","lastTime","gameState","initializeCanvas","window","addEventListener","loadAssets","requestAnimationFrame","timestamp","gameLoop","testMeteor","setupEventListeners","startButton","$35da740d59af89ba$var$GAME_WIDTH","$35da740d59af89ba$var$GAME_HEIGHT","retryButton","gameOverText","currency","defenseOptions","createDefenseOptions","selectedDefense","defenseGrid","createDefenseGrid","levelManager","nextLevelButton","levelCompleteText","gameCompleteText","continueButton","lifeLostText","lives","currentScore","highScore","loadHighScore","scale","viewportWidth","innerWidth","viewportHeight","innerHeight","viewportAspectRatio","style","e","rect","getBoundingClientRect","clientX","left","clientY","top","startGame","startNextLevel","coinCollected","coin","saveHighScore","option","log","spot","getSpotAtPosition","continuePlaying","clearRect","drawBackground","gameAreaWidth","gameAreaHeight","laneWidth","moveTo","lineTo","drawCurrency","$35da740d59af89ba$var$PADDING_TOP","drawLoadingScreen","drawVersion","drawLives","drawProgressBar","startX","grid","rowArray","progress","barWidth","timeLeft","ceil","heartSize","drawHeart","Path2D","bezierCurveTo","saved","localStorage","getItem","parseInt","setItem","toString"],"version":3,"file":"index.a4f6af30.js.map"}