{"mappings":"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","sources":["<anon>","src/index.js"],"sourcesContent":["var $35da740d59af89ba$exports = {};\n// Game constants\nconst $35da740d59af89ba$var$UNIT = 4;\nconst $35da740d59af89ba$var$GAME_WIDTH = $35da740d59af89ba$var$UNIT * 360; // Base width, will be scaled\nconst $35da740d59af89ba$var$GAME_HEIGHT = $35da740d59af89ba$var$UNIT * 640; // 16:9 ratio\nconst $35da740d59af89ba$var$LANES = 6;\nconst $35da740d59af89ba$var$PADDING_TOP = $35da740d59af89ba$var$UNIT * 40; // More space for score/level\nconst $35da740d59af89ba$var$PADDING_BOTTOM = $35da740d59af89ba$var$UNIT * 100; // More space for controls/UI\nconst $35da740d59af89ba$var$PADDING_LEFT = $35da740d59af89ba$var$UNIT * 40;\nconst $35da740d59af89ba$var$PADDING_RIGHT = $35da740d59af89ba$var$UNIT * 40;\nconst $35da740d59af89ba$var$TEXT_TOP = $35da740d59af89ba$var$PADDING_TOP + $35da740d59af89ba$var$UNIT * 20;\nconst $35da740d59af89ba$var$INITIAL_CURRENCY = 500;\nconst $35da740d59af89ba$var$INITIAL_LIVES = 3;\nconst $35da740d59af89ba$var$BUTTON_WIDTH = $35da740d59af89ba$var$GAME_WIDTH / 5 * 3;\nconst $35da740d59af89ba$var$BUTTON_HEIGHT = $35da740d59af89ba$var$BUTTON_WIDTH / 4;\nconst $35da740d59af89ba$var$BUTTON_X = $35da740d59af89ba$var$GAME_WIDTH / 2 - $35da740d59af89ba$var$BUTTON_WIDTH / 2;\nconst $35da740d59af89ba$var$BUTTON_Y = $35da740d59af89ba$var$GAME_HEIGHT / 2 - $35da740d59af89ba$var$BUTTON_HEIGHT / 2;\n// Game area calculations\nconst $35da740d59af89ba$var$GAME_AREA_WIDTH = $35da740d59af89ba$var$GAME_WIDTH - ($35da740d59af89ba$var$PADDING_LEFT + $35da740d59af89ba$var$PADDING_RIGHT);\nconst $35da740d59af89ba$var$GAME_AREA_HEIGHT = $35da740d59af89ba$var$GAME_HEIGHT - ($35da740d59af89ba$var$PADDING_TOP + $35da740d59af89ba$var$PADDING_BOTTOM);\nconst $35da740d59af89ba$var$LANE_WIDTH = $35da740d59af89ba$var$GAME_AREA_WIDTH / $35da740d59af89ba$var$LANES; // Width of each lane\nconst $35da740d59af89ba$var$SPOT_SIZE = $35da740d59af89ba$var$LANE_WIDTH; // Defense spots are same width as lanes\nconst $35da740d59af89ba$var$METEOR_SIZE = $35da740d59af89ba$var$LANE_WIDTH * 0.8; // Base size for meteors\nconst $35da740d59af89ba$var$GRID_ROWS = Math.floor($35da740d59af89ba$var$GAME_AREA_HEIGHT / $35da740d59af89ba$var$SPOT_SIZE);\nconst $35da740d59af89ba$var$LETTER_SPACING = \"0.05em\";\n// Add to game constants\nconst $35da740d59af89ba$var$DEBUG = false; // Toggle for development visualization\nconst $35da740d59af89ba$var$COLORS = {\n    BACKGROUND: \"#000\",\n    TEXT: \"#c0aa9a\",\n    DEFENSE_OPTION_TEXT: \"#c0aa9a\",\n    DEFENSE_OPTION_TEXT_INACTIVE: \"#f00\",\n    BUTTON: \"#5d908a\",\n    BUTTON_TEXT: \"#fff\",\n    PROGRESS_BAR: \"#c0aa9a\",\n    PROGRESS_BORDER: \"#c0aa9a\",\n    DEFENSE_BACKGROUND: \"rgba(255,255,255,0.2)\",\n    BORDER: \"#333\",\n    DEBUG_LINE: \"rgba(0,0,0,0.1)\",\n    GRID_LINE: \"rgba(0,0,0,0.25)\",\n    DEBUG_TEXT: \"#666\",\n    SELECTION: \"rgba(255,80,80,0.7)\",\n    HEART_FILL: \"#c0aa9a\",\n    HEART_STROKE: \"#c0aa9a\",\n    GAME_OVER_COLOR: \"#FF4444\",\n    SUCCESS_COLOR: \"#5c8e8b\"\n};\nconst $35da740d59af89ba$var$TEXTS = {\n    TITLE: window?.TXT?.TITLE || \"Meteor\\nDefense\",\n    SUB_TITLE: window?.TXT?.SUB_TITLE || \"Alles Gute im neuen Jahr!\",\n    INTRO: window?.TXT?.INTRO || \"\",\n    START_GAME: \"Start!\",\n    TRY_AGAIN: \"Neustart!\",\n    LIVES: \"Leben:\",\n    LEVEL: \"Level\",\n    SCORE: \"Punkte\",\n    COINS: \"Coins:\",\n    CURRENCY: \"Geld:\",\n    HIGH_SCORE: \"Rekord\",\n    LEVEL_COMPLETE: \"Geschafft!\",\n    GAME_OVER: \"Game Over!\",\n    GAME_COMPLETE: \"Alle\\nLevels\\ngeschafft!\",\n    LIFE_LOST: \"Leben\\nverloren!\",\n    CONTINUE: \"Weiter\",\n    NEXT_LEVEL: \"N\\xe4chstes Level\",\n    LIFE_REMAINING: (lives)=>`noch ${lives} ${lives === 1 ? \"Leben\" : \"Leben\"}`\n};\n// Level generation configuration options\nconst $35da740d59af89ba$var$LEVEL_GEN_CONFIG = {\n    levelVersion: \"1.8.4\",\n    baseDuration: 30000,\n    durationIncrease: 0,\n    maxLevels: 30,\n    difficultyMultiplier: 0.85,\n    // Meteor type weights (chance of spawning) at start and end of level\n    meteorWeights: {\n        start: {\n            small: 1,\n            medium: 0,\n            large: 0\n        },\n        end: {\n            small: 0,\n            medium: 0.35,\n            large: 0.65\n        }\n    },\n    // Spawn timing\n    minSpawnGap: 900,\n    minSpawnGapEnd: 200,\n    maxSpawnGap: 1300,\n    maxSpawnGapEnd: 200,\n    // Difficulty scaling\n    difficultyRamp: 1.25,\n    waveDuration: 6200,\n    waveDurationEnd: 1200,\n    waveGap: 3200,\n    waveGapEnd: 400\n};\nfunction $35da740d59af89ba$var$generateLevels(config = $35da740d59af89ba$var$LEVEL_GEN_CONFIG) {\n    const levels = [];\n    const diff = config.difficultyMultiplier;\n    for(let levelNum = 0; levelNum < config.maxLevels; levelNum++){\n        const duration = (config.baseDuration + config.durationIncrease * levelNum) / Math.sqrt(diff);\n        const meteors = [];\n        let currentTime = 1000;\n        const levelDifficulty = Math.pow(config.difficultyRamp, levelNum) * diff;\n        while(currentTime < duration - 2000){\n            const levelProgress = currentTime / duration;\n            const adjustedWaveDuration = $35da740d59af89ba$var$quadraticLerp(config.waveDuration / Math.sqrt(diff), config.waveDurationEnd / Math.sqrt(diff), levelProgress);\n            const waveEndTime = currentTime + adjustedWaveDuration;\n            while(currentTime < waveEndTime){\n                const waveProgress = (currentTime - (waveEndTime - adjustedWaveDuration)) / adjustedWaveDuration;\n                // Adjust weights based on difficulty (harder = more medium/large meteors)\n                const weights = {\n                    small: $35da740d59af89ba$var$quadraticLerp(config.meteorWeights.start.small, config.meteorWeights.end.small / diff, waveProgress),\n                    medium: $35da740d59af89ba$var$quadraticLerp(config.meteorWeights.start.medium, config.meteorWeights.end.medium * diff, waveProgress),\n                    large: $35da740d59af89ba$var$quadraticLerp(config.meteorWeights.start.large, config.meteorWeights.end.large * diff, waveProgress)\n                };\n                // Select meteor type based on weights\n                const meteorType = $35da740d59af89ba$var$selectMeteorType(weights);\n                // Select random lane\n                const lane = Math.floor(Math.random() * $35da740d59af89ba$var$LANES);\n                meteors.push({\n                    type: meteorType,\n                    lane: lane,\n                    startTime: Math.floor(currentTime)\n                });\n                // Adjust spawn gaps based on difficulty (harder = faster spawns)\n                const minGap = $35da740d59af89ba$var$quadraticLerp(config.minSpawnGap / diff, config.minSpawnGapEnd / diff, waveProgress);\n                const maxGap = $35da740d59af89ba$var$quadraticLerp(config.maxSpawnGap / diff, config.maxSpawnGapEnd / diff, waveProgress);\n                currentTime += Math.random() * (maxGap - minGap) + minGap;\n            }\n            const adjustedWaveGap = $35da740d59af89ba$var$quadraticLerp(config.waveGap / diff, config.waveGapEnd / diff, levelProgress);\n            currentTime += adjustedWaveGap;\n        }\n        levels.push({\n            name: `${$35da740d59af89ba$var$TEXTS.LEVEL} ${levelNum + 1}`,\n            duration: duration,\n            meteors: meteors.sort((a, b)=>a.startTime - b.startTime)\n        });\n    }\n    return levels;\n}\n// Helper function to linearly interpolate between two values\nfunction $35da740d59af89ba$var$lerp(start, end, progress) {\n    return start + (end - start) * progress;\n}\nfunction $35da740d59af89ba$var$quadraticLerp(start, end, progress) {\n    return start + (end - start) * progress * progress;\n}\n// Helper function to select meteor type based on weights\nfunction $35da740d59af89ba$var$selectMeteorType(weights) {\n    const total = weights.small + weights.medium + weights.large;\n    const random = Math.random() * total;\n    if (random < weights.small) return 0; // Small meteor\n    if (random < weights.small + weights.medium) return 1; // Medium meteor\n    return 2; // Large meteor\n}\n// Replace the existing LEVELS constant with generated levels\nconst $35da740d59af89ba$var$LEVELS = $35da740d59af89ba$var$generateLevels();\nconst $35da740d59af89ba$var$GAME_STATES = {\n    LOADING: \"loading\",\n    MENU: \"menu\",\n    PLAYING: \"playing\",\n    LIFE_LOST: \"lifeLost\",\n    LEVEL_COMPLETE: \"levelComplete\",\n    GAME_OVER: \"gameover\",\n    GAME_COMPLETE: \"gameComplete\"\n};\n// Add to game constants\nconst $35da740d59af89ba$var$DEFENSE_TYPES = [\n    {\n        id: 0,\n        name: \"Basic\",\n        color: \"#4CAF50\",\n        cost: 100,\n        damage: 10,\n        health: 100\n    },\n    {\n        id: 1,\n        name: \"Medium\",\n        color: \"#2196F3\",\n        cost: 140,\n        damage: 20,\n        health: 100\n    },\n    {\n        id: 2,\n        name: \"Strong\",\n        color: \"#9C27B0\",\n        cost: 180,\n        damage: 30,\n        health: 100\n    }\n];\n// Add to game constants\nconst $35da740d59af89ba$var$METEOR_TYPES = [\n    {\n        id: 0,\n        name: \"Small\",\n        color: \"#FF9999\",\n        health: 30,\n        speed: $35da740d59af89ba$var$UNIT * 0.05,\n        damageRate: 30,\n        rotateRate: 0.0005,\n        wiggleRate: 0.001,\n        wiggleAmount: 7,\n        sizeMultiplier: {\n            x: 1.0,\n            y: 1.0\n        },\n        coinReward: 20\n    },\n    {\n        id: 1,\n        name: \"Medium\",\n        color: \"#FF4444\",\n        health: 60,\n        speed: $35da740d59af89ba$var$UNIT * 0.035,\n        damageRate: 50,\n        rotateRate: 0,\n        wiggleRate: 0.03,\n        wiggleAmount: 0.03,\n        sizeMultiplier: {\n            x: 1,\n            y: 2\n        },\n        coinReward: 40\n    },\n    {\n        id: 2,\n        name: \"Large\",\n        color: \"#FF0000\",\n        health: 90,\n        speed: $35da740d59af89ba$var$UNIT * 0.05,\n        damageRate: 50,\n        rotateRate: 0,\n        wiggleRate: 0.03,\n        wiggleAmount: 0.03,\n        sizeMultiplier: {\n            x: 1,\n            y: 2\n        },\n        coinReward: 50\n    }\n];\n// Font definitions\nconst $35da740d59af89ba$var$FONT = {\n    TINY: {\n        size: $35da740d59af89ba$var$UNIT * 7,\n        family: \"GameText, Arial, sans-serif\",\n        get full () {\n            return `${this.size}px ${this.family}`;\n        }\n    },\n    SMALL: {\n        size: $35da740d59af89ba$var$UNIT * 13,\n        family: \"GameText, Arial, sans-serif\",\n        get full () {\n            return `${this.size}px ${this.family}`;\n        }\n    },\n    LARGE: {\n        size: $35da740d59af89ba$var$UNIT * 18,\n        family: \"GameText, Arial, sans-serif\",\n        get full () {\n            return `${this.size}px ${this.family}`;\n        }\n    },\n    TITLE: {\n        size: $35da740d59af89ba$var$UNIT * 42,\n        family: \"GameTitle, Arial, sans-serif\",\n        get full () {\n            return `${this.size}px ${this.family}`;\n        }\n    }\n};\n// Add at the top of the file, after other constants\nconst $35da740d59af89ba$var$ASSETS = {\n    METEORS: [\n        \"/assets/img/meteor-1.png\",\n        \"/assets/img/meteor-2.png\",\n        \"/assets/img/meteor-3.png\"\n    ],\n    DEFENSES: [\n        \"/assets/img/defense-1.png\",\n        \"/assets/img/defense-2.png\",\n        \"/assets/img/defense-3.png\"\n    ],\n    BACKGROUND: \"/assets/img/bg.png\",\n    FONTS: {\n        TITLE: \"/assets/fonts/pilowlava/Fonts/webfonts/Pilowlava-Regular.woff2\",\n        TEXT: \"/assets/fonts/space-mono/SpaceMono-Regular.ttf\"\n    }\n};\n// Add new AssetLoader class\nclass $35da740d59af89ba$var$AssetLoader {\n    constructor(){\n        this.images = new Map();\n        this.fonts = new Map();\n        this.totalAssets = 0;\n        this.loadedAssets = 0;\n    }\n    async loadAll() {\n        // Add font loading\n        const fontPromises = [\n            this.loadFont(\"GameText\", $35da740d59af89ba$var$ASSETS.FONTS.TEXT),\n            this.loadFont(\"GameTitle\", $35da740d59af89ba$var$ASSETS.FONTS.TITLE)\n        ];\n        const meteorPromises = $35da740d59af89ba$var$ASSETS.METEORS.map((path, index)=>this.loadImage(`meteor-${index}`, path));\n        const defensePromises = $35da740d59af89ba$var$ASSETS.DEFENSES.map((path, index)=>this.loadImage(`defense-${index}`, path));\n        const backgroundPromise = this.loadImage(\"background\", $35da740d59af89ba$var$ASSETS.BACKGROUND);\n        try {\n            await Promise.all([\n                ...fontPromises,\n                ...meteorPromises,\n                ...defensePromises,\n                backgroundPromise\n            ]);\n            return true;\n        } catch (error) {\n            console.error(\"Error loading assets:\", error);\n            return false;\n        }\n    }\n    loadImage(key, src) {\n        return new Promise((resolve, reject)=>{\n            const img = new Image();\n            this.totalAssets++;\n            img.onload = ()=>{\n                this.images.set(key, img);\n                this.loadedAssets++;\n                resolve(img);\n            };\n            img.onerror = ()=>{\n                reject(new Error(`Failed to load image: ${src}`));\n            };\n            img.src = src;\n        });\n    }\n    getImage(key) {\n        return this.images.get(key);\n    }\n    getLoadingProgress() {\n        return this.totalAssets ? this.loadedAssets / this.totalAssets : 0;\n    }\n    // Add new loadFont method\n    async loadFont(fontFamily, url) {\n        this.totalAssets++;\n        const fontFace = new FontFace(fontFamily, `url(${url})`);\n        try {\n            const loadedFont = await fontFace.load();\n            document.fonts.add(loadedFont);\n            this.fonts.set(fontFamily, loadedFont);\n            this.loadedAssets++;\n            return loadedFont;\n        } catch (error) {\n            console.error(`Failed to load font: ${url}`, error);\n            throw error;\n        }\n    }\n}\n// Add at the top of the file, after constants\nlet $35da740d59af89ba$var$game; // Global game instance\n// Test meteor\nclass $35da740d59af89ba$var$Meteor {\n    constructor(lane, type = $35da740d59af89ba$var$METEOR_TYPES[0]){\n        this.lane = lane;\n        this.type = type;\n        this.y = $35da740d59af89ba$var$PADDING_TOP;\n        this.health = type.health;\n        this.speed = type.speed;\n        this.isBlocked = false;\n        this.blockingDefense = null;\n        // Add rotation and wiggle properties\n        this.baseRotation = 0; // Base rotation from type.rotateRate\n        this.wiggleRotation = 0; // Additional rotation from wiggle motion\n        this.wiggleOffset = 0;\n        this.baseX = $35da740d59af89ba$var$PADDING_LEFT + lane * $35da740d59af89ba$var$LANE_WIDTH + $35da740d59af89ba$var$LANE_WIDTH / 2;\n    }\n    update(deltaTime) {\n        if (!this.isBlocked) {\n            this.y += this.speed * deltaTime;\n            // Update base rotation\n            this.baseRotation += this.type.rotateRate * deltaTime;\n            // Update wiggle and calculate wiggle-based rotation\n            this.wiggleOffset += this.type.wiggleRate * deltaTime;\n            // Calculate rotation based on wiggle movement (adjust 0.5 to control rotation intensity)\n            this.wiggleRotation = Math.cos(this.wiggleOffset) * this.type.wiggleAmount * 0.5;\n        }\n    }\n    block(defense) {\n        this.isBlocked = true;\n        this.blockingDefense = defense;\n    }\n    unblock() {\n        this.isBlocked = false;\n        this.blockingDefense = null;\n    }\n    draw(ctx) {\n        // Calculate wiggled x position\n        const wiggleX = this.baseX + Math.sin(this.wiggleOffset) * this.type.wiggleAmount;\n        // Get the corresponding meteor image\n        const meteorImage = $35da740d59af89ba$var$game?.assetLoader.getImage(`meteor-${this.type.id}`);\n        if (meteorImage) {\n            ctx.save(); // Save current context state\n            // Translate to meteor position\n            ctx.translate(wiggleX, this.y);\n            // Apply combined rotation (base rotation + wiggle-based rotation)\n            ctx.rotate(this.baseRotation + this.wiggleRotation);\n            // Calculate size using multiplier\n            const height = $35da740d59af89ba$var$METEOR_SIZE * this.type.sizeMultiplier.y;\n            const width = $35da740d59af89ba$var$METEOR_SIZE * this.type.sizeMultiplier.x;\n            // Draw the image centered at the translated position\n            ctx.drawImage(meteorImage, -width / 2, -height / 2, width, height);\n            ctx.restore(); // Restore context state\n        } else {\n            // Fallback to original circle drawing if image isn't loaded\n            ctx.fillStyle = this.type.color;\n            ctx.beginPath();\n            ctx.arc(wiggleX, this.y, 10, 0, Math.PI * 2);\n            ctx.fill();\n        }\n        if ($35da740d59af89ba$var$DEBUG) {\n            // Draw collision circle\n            ctx.strokeStyle = \"rgba(255,0,0,0.5)\";\n            ctx.beginPath();\n            ctx.arc(wiggleX, this.y, 10, 0, Math.PI * 2);\n            ctx.stroke();\n            // Draw health\n            ctx.fillStyle = \"white\";\n            ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n            ctx.textAlign = \"center\";\n            ctx.fillText(`${this.health}`, wiggleX, this.y);\n        }\n    }\n    takeDamage(damage) {\n        this.health -= damage;\n        return this.health <= 0;\n    }\n}\n// Add to existing constants\nclass $35da740d59af89ba$var$Button {\n    constructor(text, backgroundColor = $35da740d59af89ba$var$COLORS.BUTTON, textColor = $35da740d59af89ba$var$COLORS.BUTTON_TEXT, fontSize = 16){\n        this.x = $35da740d59af89ba$var$BUTTON_X;\n        this.y = $35da740d59af89ba$var$BUTTON_Y;\n        this.width = $35da740d59af89ba$var$BUTTON_WIDTH;\n        this.height = $35da740d59af89ba$var$BUTTON_HEIGHT;\n        this.text = text;\n        this.backgroundColor = backgroundColor;\n        this.textColor = textColor;\n        this.fontSize = fontSize;\n    }\n    isClicked(clickX, clickY) {\n        return clickX >= this.x && clickX <= this.x + this.width && clickY >= this.y && clickY <= this.y + this.height;\n    }\n    draw(ctx) {\n        // Draw button background\n        ctx.fillStyle = this.backgroundColor;\n        ctx.fillRect(this.x, this.y, this.width, this.height);\n        // Draw button text\n        ctx.fillStyle = this.textColor;\n        ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.letterSpacing = $35da740d59af89ba$var$LETTER_SPACING;\n        ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height * 0.52);\n        ctx.letterSpacing = \"0px\";\n    }\n}\nclass $35da740d59af89ba$var$Projectile {\n    constructor(x, y, damage){\n        this.x = x;\n        this.y = y;\n        this.speed = $35da740d59af89ba$var$UNIT * 0.3;\n        this.damage = damage;\n        this.size = $35da740d59af89ba$var$UNIT * 4;\n    }\n    update(deltaTime) {\n        this.y -= this.speed * deltaTime;\n    }\n    draw(ctx) {\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n        ctx.fill();\n        if ($35da740d59af89ba$var$DEBUG) {\n            // Draw collision circle\n            ctx.strokeStyle = \"rgba(255,255,0,0.3)\";\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n            ctx.stroke();\n        }\n    }\n    checkCollision(meteor) {\n        const meteorX = $35da740d59af89ba$var$PADDING_LEFT + meteor.lane * $35da740d59af89ba$var$LANE_WIDTH + $35da740d59af89ba$var$LANE_WIDTH / 2;\n        const dx = this.x - meteorX;\n        const dy = this.y - meteor.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        return distance < this.size + 10 * $35da740d59af89ba$var$UNIT; // 10 is meteor radius\n    }\n    isOffScreen() {\n        return this.y < $35da740d59af89ba$var$PADDING_TOP;\n    }\n}\n// Add to game constants\nclass $35da740d59af89ba$var$Defense {\n    constructor(type = null){\n        this.type = type;\n        this.health = type ? type.health : 0;\n        this.maxHealth = type ? type.health : 0;\n        this.projectiles = [];\n        this.lastFireTime = 0;\n        this.fireRate = 1000;\n        this.blockingMeteors = []; // Add array to track blocked meteors\n    }\n    isEmpty() {\n        return this.type === null;\n    }\n    takeDamage(amount) {\n        this.health -= amount;\n        return this.health <= 0;\n    }\n    update(currentTime, x, y, meteors, coins) {\n        if (!this.isEmpty()) {\n            // Fire projectile if enough time has passed\n            if (currentTime - this.lastFireTime > this.fireRate) {\n                this.projectiles.push(new $35da740d59af89ba$var$Projectile(x, y, this.type.damage));\n                this.lastFireTime = currentTime;\n            }\n            // Check for meteor collisions with this defense\n            const defenseRow = Math.floor((y - $35da740d59af89ba$var$PADDING_TOP) / $35da740d59af89ba$var$SPOT_SIZE);\n            meteors.forEach((meteor)=>{\n                const meteorRow = Math.floor((meteor.y - $35da740d59af89ba$var$PADDING_TOP) / $35da740d59af89ba$var$SPOT_SIZE);\n                if (meteorRow === defenseRow && meteor.lane === Math.floor((x - $35da740d59af89ba$var$PADDING_LEFT) / $35da740d59af89ba$var$LANE_WIDTH)) {\n                    // Block meteor if not already blocked\n                    if (!meteor.isBlocked) {\n                        meteor.block(this);\n                        this.blockingMeteors.push(meteor); // Track this meteor\n                    }\n                    // Take damage from meteor using meteor's damage rate\n                    if (meteor.blockingDefense === this) {\n                        const destroyed = this.takeDamage(meteor.type.damageRate / 60);\n                        if (destroyed) {\n                            // Unblock all meteors this defense was blocking\n                            this.blockingMeteors.forEach((m)=>m.unblock());\n                            this.blockingMeteors = [];\n                            this.type = null; // Reset defense when destroyed\n                            this.health = 0;\n                            this.maxHealth = 0;\n                        }\n                    }\n                }\n            });\n            // Update existing projectiles and check collisions\n            this.projectiles = this.projectiles.filter((projectile)=>{\n                projectile.update(16);\n                // Check for collisions with any meteor\n                for(let i = 0; i < meteors.length; i++){\n                    const meteor = meteors[i];\n                    if (projectile.checkCollision(meteor)) {\n                        const destroyed = meteor.takeDamage(projectile.damage);\n                        if (destroyed) {\n                            // Spawn coin at meteor's position with meteor's reward value\n                            const meteorX = $35da740d59af89ba$var$PADDING_LEFT + meteor.lane * $35da740d59af89ba$var$LANE_WIDTH + $35da740d59af89ba$var$LANE_WIDTH / 2;\n                            coins.push(new $35da740d59af89ba$var$Coin(meteorX, meteor.y, meteor.type.coinReward));\n                            meteors.splice(i, 1);\n                        }\n                        return false; // Remove projectile\n                    }\n                }\n                return !projectile.isOffScreen();\n            });\n        }\n    }\n    draw(ctx, x, y, size, isSelected = false, isInactive = false) {\n        // Draw spot outline\n        ctx.strokeStyle = this.isEmpty() ? $35da740d59af89ba$var$COLORS.GRID_LINE : \"#888\";\n        ctx.lineWidth = $35da740d59af89ba$var$UNIT * 1;\n        ctx.strokeRect(x - size / 2, y - size / 2, size, size);\n        ctx.fillStyle = $35da740d59af89ba$var$COLORS.DEFENSE_BACKGROUND; // Add black background to prevent any transparency\n        ctx.fillRect(x - size / 2, y - size / 2, size, size);\n        if (!this.isEmpty()) {\n            if ($35da740d59af89ba$var$game?.assetLoader) {\n                // Draw defense image\n                const defenseImage = $35da740d59af89ba$var$game.assetLoader.getImage(`defense-${this.type.id}`);\n                if (defenseImage) {\n                    if (isInactive) ctx.globalAlpha = 0.5;\n                    else ctx.globalAlpha = Math.max(0.3, this.health / this.maxHealth);\n                    ctx.drawImage(defenseImage, x - size / 2, y - size / 2, size, size);\n                    ctx.globalAlpha = 1.0;\n                }\n            }\n            // Draw projectiles\n            this.projectiles.forEach((projectile)=>projectile.draw(ctx));\n            if ($35da740d59af89ba$var$DEBUG) {\n                // Draw health bar\n                ctx.fillStyle = $35da740d59af89ba$var$COLORS.TEXT;\n                ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n                ctx.textAlign = \"center\";\n                ctx.fillText(`${Math.floor(this.health / this.maxHealth * 100)}%`, x, y);\n            }\n            // Draw selection highlight\n            if (isSelected) {\n                ctx.strokeStyle = $35da740d59af89ba$var$COLORS.SELECTION;\n                ctx.lineWidth = $35da740d59af89ba$var$UNIT * 4;\n                ctx.strokeRect(x - size / 2, y - size / 2, size, size);\n            }\n        }\n    }\n}\nclass $35da740d59af89ba$var$DefenseOption {\n    constructor(type, x, y){\n        this.type = type;\n        this.x = x;\n        this.y = y;\n        this.defense = new $35da740d59af89ba$var$Defense(type);\n    }\n    draw(ctx, isSelected = false, currentCurrency = 0) {\n        const isInactive = currentCurrency < this.type.cost;\n        // Draw defense using Defense class\n        this.defense.draw(ctx, this.x + $35da740d59af89ba$var$SPOT_SIZE / 2, this.y + $35da740d59af89ba$var$SPOT_SIZE / 2, $35da740d59af89ba$var$SPOT_SIZE, isSelected, isInactive);\n        // Draw cost (red if can't afford)\n        ctx.fillStyle = isInactive ? $35da740d59af89ba$var$COLORS.DEFENSE_OPTION_TEXT_INACTIVE : $35da740d59af89ba$var$COLORS.DEFENSE_OPTION_TEXT;\n        ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n        ctx.textAlign = \"center\";\n        ctx.letterSpacing = $35da740d59af89ba$var$LETTER_SPACING;\n        ctx.fillText(`$${this.type.cost}`, this.x + $35da740d59af89ba$var$SPOT_SIZE / 2, this.y + $35da740d59af89ba$var$SPOT_SIZE + $35da740d59af89ba$var$UNIT * 15);\n        ctx.letterSpacing = \"0px\";\n    }\n    isClicked(clickX, clickY) {\n        return clickX >= this.x && clickX <= this.x + $35da740d59af89ba$var$SPOT_SIZE && clickY >= this.y && clickY <= this.y + $35da740d59af89ba$var$SPOT_SIZE;\n    }\n}\nclass $35da740d59af89ba$var$DefenseSpot {\n    constructor(x, y, row, lane){\n        this.x = x;\n        this.y = y;\n        this.row = row;\n        this.lane = lane;\n        this.defense = new $35da740d59af89ba$var$Defense();\n    }\n    isEmpty() {\n        return this.defense.isEmpty();\n    }\n    placeDefense(defenseType) {\n        if (this.isEmpty()) {\n            this.defense = new $35da740d59af89ba$var$Defense(defenseType);\n            return true;\n        }\n        return false;\n    }\n    removeDefense() {\n        this.defense = new $35da740d59af89ba$var$Defense(); // Reset to empty defense\n    }\n    draw(ctx) {\n        // Draw defense (or empty spot)\n        this.defense.draw(ctx, this.x, this.y, $35da740d59af89ba$var$SPOT_SIZE);\n        if ($35da740d59af89ba$var$DEBUG) {\n            // Draw coordinates for debugging\n            ctx.fillStyle = $35da740d59af89ba$var$COLORS.DEBUG_TEXT;\n            ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n            ctx.textAlign = \"center\";\n            ctx.fillText(`${this.lane},${this.row}`, this.x, this.y);\n        }\n    }\n    update(currentTime, meteors, coins) {\n        this.defense.update(currentTime, this.x, this.y, meteors, coins);\n    }\n}\nclass $35da740d59af89ba$var$Coin {\n    constructor(x, y, value = 10){\n        this.x = x;\n        this.y = y;\n        this.value = value;\n        this.lifetime = 5000; // 5 seconds lifetime\n        this.createTime = performance.now();\n        this.hitRadius = $35da740d59af89ba$var$UNIT * 30; // Bigger radius for hit detection\n        // Size based on value\n        this.size = $35da740d59af89ba$var$UNIT * (8 + (value - 10) / 10 * 2); // Increases by 2 pixels for each 10 value\n        // Base movement\n        const angle = Math.random() * Math.PI * 2;\n        const speed = $35da740d59af89ba$var$UNIT * (0.3 + Math.random() * 0.1);\n        this.vx = Math.cos(angle) * speed;\n        this.vy = Math.sin(angle) * speed;\n        // Wave motion parameters\n        this.waveAmplitude = $35da740d59af89ba$var$UNIT * (2.2 + Math.random() * 0.2);\n        this.waveFrequency = 0.005 + Math.random() * 0.001;\n        this.waveOffset = Math.random() * Math.PI * 2;\n        this.baseX = x;\n        this.baseY = y;\n        this.time = 0;\n    }\n    draw(ctx, currentTime) {\n        const age = currentTime - this.createTime;\n        const remainingTime = this.lifetime - age;\n        // Start blinking when less than 1.5 seconds remaining\n        if (remainingTime < 1500) {\n            const blinkRate = 100 + remainingTime / 1500 * 400;\n            if (Math.floor(currentTime / blinkRate) % 2 === 0) return;\n        }\n        if ($35da740d59af89ba$var$DEBUG) {\n            // Draw hit area\n            ctx.strokeStyle = \"rgba(255, 80, 80, 0.6)\";\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.hitRadius, 0, Math.PI * 2);\n            ctx.stroke();\n        }\n        const coinX = this.x + Math.sin(this.time * this.waveFrequency + this.waveOffset) * this.waveAmplitude;\n        const coinY = this.y + Math.cos(this.time * this.waveFrequency + this.waveOffset) * this.waveAmplitude;\n        // Draw coin with gradient for more depth\n        const gradient = ctx.createRadialGradient(coinX - this.size / 3, coinY - this.size / 3, 0, coinX, coinY, this.size);\n        gradient.addColorStop(0, \"#FFD700\"); // Bright gold\n        gradient.addColorStop(1, \"#DAA520\"); // Darker gold\n        ctx.fillStyle = gradient;\n        ctx.beginPath();\n        ctx.arc(coinX, coinY, this.size, 0, Math.PI * 2);\n        ctx.fill();\n        // Add coin border\n        ctx.strokeStyle = \"#B8860B\"; // Dark gold\n        ctx.lineWidth = $35da740d59af89ba$var$UNIT * 1;\n        ctx.stroke();\n        // Draw value\n        ctx.fillStyle = \"black\";\n        ctx.globalAlpha = 0.7;\n        ctx.font = `${Math.max(10, this.size)}px ${$35da740d59af89ba$var$FONT.SMALL.family}`;\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.letterSpacing = $35da740d59af89ba$var$LETTER_SPACING;\n        ctx.fillText(`${this.value}`, coinX, coinY + this.size / 8);\n        ctx.letterSpacing = \"0px\";\n        ctx.globalAlpha = 1;\n    }\n    update(currentTime) {\n        this.time += 16; // Increment time (assuming ~60fps)\n        // Update base position with velocity\n        this.baseX += this.vx;\n        this.baseY += this.vy;\n        // Add wave motion\n        this.x = this.baseX + Math.sin(this.time * this.waveFrequency + this.waveOffset) * this.waveAmplitude;\n        this.y = this.baseY + Math.cos(this.time * this.waveFrequency + this.waveOffset) * this.waveAmplitude;\n        // Calculate remaining lifetime\n        const age = currentTime - this.createTime;\n        return age < this.lifetime;\n    }\n    isClicked(clickX, clickY) {\n        const dx = clickX - this.x;\n        const dy = clickY - this.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        return distance < this.hitRadius;\n    }\n}\nclass $35da740d59af89ba$var$LevelManager {\n    constructor(){\n        this.currentLevel = 0;\n        this.levelStartTime = 0;\n        this.remainingMeteors = [];\n        this.allMeteorsSpawned = false;\n        this.pauseStartTime = 0; // Add new property to track pause time\n        this.totalPausedTime = 0; // Add new property to track total paused time\n    }\n    startLevel(levelIndex) {\n        this.currentLevel = levelIndex;\n        this.levelStartTime = performance.now();\n        this.remainingMeteors = [\n            ...$35da740d59af89ba$var$LEVELS[levelIndex].meteors\n        ];\n        this.allMeteorsSpawned = false;\n        this.totalPausedTime = 0; // Reset paused time when starting new level\n    }\n    update(currentTime, meteors) {\n        if (this.currentLevel >= $35da740d59af89ba$var$LEVELS.length) return false;\n        // Adjust level time by subtracting total paused time\n        const levelTime = currentTime - this.levelStartTime - this.totalPausedTime;\n        const level = $35da740d59af89ba$var$LEVELS[this.currentLevel];\n        // Check if level time is exceeded\n        if (levelTime >= level.duration) {\n            this.allMeteorsSpawned = true;\n            return false;\n        }\n        // Spawn meteors that are due\n        while(this.remainingMeteors.length > 0 && levelTime >= this.remainingMeteors[0].startTime){\n            const meteorData = this.remainingMeteors.shift();\n            meteors.push(new $35da740d59af89ba$var$Meteor(meteorData.lane, $35da740d59af89ba$var$METEOR_TYPES[meteorData.type]));\n        }\n        // Check if all meteors have been spawned\n        if (this.remainingMeteors.length === 0) this.allMeteorsSpawned = true;\n        return true;\n    }\n    isLevelComplete(meteors) {\n        return this.allMeteorsSpawned && meteors.length === 0;\n    }\n    getLevelProgress() {\n        const currentTime = performance.now();\n        let adjustedTime = currentTime - this.levelStartTime - this.totalPausedTime;\n        // If currently paused, also subtract the current pause duration\n        if (this.pauseStartTime) adjustedTime -= currentTime - this.pauseStartTime;\n        const duration = $35da740d59af89ba$var$LEVELS[this.currentLevel].duration;\n        return Math.min(adjustedTime / duration, 1);\n    }\n    // Add new methods to handle pausing\n    pause() {\n        if (!this.pauseStartTime) this.pauseStartTime = performance.now();\n    }\n    resume() {\n        if (this.pauseStartTime) {\n            this.totalPausedTime += performance.now() - this.pauseStartTime;\n            this.pauseStartTime = 0;\n        }\n    }\n}\nconst $35da740d59af89ba$var$STORAGE_KEY = \"meteorDefenseHighScore\";\n// Add after other classes, before Game class\nclass $35da740d59af89ba$var$TextRenderer {\n    static drawTitle(ctx, { title: title = \"\", color: color = $35da740d59af89ba$var$COLORS.TEXT, subtitle: subtitle = null, copy: copy = null }) {\n        const x = $35da740d59af89ba$var$GAME_WIDTH / 2;\n        const baseY = $35da740d59af89ba$var$GAME_HEIGHT / 4;\n        const titleLineHeight = $35da740d59af89ba$var$FONT.TITLE.size * 1.2;\n        const subtitleLineHeight = $35da740d59af89ba$var$FONT.LARGE.size * 1.3;\n        const copyLineHeight = $35da740d59af89ba$var$FONT.SMALL.size * 1.35;\n        // Split title into lines\n        const titleLines = title.split(\"\\n\");\n        // Calculate starting Y position that grows upward\n        const titleStartY = baseY - (titleLines.length - 1) * titleLineHeight;\n        // Draw main title lines\n        ctx.fillStyle = color;\n        ctx.font = $35da740d59af89ba$var$FONT.TITLE.full;\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        titleLines.forEach((line, index)=>{\n            ctx.fillText(line, x, titleStartY + index * titleLineHeight);\n        });\n        // Draw subtitle if provided\n        if (subtitle) {\n            ctx.fillStyle = $35da740d59af89ba$var$COLORS.TEXT;\n            ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n            ctx.letterSpacing = $35da740d59af89ba$var$LETTER_SPACING;\n            // Split subtitle into lines and render each one\n            const subtitleLines = subtitle.split(\"\\n\");\n            subtitleLines.forEach((line, index)=>{\n                ctx.fillText(line, x, baseY + titleLineHeight + index * subtitleLineHeight);\n            });\n            ctx.letterSpacing = \"0px\";\n        }\n        if (copy) {\n            ctx.fillStyle = $35da740d59af89ba$var$COLORS.TEXT;\n            ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n            ctx.letterSpacing = $35da740d59af89ba$var$LETTER_SPACING;\n            // Split copy into lines and render each one\n            const copyLines = copy.split(\"\\n\");\n            copyLines.forEach((line, index)=>{\n                ctx.fillText(line, x, $35da740d59af89ba$var$GAME_HEIGHT / 5 * 3 + index * copyLineHeight);\n            });\n            ctx.letterSpacing = \"0px\";\n        }\n    }\n}\nclass $35da740d59af89ba$var$Game {\n    constructor(){\n        this.canvas = document.getElementById(\"canvas\");\n        this.ctx = this.canvas.getContext(\"2d\");\n        this.lastTime = 0;\n        this.meteors = [];\n        this.coins = [];\n        this.assetLoader = new $35da740d59af89ba$var$AssetLoader();\n        this.gameState = $35da740d59af89ba$var$GAME_STATES.LOADING;\n        // Initialize game dimensions and scaling\n        this.initializeCanvas();\n        window.addEventListener(\"resize\", ()=>this.initializeCanvas());\n        // Initialize other game properties\n        this.initializeGameProperties();\n        // Start game loop immediately\n        requestAnimationFrame((timestamp)=>this.gameLoop(timestamp));\n        // Load assets separately\n        this.loadAssets();\n    }\n    initializeCanvas() {\n        // Get dynamic viewport height (accounts for mobile browser UI elements)\n        const viewportWidth = window.innerWidth;\n        const viewportHeight = window.innerHeight;\n        // Calculate maximum possible game size that maintains aspect ratio\n        const gameAspectRatio = $35da740d59af89ba$var$GAME_WIDTH / $35da740d59af89ba$var$GAME_HEIGHT;\n        const viewportAspectRatio = viewportWidth / viewportHeight;\n        let scale;\n        if (viewportAspectRatio > gameAspectRatio) // Viewport is wider than game - fit to height\n        scale = viewportHeight / $35da740d59af89ba$var$GAME_HEIGHT;\n        else // Viewport is taller than game - fit to width\n        scale = viewportWidth / $35da740d59af89ba$var$GAME_WIDTH;\n        // Ensure the scaled size doesn't exceed viewport\n        scale = Math.min(scale, 1);\n        this.canvas.width = $35da740d59af89ba$var$GAME_WIDTH;\n        this.canvas.height = $35da740d59af89ba$var$GAME_HEIGHT;\n        // Apply scale through CSS\n        this.canvas.style.width = `${$35da740d59af89ba$var$GAME_WIDTH * scale}px`;\n        this.canvas.style.height = `${$35da740d59af89ba$var$GAME_HEIGHT * scale}px`;\n    }\n    setupEventListeners() {\n        this.canvas.addEventListener(\"click\", (e)=>{\n            const rect = this.canvas.getBoundingClientRect();\n            const scale = this.canvas.width / rect.width;\n            const x = (e.clientX - rect.left) * scale;\n            const y = (e.clientY - rect.top) * scale;\n            if (this.gameState === $35da740d59af89ba$var$GAME_STATES.MENU) {\n                if (this.startButton.isClicked(x, y)) this.startGame();\n            } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.GAME_OVER) {\n                if (this.retryButton.isClicked(x, y)) this.startGame();\n            } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.LEVEL_COMPLETE) {\n                if (this.nextLevelButton.isClicked(x, y)) this.startNextLevel();\n            } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.PLAYING) {\n                // Check for coin collection first\n                let coinCollected = false;\n                for(let i = this.coins.length - 1; i >= 0; i--){\n                    const coin = this.coins[i];\n                    if (coin.isClicked(x, y)) {\n                        this.currency += coin.value;\n                        this.currentScore += coin.value; // Add to current score\n                        this.coins.splice(i, 1);\n                        coinCollected = true;\n                        break;\n                    }\n                }\n                // Only check defense interactions if we didn't collect a coin\n                if (!coinCollected) {\n                    // Check if defense option was clicked\n                    this.defenseOptions.forEach((option)=>{\n                        if (option.isClicked(x, y)) {\n                            if (this.selectedDefense === option.type) {\n                                // Deselect if clicking the same defense\n                                this.selectedDefense = null;\n                                console.log(\"Defense deselected\");\n                            } else if (this.currency >= option.type.cost) {\n                                this.selectedDefense = option.type;\n                                console.log(`Selected ${option.type.name} defense`);\n                            } else console.log(\"Not enough currency!\");\n                        }\n                    });\n                    // Check if grid spot was clicked\n                    if (this.selectedDefense) {\n                        const spot = this.getSpotAtPosition(x, y);\n                        if (spot && spot.isEmpty()) {\n                            if (this.currency >= this.selectedDefense.cost) {\n                                spot.placeDefense(this.selectedDefense);\n                                this.currency -= this.selectedDefense.cost;\n                                this.selectedDefense = null; // Reset selection after placing defense\n                            }\n                        }\n                    }\n                }\n            } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.LIFE_LOST) {\n                if (this.continueButton.isClicked(x, y)) {\n                    this.continuePlaying();\n                    this.currency += 120;\n                }\n            }\n        });\n    }\n    startGame() {\n        this.gameState = $35da740d59af89ba$var$GAME_STATES.PLAYING;\n        this.meteors = [];\n        this.coins = [];\n        this.currency = $35da740d59af89ba$var$INITIAL_CURRENCY;\n        this.selectedDefense = null;\n        this.lives = $35da740d59af89ba$var$INITIAL_LIVES; // Reset lives when starting new game\n        this.currentScore = 0; // Reset current score\n        this.levelManager.startLevel(0);\n        // Reset defense grid\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++)this.defenseGrid[row][lane].removeDefense();\n    }\n    startNextLevel() {\n        this.meteors = [];\n        this.coins = [];\n        this.currency = $35da740d59af89ba$var$INITIAL_CURRENCY;\n        this.selectedDefense = null;\n        // Reset defense grid\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++)this.defenseGrid[row][lane].removeDefense();\n        this.levelManager.startLevel(this.levelManager.currentLevel + 1);\n        this.gameState = $35da740d59af89ba$var$GAME_STATES.PLAYING;\n    }\n    gameLoop(timestamp) {\n        // Calculate delta time\n        const deltaTime = timestamp - this.lastTime;\n        this.lastTime = timestamp;\n        // Clear canvas\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        // Update and draw game elements\n        this.update(deltaTime);\n        this.draw();\n        // Continue game loop\n        requestAnimationFrame((timestamp)=>this.gameLoop(timestamp));\n    }\n    drawBackground() {\n        if ($35da740d59af89ba$var$DEBUG) {\n            this.ctx.fillStyle = \"#666\";\n            this.ctx.fillRect(0, 0, $35da740d59af89ba$var$GAME_WIDTH, $35da740d59af89ba$var$GAME_HEIGHT);\n            return;\n        }\n        // Draw background image\n        const bgImage = this.assetLoader.getImage(\"background\");\n        if (bgImage) {\n            // Draw the image covering the full canvas, before anything else\n            this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.BACKGROUND; // Add black background to prevent any transparency\n            this.ctx.fillRect(0, 0, $35da740d59af89ba$var$GAME_WIDTH, $35da740d59af89ba$var$GAME_HEIGHT);\n            this.ctx.drawImage(bgImage, 0, 0, $35da740d59af89ba$var$GAME_WIDTH, $35da740d59af89ba$var$GAME_HEIGHT);\n        } else {\n            // Fallback to solid color if image not loaded\n            this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.BACKGROUND;\n            this.ctx.fillRect(0, 0, $35da740d59af89ba$var$GAME_WIDTH, $35da740d59af89ba$var$GAME_HEIGHT);\n        }\n    }\n    drawDefenseGrid() {\n        // Draw defense grid\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++)this.defenseGrid[row][lane].draw(this.ctx);\n    }\n    update(deltaTime) {\n        if (this.gameState === $35da740d59af89ba$var$GAME_STATES.PLAYING) {\n            const currentTime = performance.now();\n            // Update all defense spots\n            for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++)this.defenseGrid[row][lane].update(currentTime, this.meteors, this.coins);\n            // Update meteors and check for lives\n            this.meteors = this.meteors.filter((meteor)=>{\n                meteor.update(deltaTime);\n                if (meteor.y >= $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM) {\n                    this.lives--;\n                    if (this.lives <= 0) {\n                        // Update high score when game ends\n                        if (this.currentScore > this.highScore) {\n                            this.highScore = this.currentScore;\n                            this.saveHighScore();\n                        }\n                        // Update level high score when game ends\n                        if (this.levelManager.currentLevel > this.levelHighScore) {\n                            this.levelHighScore = this.levelManager.currentLevel;\n                            this.saveLevelHighScore();\n                        }\n                        this.gameState = $35da740d59af89ba$var$GAME_STATES.GAME_OVER;\n                    } else this.gameState = $35da740d59af89ba$var$GAME_STATES.LIFE_LOST;\n                    return false;\n                }\n                return true;\n            });\n            // Update coins\n            this.coins = this.coins.filter((coin)=>{\n                return coin.update(currentTime);\n            });\n            // Update level manager\n            this.levelManager.update(currentTime, this.meteors);\n            // Check for level completion\n            if (this.levelManager.isLevelComplete(this.meteors)) {\n                if (this.levelManager.currentLevel >= $35da740d59af89ba$var$LEVELS.length - 1) this.gameState = $35da740d59af89ba$var$GAME_STATES.GAME_COMPLETE;\n                else this.gameState = $35da740d59af89ba$var$GAME_STATES.LEVEL_COMPLETE;\n            }\n        } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.LIFE_LOST) // Pause the level timer\n        this.levelManager.pause();\n    }\n    drawCurrency() {\n        const currencyY = $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM + $35da740d59af89ba$var$UNIT * 15; // Position below game grid\n        this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.TEXT;\n        this.ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n        this.ctx.textAlign = \"center\";\n        this.ctx.letterSpacing = $35da740d59af89ba$var$LETTER_SPACING;\n        // Draw currency centered below grid\n        this.ctx.fillText(`${$35da740d59af89ba$var$TEXTS.CURRENCY} $${this.currency}`, $35da740d59af89ba$var$GAME_WIDTH / 2, currencyY);\n        // Level text centered below progress bar\n        this.ctx.fillText(`${$35da740d59af89ba$var$LEVELS[this.levelManager.currentLevel].name}`, $35da740d59af89ba$var$GAME_WIDTH / 2, $35da740d59af89ba$var$TEXT_TOP);\n        // Draw scores in top left corner\n        this.ctx.textAlign = \"left\";\n        this.ctx.fillText(`${this.currentScore} ${$35da740d59af89ba$var$TEXTS.SCORE}`, $35da740d59af89ba$var$PADDING_LEFT, $35da740d59af89ba$var$TEXT_TOP);\n        this.ctx.letterSpacing = \"0px\";\n    }\n    draw() {\n        this.drawBackground();\n        if (this.gameState === $35da740d59af89ba$var$GAME_STATES.LOADING) this.drawLoadingScreen();\n        else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.MENU) {\n            $35da740d59af89ba$var$TextRenderer.drawTitle(this.ctx, {\n                title: $35da740d59af89ba$var$TEXTS.TITLE,\n                subtitle: $35da740d59af89ba$var$TEXTS.SUB_TITLE,\n                copy: $35da740d59af89ba$var$TEXTS.INTRO,\n                color: $35da740d59af89ba$var$COLORS.GAME_OVER_COLOR\n            });\n            this.startButton.draw(this.ctx);\n            this.drawVersion();\n        } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.PLAYING) {\n            this.drawDefenseGrid();\n            // Draw currency and lives\n            this.drawCurrency();\n            this.drawLives();\n            this.drawProgressBar(this.ctx);\n            // Draw defense options\n            this.defenseOptions.forEach((option)=>{\n                option.draw(this.ctx, this.selectedDefense && option.type.id === this.selectedDefense.id, this.currency);\n            });\n            // Draw meteors\n            this.meteors.forEach((meteor)=>meteor.draw(this.ctx));\n            // Draw coins\n            const currentTime = performance.now();\n            this.coins.forEach((coin)=>coin.draw(this.ctx, currentTime));\n            this.drawVersion();\n        } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.LIFE_LOST) {\n            // Draw the life lost screen\n            this.drawCurrency();\n            this.drawLives();\n            this.drawProgressBar(this.ctx);\n            // Add semi-transparent overlay\n            this.ctx.fillStyle = \"rgba(0, 0, 0, 0.7)\";\n            this.ctx.fillRect(0, 0, $35da740d59af89ba$var$GAME_WIDTH, $35da740d59af89ba$var$GAME_HEIGHT);\n            $35da740d59af89ba$var$TextRenderer.drawTitle(this.ctx, {\n                title: $35da740d59af89ba$var$TEXTS.LIFE_LOST,\n                color: $35da740d59af89ba$var$COLORS.GAME_OVER_COLOR,\n                subtitle: $35da740d59af89ba$var$TEXTS.LIFE_REMAINING(this.lives)\n            });\n            this.continueButton.draw(this.ctx);\n        } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.LEVEL_COMPLETE) {\n            $35da740d59af89ba$var$TextRenderer.drawTitle(this.ctx, {\n                title: $35da740d59af89ba$var$TEXTS.LEVEL_COMPLETE,\n                color: $35da740d59af89ba$var$COLORS.SUCCESS_COLOR\n            });\n            this.nextLevelButton.draw(this.ctx);\n        } else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.GAME_COMPLETE) $35da740d59af89ba$var$TextRenderer.drawTitle(this.ctx, {\n            title: $35da740d59af89ba$var$TEXTS.GAME_COMPLETE,\n            color: $35da740d59af89ba$var$COLORS.SUCCESS_COLOR,\n            subtitle: `${$35da740d59af89ba$var$TEXTS.SCORE}: ${this.currentScore} (${$35da740d59af89ba$var$TEXTS.LEVEL} ${this.levelManager.currentLevel + 1})\n${$35da740d59af89ba$var$TEXTS.HIGH_SCORE}: ${this.highScore} (${$35da740d59af89ba$var$TEXTS.LEVEL} ${this.levelHighScore + 1})`\n        });\n        else if (this.gameState === $35da740d59af89ba$var$GAME_STATES.GAME_OVER) {\n            $35da740d59af89ba$var$TextRenderer.drawTitle(this.ctx, {\n                title: $35da740d59af89ba$var$TEXTS.GAME_OVER,\n                color: $35da740d59af89ba$var$COLORS.GAME_OVER_COLOR,\n                subtitle: `${$35da740d59af89ba$var$TEXTS.SCORE}: ${this.currentScore} (${$35da740d59af89ba$var$TEXTS.LEVEL} ${this.levelManager.currentLevel + 1})\n${$35da740d59af89ba$var$TEXTS.HIGH_SCORE}: ${this.highScore} (${$35da740d59af89ba$var$TEXTS.LEVEL} ${this.levelHighScore + 1})`\n            });\n            this.retryButton.draw(this.ctx);\n        }\n    }\n    createDefenseOptions() {\n        const optionsAreaY = $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM + $35da740d59af89ba$var$UNIT * 30; // Move down to make room for currency\n        const spacing = $35da740d59af89ba$var$UNIT * 20;\n        const totalWidth = ($35da740d59af89ba$var$SPOT_SIZE + spacing) * $35da740d59af89ba$var$DEFENSE_TYPES.length - spacing;\n        const startX = ($35da740d59af89ba$var$GAME_WIDTH - totalWidth) / 2;\n        return $35da740d59af89ba$var$DEFENSE_TYPES.map((type, index)=>{\n            const x = startX + index * ($35da740d59af89ba$var$SPOT_SIZE + spacing);\n            const y = optionsAreaY;\n            return new $35da740d59af89ba$var$DefenseOption(type, x, y);\n        });\n    }\n    createDefenseGrid() {\n        const grid = [];\n        // Create 2D array for easier position reference\n        for(let row = 0; row < $35da740d59af89ba$var$GRID_ROWS; row++){\n            const rowArray = [];\n            for(let lane = 0; lane < $35da740d59af89ba$var$LANES; lane++){\n                const x = $35da740d59af89ba$var$PADDING_LEFT + lane * $35da740d59af89ba$var$LANE_WIDTH + $35da740d59af89ba$var$LANE_WIDTH / 2;\n                const y = $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$PADDING_BOTTOM - row * $35da740d59af89ba$var$SPOT_SIZE - $35da740d59af89ba$var$SPOT_SIZE / 2;\n                rowArray.push(new $35da740d59af89ba$var$DefenseSpot(x, y, row, lane));\n            }\n            grid.push(rowArray);\n        }\n        return grid;\n    }\n    // Helper method to get spot at specific coordinates\n    getSpotAtPosition(x, y) {\n        for(let row = 0; row < this.defenseGrid.length; row++)for(let lane = 0; lane < this.defenseGrid[row].length; lane++){\n            const spot = this.defenseGrid[row][lane];\n            if (x >= spot.x - $35da740d59af89ba$var$SPOT_SIZE / 2 && x <= spot.x + $35da740d59af89ba$var$SPOT_SIZE / 2 && y >= spot.y - $35da740d59af89ba$var$SPOT_SIZE / 2 && y <= spot.y + $35da740d59af89ba$var$SPOT_SIZE / 2) return spot;\n        }\n        return null;\n    }\n    drawProgressBar(ctx) {\n        // Draw progress bar background\n        const barWidth = $35da740d59af89ba$var$GAME_WIDTH - $35da740d59af89ba$var$PADDING_LEFT - $35da740d59af89ba$var$PADDING_RIGHT; // Leave some padding\n        const barHeight = $35da740d59af89ba$var$UNIT * 20;\n        const x = $35da740d59af89ba$var$PADDING_LEFT;\n        const y = $35da740d59af89ba$var$UNIT * 20; // Padding from top\n        // Background\n        ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n        ctx.fillRect(x, y, barWidth, barHeight);\n        // Progress (inverted to show remaining time)\n        const progress = 1 - this.levelManager.getLevelProgress();\n        ctx.fillStyle = $35da740d59af89ba$var$COLORS.PROGRESS_BAR;\n        ctx.fillRect(x, y, barWidth * progress, barHeight);\n        // Border\n        ctx.strokeStyle = $35da740d59af89ba$var$COLORS.PROGRESS_BORDER;\n        ctx.lineWidth = $35da740d59af89ba$var$UNIT * 2;\n        ctx.strokeRect(x, y, barWidth, barHeight);\n        // Time remaining\n        if ($35da740d59af89ba$var$DEBUG) {\n            const timeLeft = Math.ceil(($35da740d59af89ba$var$LEVELS[this.levelManager.currentLevel].duration - (performance.now() - this.levelManager.levelStartTime)) / 1000);\n            if (timeLeft > 0) {\n                ctx.font = $35da740d59af89ba$var$FONT.SMALL.full;\n                ctx.fillText(`${timeLeft}s`, $35da740d59af89ba$var$GAME_WIDTH - 30, y + barHeight / 2 + 5);\n            }\n        }\n    }\n    async loadAssets() {\n        try {\n            const success = await this.assetLoader.loadAll();\n            if (success) this.gameState = $35da740d59af89ba$var$GAME_STATES.MENU;\n            else console.error(\"Failed to load assets\");\n        } catch (error) {\n            console.error(\"Error loading assets:\", error);\n        }\n    }\n    drawLoadingScreen() {\n        const progress = this.assetLoader.getLoadingProgress();\n        // draw black background\n        this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.BACKGROUND;\n        this.ctx.fillRect(0, 0, $35da740d59af89ba$var$GAME_WIDTH, $35da740d59af89ba$var$GAME_HEIGHT);\n        // Draw loading bar\n        const barWidth = $35da740d59af89ba$var$GAME_WIDTH - $35da740d59af89ba$var$PADDING_LEFT - $35da740d59af89ba$var$PADDING_RIGHT; // Leave some padding\n        const barHeight = $35da740d59af89ba$var$UNIT * 20;\n        const x = $35da740d59af89ba$var$PADDING_LEFT;\n        const y = $35da740d59af89ba$var$GAME_HEIGHT / 2;\n        // Background\n        this.ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n        this.ctx.fillRect(x, y, barWidth, barHeight);\n        // Progress\n        this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.PROGRESS_BAR;\n        this.ctx.fillRect(x, y, barWidth * progress, barHeight);\n        // Border\n        this.ctx.strokeStyle = $35da740d59af89ba$var$COLORS.PROGRESS_BORDER;\n        this.ctx.lineWidth = $35da740d59af89ba$var$UNIT * 2;\n        this.ctx.strokeRect(x, y, barWidth, barHeight);\n        // Loading text\n        this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.TEXT;\n        this.ctx.font = $35da740d59af89ba$var$FONT.LARGE.full;\n        this.ctx.textAlign = \"center\";\n        this.ctx.fillText(\"Loading...\", $35da740d59af89ba$var$GAME_WIDTH / 2, y - $35da740d59af89ba$var$UNIT * 20);\n        this.ctx.fillText(`${Math.floor(progress * 100)}%`, $35da740d59af89ba$var$GAME_WIDTH / 2, y + $35da740d59af89ba$var$UNIT * 40);\n    }\n    drawLives() {\n        const heartSize = $35da740d59af89ba$var$UNIT * 17;\n        const spacing = $35da740d59af89ba$var$UNIT * 5;\n        const startX = $35da740d59af89ba$var$GAME_WIDTH - $35da740d59af89ba$var$PADDING_LEFT - heartSize / 2 - (heartSize + spacing) * ($35da740d59af89ba$var$INITIAL_LIVES - 1);\n        const y = $35da740d59af89ba$var$PADDING_TOP + $35da740d59af89ba$var$UNIT * 20;\n        // Draw hearts\n        for(let i = 0; i < $35da740d59af89ba$var$INITIAL_LIVES; i++){\n            const x = startX + (heartSize + spacing) * i;\n            // Draw empty heart outline\n            this.ctx.strokeStyle = $35da740d59af89ba$var$COLORS.HEART_STROKE;\n            this.ctx.lineWidth = $35da740d59af89ba$var$UNIT * 2;\n            this.drawHeart(x, y - heartSize / 2, heartSize);\n            // Fill heart if life is remaining\n            if (i < this.lives) {\n                this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.HEART_FILL;\n                this.drawHeart(x, y - heartSize / 2, heartSize, true);\n            }\n        }\n    }\n    // Helper method to draw a heart\n    drawHeart(x, y, size, fill = false) {\n        const path = new Path2D();\n        path.moveTo(x, y + size / 4);\n        path.bezierCurveTo(x, y, x - size / 2, y, x - size / 2, y + size / 4);\n        path.bezierCurveTo(x - size / 2, y + size / 2, x, y + size * 3 / 4, x, y + size * 3 / 4);\n        path.bezierCurveTo(x, y + size * 3 / 4, x + size / 2, y + size / 2, x + size / 2, y + size / 4);\n        path.bezierCurveTo(x + size / 2, y, x, y, x, y + size / 4);\n        if (fill) this.ctx.fill(path);\n        else {\n            this.ctx.lineCap = \"round\";\n            this.ctx.stroke(path);\n        }\n    }\n    // Add new method to continue playing\n    continuePlaying() {\n        this.gameState = $35da740d59af89ba$var$GAME_STATES.PLAYING;\n        this.meteors = [];\n        // Resume the level timer\n        this.levelManager.resume();\n    }\n    // Add after constructor\n    loadHighScore() {\n        const saved = localStorage.getItem($35da740d59af89ba$var$STORAGE_KEY + \"_coins\");\n        return saved ? parseInt(saved, 0) : 0;\n    }\n    saveHighScore() {\n        localStorage.setItem($35da740d59af89ba$var$STORAGE_KEY + \"_coins\", this.highScore.toString());\n    }\n    // Add new method to draw version\n    drawVersion() {\n        this.ctx.globalAlpha = 0.5;\n        this.ctx.fillStyle = $35da740d59af89ba$var$COLORS.TEXT;\n        this.ctx.font = $35da740d59af89ba$var$FONT.TINY.full; // Smaller font size\n        this.ctx.textAlign = \"right\";\n        this.ctx.fillText(`v${$35da740d59af89ba$var$LEVEL_GEN_CONFIG.levelVersion}`, $35da740d59af89ba$var$GAME_WIDTH - $35da740d59af89ba$var$UNIT * 5, $35da740d59af89ba$var$GAME_HEIGHT - $35da740d59af89ba$var$UNIT * 5); // Position in bottom left corner\n        this.ctx.globalAlpha = 1;\n    }\n    // Add new method to load level high score\n    loadLevelHighScore() {\n        const saved = localStorage.getItem($35da740d59af89ba$var$STORAGE_KEY + \"_level\");\n        return saved ? parseInt(saved, 0) : 0;\n    }\n    // Add new method to save level high score\n    saveLevelHighScore() {\n        localStorage.setItem($35da740d59af89ba$var$STORAGE_KEY + \"_level\", this.levelHighScore.toString());\n    }\n    // Move initialization code to separate method\n    initializeGameProperties() {\n        // Create buttons\n        this.startButton = new $35da740d59af89ba$var$Button($35da740d59af89ba$var$TEXTS.START_GAME);\n        this.retryButton = new $35da740d59af89ba$var$Button($35da740d59af89ba$var$TEXTS.TRY_AGAIN);\n        // Initialize currency and defense options\n        this.currency = $35da740d59af89ba$var$INITIAL_CURRENCY;\n        this.defenseOptions = this.createDefenseOptions();\n        this.selectedDefense = null;\n        // Initialize the defense grid\n        this.defenseGrid = this.createDefenseGrid();\n        this.levelManager = new $35da740d59af89ba$var$LevelManager();\n        // Add new buttons\n        this.nextLevelButton = new $35da740d59af89ba$var$Button($35da740d59af89ba$var$TEXTS.NEXT_LEVEL);\n        // Add new continue button\n        this.continueButton = new $35da740d59af89ba$var$Button($35da740d59af89ba$var$TEXTS.CONTINUE);\n        // Add lives property\n        this.lives = $35da740d59af89ba$var$INITIAL_LIVES;\n        // Add high score properties\n        this.currentScore = 0;\n        this.highScore = this.loadHighScore();\n        // Add level high score property\n        this.levelHighScore = this.loadLevelHighScore();\n        this.setupEventListeners();\n    }\n}\n// Start the game when the page loads\nwindow.addEventListener(\"load\", ()=>{\n    $35da740d59af89ba$var$game = new $35da740d59af89ba$var$Game();\n});\n\n\n//# sourceMappingURL=neo.a4f7df0f.js.map\n","// Game constants\nconst UNIT = 4;\n\nconst GAME_WIDTH = UNIT * 360; // Base width, will be scaled\nconst GAME_HEIGHT = UNIT * 640; // 16:9 ratio\n\nconst LANES = 6;\nconst PADDING_TOP = UNIT * 40; // More space for score/level\nconst PADDING_BOTTOM = UNIT * 100; // More space for controls/UI\nconst PADDING_LEFT = UNIT * 40;\nconst PADDING_RIGHT = UNIT * 40;\nconst TEXT_TOP = PADDING_TOP + UNIT * 20;\n\nconst INITIAL_CURRENCY = 500;\nconst INITIAL_LIVES = 3;\n\nconst BUTTON_WIDTH = (GAME_WIDTH / 5) * 3;\nconst BUTTON_HEIGHT = BUTTON_WIDTH / 4;\n\nconst BUTTON_X = GAME_WIDTH / 2 - BUTTON_WIDTH / 2;\nconst BUTTON_Y = GAME_HEIGHT / 2 - BUTTON_HEIGHT / 2;\n\n// Game area calculations\nconst GAME_AREA_WIDTH = GAME_WIDTH - (PADDING_LEFT + PADDING_RIGHT);\nconst GAME_AREA_HEIGHT = GAME_HEIGHT - (PADDING_TOP + PADDING_BOTTOM);\nconst LANE_WIDTH = GAME_AREA_WIDTH / LANES; // Width of each lane\nconst SPOT_SIZE = LANE_WIDTH; // Defense spots are same width as lanes\nconst METEOR_SIZE = LANE_WIDTH * 0.8; // Base size for meteors\nconst GRID_ROWS = Math.floor(GAME_AREA_HEIGHT / SPOT_SIZE);\nconst LETTER_SPACING = \"0.05em\";\n\n// Add to game constants\nconst DEBUG = false; // Toggle for development visualization\n\nconst COLORS = {\n  BACKGROUND: \"#000\",\n  TEXT: \"#c0aa9a\",\n  DEFENSE_OPTION_TEXT: \"#c0aa9a\",\n  DEFENSE_OPTION_TEXT_INACTIVE: \"#f00\",\n  BUTTON: \"#5d908a\",\n  BUTTON_TEXT: \"#fff\",\n  PROGRESS_BAR: \"#c0aa9a\",\n  PROGRESS_BORDER: \"#c0aa9a\",\n  DEFENSE_BACKGROUND: \"rgba(255,255,255,0.2)\",\n  BORDER: \"#333\",\n  DEBUG_LINE: \"rgba(0,0,0,0.1)\",\n  GRID_LINE: \"rgba(0,0,0,0.25)\",\n  DEBUG_TEXT: \"#666\",\n  SELECTION: \"rgba(255,80,80,0.7)\",\n  HEART_FILL: \"#c0aa9a\",\n  HEART_STROKE: \"#c0aa9a\",\n  GAME_OVER_COLOR: \"#FF4444\",\n  SUCCESS_COLOR: \"#5c8e8b\",\n};\n\nconst TEXTS = {\n  TITLE: window?.TXT?.TITLE || \"Meteor\\nDefense\",\n  SUB_TITLE: window?.TXT?.SUB_TITLE || \"Alles Gute im neuen Jahr!\",\n  INTRO: window?.TXT?.INTRO || \"\",\n  START_GAME: \"Start!\",\n  TRY_AGAIN: \"Neustart!\",\n  LIVES: \"Leben:\",\n  LEVEL: \"Level\",\n  SCORE: \"Punkte\",\n  COINS: \"Coins:\",\n  CURRENCY: \"Geld:\",\n  HIGH_SCORE: \"Rekord\",\n  LEVEL_COMPLETE: \"Geschafft!\",\n  GAME_OVER: \"Game Over!\",\n  GAME_COMPLETE: \"Alle\\nLevels\\ngeschafft!\",\n  LIFE_LOST: \"Leben\\nverloren!\",\n  CONTINUE: \"Weiter\",\n  NEXT_LEVEL: \"Nächstes Level\",\n  LIFE_REMAINING: (lives) => `noch ${lives} ${lives === 1 ? \"Leben\" : \"Leben\"}`,\n};\n\n// Level generation configuration options\nconst LEVEL_GEN_CONFIG = {\n  levelVersion: \"1.8.4\",\n  baseDuration: 30000, // Base duration in ms\n  durationIncrease: 0, // How much to increase duration per level (15s)\n  maxLevels: 30, // How many levels to generate\n  difficultyMultiplier: 0.85, // NEW: Global difficulty multiplier (1.0 = normal, < 1.0 easier, > 1.0 harder)\n\n  // Meteor type weights (chance of spawning) at start and end of level\n  meteorWeights: {\n    start: { small: 1, medium: 0, large: 0 },\n    end: { small: 0, medium: 0.35, large: 0.65 },\n  },\n\n  // Spawn timing\n  minSpawnGap: 900, // Minimum ms between meteors at start\n  minSpawnGapEnd: 200, // Minimum gap by end of level\n\n  maxSpawnGap: 1300, // Maximum ms between meteors at start\n  maxSpawnGapEnd: 200, // Maximum gap by end of level (NEW)\n\n  // Difficulty scaling\n  difficultyRamp: 1.25, // Multiplier for difficulty between levels\n  waveDuration: 6200, // Initial duration of attack waves in ms\n  waveDurationEnd: 1200, // End duration of attack waves in ms (NEW)\n  waveGap: 3200, // Initial gap between waves in ms\n  waveGapEnd: 400, // End gap between waves in ms (NEW)\n};\n\nfunction generateLevels(config = LEVEL_GEN_CONFIG) {\n  const levels = [];\n  const diff = config.difficultyMultiplier;\n\n  for (let levelNum = 0; levelNum < config.maxLevels; levelNum++) {\n    const duration =\n      (config.baseDuration + config.durationIncrease * levelNum) /\n      Math.sqrt(diff);\n    const meteors = [];\n    let currentTime = 1000;\n\n    const levelDifficulty = Math.pow(config.difficultyRamp, levelNum) * diff;\n\n    while (currentTime < duration - 2000) {\n      const levelProgress = currentTime / duration;\n      const adjustedWaveDuration = quadraticLerp(\n        config.waveDuration / Math.sqrt(diff),\n        config.waveDurationEnd / Math.sqrt(diff),\n        levelProgress,\n      );\n\n      const waveEndTime = currentTime + adjustedWaveDuration;\n\n      while (currentTime < waveEndTime) {\n        const waveProgress =\n          (currentTime - (waveEndTime - adjustedWaveDuration)) /\n          adjustedWaveDuration;\n\n        // Adjust weights based on difficulty (harder = more medium/large meteors)\n        const weights = {\n          small: quadraticLerp(\n            config.meteorWeights.start.small,\n            config.meteorWeights.end.small / diff, // Reduce small meteors at higher difficulty\n            waveProgress,\n          ),\n          medium: quadraticLerp(\n            config.meteorWeights.start.medium,\n            config.meteorWeights.end.medium * diff, // Increase medium meteors at higher difficulty\n            waveProgress,\n          ),\n          large: quadraticLerp(\n            config.meteorWeights.start.large,\n            config.meteorWeights.end.large * diff, // Increase large meteors at higher difficulty\n            waveProgress,\n          ),\n        };\n\n        // Select meteor type based on weights\n        const meteorType = selectMeteorType(weights);\n\n        // Select random lane\n        const lane = Math.floor(Math.random() * LANES);\n\n        meteors.push({\n          type: meteorType,\n          lane: lane,\n          startTime: Math.floor(currentTime),\n        });\n\n        // Adjust spawn gaps based on difficulty (harder = faster spawns)\n        const minGap = quadraticLerp(\n          config.minSpawnGap / diff,\n          config.minSpawnGapEnd / diff,\n          waveProgress,\n        );\n        const maxGap = quadraticLerp(\n          config.maxSpawnGap / diff,\n          config.maxSpawnGapEnd / diff,\n          waveProgress,\n        );\n        currentTime += Math.random() * (maxGap - minGap) + minGap;\n      }\n\n      const adjustedWaveGap = quadraticLerp(\n        config.waveGap / diff,\n        config.waveGapEnd / diff,\n        levelProgress,\n      );\n      currentTime += adjustedWaveGap;\n    }\n\n    levels.push({\n      name: `${TEXTS.LEVEL} ${levelNum + 1}`,\n      duration: duration,\n      meteors: meteors.sort((a, b) => a.startTime - b.startTime),\n    });\n  }\n\n  return levels;\n}\n\n// Helper function to linearly interpolate between two values\nfunction lerp(start, end, progress) {\n  return start + (end - start) * progress;\n}\n\nfunction quadraticLerp(start, end, progress) {\n  return start + (end - start) * progress * progress;\n}\n\n// Helper function to select meteor type based on weights\nfunction selectMeteorType(weights) {\n  const total = weights.small + weights.medium + weights.large;\n  const random = Math.random() * total;\n\n  if (random < weights.small) return 0; // Small meteor\n  if (random < weights.small + weights.medium) return 1; // Medium meteor\n  return 2; // Large meteor\n}\n\n// Replace the existing LEVELS constant with generated levels\nconst LEVELS = generateLevels();\n\nconst GAME_STATES = {\n  LOADING: \"loading\",\n  MENU: \"menu\",\n  PLAYING: \"playing\",\n  LIFE_LOST: \"lifeLost\",\n  LEVEL_COMPLETE: \"levelComplete\",\n  GAME_OVER: \"gameover\",\n  GAME_COMPLETE: \"gameComplete\",\n};\n\n// Add to game constants\nconst DEFENSE_TYPES = [\n  {\n    id: 0,\n    name: \"Basic\",\n    color: \"#4CAF50\",\n    cost: 100,\n    damage: 10,\n    health: 100,\n  },\n  {\n    id: 1,\n    name: \"Medium\",\n    color: \"#2196F3\",\n    cost: 140,\n    damage: 20,\n    health: 100,\n  },\n  {\n    id: 2,\n    name: \"Strong\",\n    color: \"#9C27B0\",\n    cost: 180,\n    damage: 30,\n    health: 100,\n  },\n];\n\n// Add to game constants\nconst METEOR_TYPES = [\n  {\n    id: 0,\n    name: \"Small\",\n    color: \"#FF9999\",\n    health: 30,\n    speed: UNIT * 0.05,\n    damageRate: 30,\n    rotateRate: 0.0005,\n    wiggleRate: 0.001,\n    wiggleAmount: 7,\n    sizeMultiplier: { x: 1.0, y: 1.0 },\n    coinReward: 20, // 1 coin\n  },\n  {\n    id: 1,\n    name: \"Medium\",\n    color: \"#FF4444\",\n    health: 60,\n    speed: UNIT * 0.035,\n    damageRate: 50,\n    rotateRate: 0,\n    wiggleRate: 0.03,\n    wiggleAmount: 0.03,\n    sizeMultiplier: { x: 1, y: 2 },\n    coinReward: 40, // 2 coins\n  },\n  {\n    id: 2,\n    name: \"Large\",\n    color: \"#FF0000\",\n    health: 90,\n    speed: UNIT * 0.05,\n    damageRate: 50,\n    rotateRate: 0,\n    wiggleRate: 0.03,\n    wiggleAmount: 0.03,\n    sizeMultiplier: { x: 1, y: 2 },\n    coinReward: 50, // 3 coins\n  },\n];\n\n// Font definitions\nconst FONT = {\n  TINY: {\n    size: UNIT * 7,\n    family: \"GameText, Arial, sans-serif\",\n    get full() {\n      return `${this.size}px ${this.family}`;\n    },\n  },\n  SMALL: {\n    size: UNIT * 13,\n    family: \"GameText, Arial, sans-serif\",\n    get full() {\n      return `${this.size}px ${this.family}`;\n    },\n  },\n  LARGE: {\n    size: UNIT * 18,\n    family: \"GameText, Arial, sans-serif\",\n    get full() {\n      return `${this.size}px ${this.family}`;\n    },\n  },\n  TITLE: {\n    size: UNIT * 42,\n    family: \"GameTitle, Arial, sans-serif\",\n    get full() {\n      return `${this.size}px ${this.family}`;\n    },\n  },\n};\n\n// Add at the top of the file, after other constants\nconst ASSETS = {\n  METEORS: [\n    \"/assets/img/meteor-1.png\",\n    \"/assets/img/meteor-2.png\",\n    \"/assets/img/meteor-3.png\",\n  ],\n  DEFENSES: [\n    \"/assets/img/defense-1.png\",\n    \"/assets/img/defense-2.png\",\n    \"/assets/img/defense-3.png\",\n  ],\n  BACKGROUND: \"/assets/img/bg.png\",\n  FONTS: {\n    TITLE: \"/assets/fonts/pilowlava/Fonts/webfonts/Pilowlava-Regular.woff2\",\n    TEXT: \"/assets/fonts/space-mono/SpaceMono-Regular.ttf\",\n  },\n};\n\n// Add new AssetLoader class\nclass AssetLoader {\n  constructor() {\n    this.images = new Map();\n    this.fonts = new Map();\n    this.totalAssets = 0;\n    this.loadedAssets = 0;\n  }\n\n  async loadAll() {\n    // Add font loading\n    const fontPromises = [\n      this.loadFont(\"GameText\", ASSETS.FONTS.TEXT),\n      this.loadFont(\"GameTitle\", ASSETS.FONTS.TITLE),\n    ];\n\n    const meteorPromises = ASSETS.METEORS.map((path, index) =>\n      this.loadImage(`meteor-${index}`, path),\n    );\n\n    const defensePromises = ASSETS.DEFENSES.map((path, index) =>\n      this.loadImage(`defense-${index}`, path),\n    );\n\n    const backgroundPromise = this.loadImage(\"background\", ASSETS.BACKGROUND);\n\n    try {\n      await Promise.all([\n        ...fontPromises,\n        ...meteorPromises,\n        ...defensePromises,\n        backgroundPromise,\n      ]);\n      return true;\n    } catch (error) {\n      console.error(\"Error loading assets:\", error);\n      return false;\n    }\n  }\n\n  loadImage(key, src) {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      this.totalAssets++;\n\n      img.onload = () => {\n        this.images.set(key, img);\n        this.loadedAssets++;\n        resolve(img);\n      };\n\n      img.onerror = () => {\n        reject(new Error(`Failed to load image: ${src}`));\n      };\n\n      img.src = src;\n    });\n  }\n\n  getImage(key) {\n    return this.images.get(key);\n  }\n\n  getLoadingProgress() {\n    return this.totalAssets ? this.loadedAssets / this.totalAssets : 0;\n  }\n\n  // Add new loadFont method\n  async loadFont(fontFamily, url) {\n    this.totalAssets++;\n\n    const fontFace = new FontFace(fontFamily, `url(${url})`);\n\n    try {\n      const loadedFont = await fontFace.load();\n      document.fonts.add(loadedFont);\n      this.fonts.set(fontFamily, loadedFont);\n      this.loadedAssets++;\n      return loadedFont;\n    } catch (error) {\n      console.error(`Failed to load font: ${url}`, error);\n      throw error;\n    }\n  }\n}\n\n// Add at the top of the file, after constants\nlet game; // Global game instance\n\n// Test meteor\nclass Meteor {\n  constructor(lane, type = METEOR_TYPES[0]) {\n    this.lane = lane;\n    this.type = type;\n    this.y = PADDING_TOP;\n    this.health = type.health;\n    this.speed = type.speed;\n    this.isBlocked = false;\n    this.blockingDefense = null;\n\n    // Add rotation and wiggle properties\n    this.baseRotation = 0; // Base rotation from type.rotateRate\n    this.wiggleRotation = 0; // Additional rotation from wiggle motion\n    this.wiggleOffset = 0;\n    this.baseX = PADDING_LEFT + lane * LANE_WIDTH + LANE_WIDTH / 2;\n  }\n\n  update(deltaTime) {\n    if (!this.isBlocked) {\n      this.y += this.speed * deltaTime;\n\n      // Update base rotation\n      this.baseRotation += this.type.rotateRate * deltaTime;\n\n      // Update wiggle and calculate wiggle-based rotation\n      this.wiggleOffset += this.type.wiggleRate * deltaTime;\n      // Calculate rotation based on wiggle movement (adjust 0.5 to control rotation intensity)\n      this.wiggleRotation =\n        Math.cos(this.wiggleOffset) * this.type.wiggleAmount * 0.5;\n    }\n  }\n\n  block(defense) {\n    this.isBlocked = true;\n    this.blockingDefense = defense;\n  }\n\n  unblock() {\n    this.isBlocked = false;\n    this.blockingDefense = null;\n  }\n\n  draw(ctx) {\n    // Calculate wiggled x position\n    const wiggleX =\n      this.baseX + Math.sin(this.wiggleOffset) * this.type.wiggleAmount;\n\n    // Get the corresponding meteor image\n    const meteorImage = game?.assetLoader.getImage(`meteor-${this.type.id}`);\n\n    if (meteorImage) {\n      ctx.save(); // Save current context state\n\n      // Translate to meteor position\n      ctx.translate(wiggleX, this.y);\n\n      // Apply combined rotation (base rotation + wiggle-based rotation)\n      ctx.rotate(this.baseRotation + this.wiggleRotation);\n\n      // Calculate size using multiplier\n      const height = METEOR_SIZE * this.type.sizeMultiplier.y;\n      const width = METEOR_SIZE * this.type.sizeMultiplier.x;\n\n      // Draw the image centered at the translated position\n      ctx.drawImage(meteorImage, -width / 2, -height / 2, width, height);\n\n      ctx.restore(); // Restore context state\n    } else {\n      // Fallback to original circle drawing if image isn't loaded\n      ctx.fillStyle = this.type.color;\n      ctx.beginPath();\n      ctx.arc(wiggleX, this.y, 10, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    if (DEBUG) {\n      // Draw collision circle\n      ctx.strokeStyle = \"rgba(255,0,0,0.5)\";\n      ctx.beginPath();\n      ctx.arc(wiggleX, this.y, 10, 0, Math.PI * 2);\n      ctx.stroke();\n\n      // Draw health\n      ctx.fillStyle = \"white\";\n      ctx.font = FONT.SMALL.full;\n      ctx.textAlign = \"center\";\n      ctx.fillText(`${this.health}`, wiggleX, this.y);\n    }\n  }\n\n  takeDamage(damage) {\n    this.health -= damage;\n    return this.health <= 0;\n  }\n}\n\n// Add to existing constants\nclass Button {\n  constructor(\n    text,\n    backgroundColor = COLORS.BUTTON,\n    textColor = COLORS.BUTTON_TEXT,\n    fontSize = 16,\n  ) {\n    this.x = BUTTON_X;\n    this.y = BUTTON_Y;\n    this.width = BUTTON_WIDTH;\n    this.height = BUTTON_HEIGHT;\n    this.text = text;\n    this.backgroundColor = backgroundColor;\n    this.textColor = textColor;\n    this.fontSize = fontSize;\n  }\n\n  isClicked(clickX, clickY) {\n    return (\n      clickX >= this.x &&\n      clickX <= this.x + this.width &&\n      clickY >= this.y &&\n      clickY <= this.y + this.height\n    );\n  }\n\n  draw(ctx) {\n    // Draw button background\n    ctx.fillStyle = this.backgroundColor;\n    ctx.fillRect(this.x, this.y, this.width, this.height);\n\n    // Draw button text\n    ctx.fillStyle = this.textColor;\n    ctx.font = FONT.LARGE.full;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.letterSpacing = LETTER_SPACING;\n    ctx.fillText(\n      this.text,\n      this.x + this.width / 2,\n      this.y + this.height * 0.52,\n    );\n    ctx.letterSpacing = \"0px\";\n  }\n}\n\nclass Projectile {\n  constructor(x, y, damage) {\n    this.x = x;\n    this.y = y;\n    this.speed = UNIT * 0.3;\n    this.damage = damage;\n    this.size = UNIT * 4;\n  }\n\n  update(deltaTime) {\n    this.y -= this.speed * deltaTime;\n  }\n\n  draw(ctx) {\n    ctx.fillStyle = \"black\";\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n    ctx.fill();\n\n    if (DEBUG) {\n      // Draw collision circle\n      ctx.strokeStyle = \"rgba(255,255,0,0.3)\";\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n  }\n\n  checkCollision(meteor) {\n    const meteorX = PADDING_LEFT + meteor.lane * LANE_WIDTH + LANE_WIDTH / 2;\n    const dx = this.x - meteorX;\n    const dy = this.y - meteor.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < this.size + 10 * UNIT; // 10 is meteor radius\n  }\n\n  isOffScreen() {\n    return this.y < PADDING_TOP;\n  }\n}\n\n// Add to game constants\nclass Defense {\n  constructor(type = null) {\n    this.type = type;\n    this.health = type ? type.health : 0;\n    this.maxHealth = type ? type.health : 0;\n    this.projectiles = [];\n    this.lastFireTime = 0;\n    this.fireRate = 1000;\n    this.blockingMeteors = []; // Add array to track blocked meteors\n  }\n\n  isEmpty() {\n    return this.type === null;\n  }\n\n  takeDamage(amount) {\n    this.health -= amount;\n    return this.health <= 0;\n  }\n\n  update(currentTime, x, y, meteors, coins) {\n    if (!this.isEmpty()) {\n      // Fire projectile if enough time has passed\n      if (currentTime - this.lastFireTime > this.fireRate) {\n        this.projectiles.push(new Projectile(x, y, this.type.damage));\n        this.lastFireTime = currentTime;\n      }\n\n      // Check for meteor collisions with this defense\n      const defenseRow = Math.floor((y - PADDING_TOP) / SPOT_SIZE);\n      meteors.forEach((meteor) => {\n        const meteorRow = Math.floor((meteor.y - PADDING_TOP) / SPOT_SIZE);\n        if (\n          meteorRow === defenseRow &&\n          meteor.lane === Math.floor((x - PADDING_LEFT) / LANE_WIDTH)\n        ) {\n          // Block meteor if not already blocked\n          if (!meteor.isBlocked) {\n            meteor.block(this);\n            this.blockingMeteors.push(meteor); // Track this meteor\n          }\n\n          // Take damage from meteor using meteor's damage rate\n          if (meteor.blockingDefense === this) {\n            const destroyed = this.takeDamage(meteor.type.damageRate / 60);\n            if (destroyed) {\n              // Unblock all meteors this defense was blocking\n              this.blockingMeteors.forEach((m) => m.unblock());\n              this.blockingMeteors = [];\n              this.type = null; // Reset defense when destroyed\n              this.health = 0;\n              this.maxHealth = 0;\n            }\n          }\n        }\n      });\n\n      // Update existing projectiles and check collisions\n      this.projectiles = this.projectiles.filter((projectile) => {\n        projectile.update(16);\n\n        // Check for collisions with any meteor\n        for (let i = 0; i < meteors.length; i++) {\n          const meteor = meteors[i];\n          if (projectile.checkCollision(meteor)) {\n            const destroyed = meteor.takeDamage(projectile.damage);\n            if (destroyed) {\n              // Spawn coin at meteor's position with meteor's reward value\n              const meteorX =\n                PADDING_LEFT + meteor.lane * LANE_WIDTH + LANE_WIDTH / 2;\n              coins.push(new Coin(meteorX, meteor.y, meteor.type.coinReward));\n              meteors.splice(i, 1);\n            }\n            return false; // Remove projectile\n          }\n        }\n\n        return !projectile.isOffScreen();\n      });\n    }\n  }\n\n  draw(ctx, x, y, size, isSelected = false, isInactive = false) {\n    // Draw spot outline\n    ctx.strokeStyle = this.isEmpty() ? COLORS.GRID_LINE : \"#888\";\n    ctx.lineWidth = UNIT * 1;\n    ctx.strokeRect(x - size / 2, y - size / 2, size, size);\n    ctx.fillStyle = COLORS.DEFENSE_BACKGROUND; // Add black background to prevent any transparency\n    ctx.fillRect(x - size / 2, y - size / 2, size, size);\n\n    if (!this.isEmpty()) {\n      if (game?.assetLoader) {\n        // Draw defense image\n        const defenseImage = game.assetLoader.getImage(\n          `defense-${this.type.id}`,\n        );\n        if (defenseImage) {\n          if (isInactive) {\n            ctx.globalAlpha = 0.5;\n          } else {\n            ctx.globalAlpha = Math.max(0.3, this.health / this.maxHealth);\n          }\n\n          ctx.drawImage(defenseImage, x - size / 2, y - size / 2, size, size);\n\n          ctx.globalAlpha = 1.0;\n        }\n      }\n\n      // Draw projectiles\n      this.projectiles.forEach((projectile) => projectile.draw(ctx));\n\n      if (DEBUG) {\n        // Draw health bar\n        ctx.fillStyle = COLORS.TEXT;\n        ctx.font = FONT.SMALL.full;\n        ctx.textAlign = \"center\";\n        ctx.fillText(\n          `${Math.floor((this.health / this.maxHealth) * 100)}%`,\n          x,\n          y,\n        );\n      }\n\n      // Draw selection highlight\n      if (isSelected) {\n        ctx.strokeStyle = COLORS.SELECTION;\n        ctx.lineWidth = UNIT * 4;\n        ctx.strokeRect(x - size / 2, y - size / 2, size, size);\n      }\n    }\n  }\n}\n\nclass DefenseOption {\n  constructor(type, x, y) {\n    this.type = type;\n    this.x = x;\n    this.y = y;\n    this.defense = new Defense(type);\n  }\n\n  draw(ctx, isSelected = false, currentCurrency = 0) {\n    const isInactive = currentCurrency < this.type.cost;\n\n    // Draw defense using Defense class\n    this.defense.draw(\n      ctx,\n      this.x + SPOT_SIZE / 2,\n      this.y + SPOT_SIZE / 2,\n      SPOT_SIZE,\n      isSelected,\n      isInactive,\n    );\n\n    // Draw cost (red if can't afford)\n    ctx.fillStyle = isInactive\n      ? COLORS.DEFENSE_OPTION_TEXT_INACTIVE\n      : COLORS.DEFENSE_OPTION_TEXT;\n    ctx.font = FONT.SMALL.full;\n    ctx.textAlign = \"center\";\n    ctx.letterSpacing = LETTER_SPACING;\n    ctx.fillText(\n      `$${this.type.cost}`,\n      this.x + SPOT_SIZE / 2,\n      this.y + SPOT_SIZE + UNIT * 15,\n    );\n    ctx.letterSpacing = \"0px\";\n  }\n\n  isClicked(clickX, clickY) {\n    return (\n      clickX >= this.x &&\n      clickX <= this.x + SPOT_SIZE &&\n      clickY >= this.y &&\n      clickY <= this.y + SPOT_SIZE\n    );\n  }\n}\n\nclass DefenseSpot {\n  constructor(x, y, row, lane) {\n    this.x = x;\n    this.y = y;\n    this.row = row;\n    this.lane = lane;\n    this.defense = new Defense();\n  }\n\n  isEmpty() {\n    return this.defense.isEmpty();\n  }\n\n  placeDefense(defenseType) {\n    if (this.isEmpty()) {\n      this.defense = new Defense(defenseType);\n      return true;\n    }\n    return false;\n  }\n\n  removeDefense() {\n    this.defense = new Defense(); // Reset to empty defense\n  }\n\n  draw(ctx) {\n    // Draw defense (or empty spot)\n    this.defense.draw(ctx, this.x, this.y, SPOT_SIZE);\n\n    if (DEBUG) {\n      // Draw coordinates for debugging\n      ctx.fillStyle = COLORS.DEBUG_TEXT;\n      ctx.font = FONT.SMALL.full;\n      ctx.textAlign = \"center\";\n      ctx.fillText(`${this.lane},${this.row}`, this.x, this.y);\n    }\n  }\n\n  update(currentTime, meteors, coins) {\n    this.defense.update(currentTime, this.x, this.y, meteors, coins);\n  }\n}\n\nclass Coin {\n  constructor(x, y, value = 10) {\n    this.x = x;\n    this.y = y;\n    this.value = value;\n    this.lifetime = 5000; // 5 seconds lifetime\n    this.createTime = performance.now();\n    this.hitRadius = UNIT * 30; // Bigger radius for hit detection\n\n    // Size based on value\n    this.size = UNIT * (8 + ((value - 10) / 10) * 2); // Increases by 2 pixels for each 10 value\n\n    // Base movement\n    const angle = Math.random() * Math.PI * 2;\n    const speed = UNIT * (0.3 + Math.random() * 0.1);\n    this.vx = Math.cos(angle) * speed;\n    this.vy = Math.sin(angle) * speed;\n\n    // Wave motion parameters\n    this.waveAmplitude = UNIT * (2.2 + Math.random() * 0.2);\n    this.waveFrequency = 0.005 + Math.random() * 0.001;\n    this.waveOffset = Math.random() * Math.PI * 2;\n    this.baseX = x;\n    this.baseY = y;\n    this.time = 0;\n  }\n\n  draw(ctx, currentTime) {\n    const age = currentTime - this.createTime;\n    const remainingTime = this.lifetime - age;\n\n    // Start blinking when less than 1.5 seconds remaining\n    if (remainingTime < 1500) {\n      const blinkRate = 100 + (remainingTime / 1500) * 400;\n      if (Math.floor(currentTime / blinkRate) % 2 === 0) {\n        return;\n      }\n    }\n\n    if (DEBUG) {\n      // Draw hit area\n      ctx.strokeStyle = \"rgba(255, 80, 80, 0.6)\";\n      ctx.beginPath();\n      ctx.arc(this.x, this.y, this.hitRadius, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n\n    const coinX =\n      this.x +\n      Math.sin(this.time * this.waveFrequency + this.waveOffset) *\n        this.waveAmplitude;\n    const coinY =\n      this.y +\n      Math.cos(this.time * this.waveFrequency + this.waveOffset) *\n        this.waveAmplitude;\n\n    // Draw coin with gradient for more depth\n    const gradient = ctx.createRadialGradient(\n      coinX - this.size / 3,\n      coinY - this.size / 3,\n      0,\n      coinX,\n      coinY,\n      this.size,\n    );\n    gradient.addColorStop(0, \"#FFD700\"); // Bright gold\n    gradient.addColorStop(1, \"#DAA520\"); // Darker gold\n\n    ctx.fillStyle = gradient;\n    ctx.beginPath();\n    ctx.arc(coinX, coinY, this.size, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Add coin border\n    ctx.strokeStyle = \"#B8860B\"; // Dark gold\n    ctx.lineWidth = UNIT * 1;\n    ctx.stroke();\n\n    // Draw value\n    ctx.fillStyle = \"black\";\n    ctx.globalAlpha = 0.7;\n    ctx.font = `${Math.max(10, this.size)}px ${FONT.SMALL.family}`;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.letterSpacing = LETTER_SPACING;\n    ctx.fillText(`${this.value}`, coinX, coinY + this.size / 8);\n    ctx.letterSpacing = \"0px\";\n    ctx.globalAlpha = 1;\n  }\n\n  update(currentTime) {\n    this.time += 16; // Increment time (assuming ~60fps)\n\n    // Update base position with velocity\n    this.baseX += this.vx;\n    this.baseY += this.vy;\n\n    // Add wave motion\n    this.x =\n      this.baseX +\n      Math.sin(this.time * this.waveFrequency + this.waveOffset) *\n        this.waveAmplitude;\n    this.y =\n      this.baseY +\n      Math.cos(this.time * this.waveFrequency + this.waveOffset) *\n        this.waveAmplitude;\n\n    // Calculate remaining lifetime\n    const age = currentTime - this.createTime;\n    return age < this.lifetime;\n  }\n\n  isClicked(clickX, clickY) {\n    const dx = clickX - this.x;\n    const dy = clickY - this.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < this.hitRadius;\n  }\n}\n\nclass LevelManager {\n  constructor() {\n    this.currentLevel = 0;\n    this.levelStartTime = 0;\n    this.remainingMeteors = [];\n    this.allMeteorsSpawned = false;\n    this.pauseStartTime = 0; // Add new property to track pause time\n    this.totalPausedTime = 0; // Add new property to track total paused time\n  }\n\n  startLevel(levelIndex) {\n    this.currentLevel = levelIndex;\n    this.levelStartTime = performance.now();\n    this.remainingMeteors = [...LEVELS[levelIndex].meteors];\n    this.allMeteorsSpawned = false;\n    this.totalPausedTime = 0; // Reset paused time when starting new level\n  }\n\n  update(currentTime, meteors) {\n    if (this.currentLevel >= LEVELS.length) return false;\n\n    // Adjust level time by subtracting total paused time\n    const levelTime = currentTime - this.levelStartTime - this.totalPausedTime;\n    const level = LEVELS[this.currentLevel];\n\n    // Check if level time is exceeded\n    if (levelTime >= level.duration) {\n      this.allMeteorsSpawned = true;\n      return false;\n    }\n\n    // Spawn meteors that are due\n    while (\n      this.remainingMeteors.length > 0 &&\n      levelTime >= this.remainingMeteors[0].startTime\n    ) {\n      const meteorData = this.remainingMeteors.shift();\n      meteors.push(new Meteor(meteorData.lane, METEOR_TYPES[meteorData.type]));\n    }\n\n    // Check if all meteors have been spawned\n    if (this.remainingMeteors.length === 0) {\n      this.allMeteorsSpawned = true;\n    }\n\n    return true;\n  }\n\n  isLevelComplete(meteors) {\n    return this.allMeteorsSpawned && meteors.length === 0;\n  }\n\n  getLevelProgress() {\n    const currentTime = performance.now();\n    let adjustedTime = currentTime - this.levelStartTime - this.totalPausedTime;\n    // If currently paused, also subtract the current pause duration\n    if (this.pauseStartTime) {\n      adjustedTime -= currentTime - this.pauseStartTime;\n    }\n    const duration = LEVELS[this.currentLevel].duration;\n    return Math.min(adjustedTime / duration, 1);\n  }\n\n  // Add new methods to handle pausing\n  pause() {\n    if (!this.pauseStartTime) {\n      this.pauseStartTime = performance.now();\n    }\n  }\n\n  resume() {\n    if (this.pauseStartTime) {\n      this.totalPausedTime += performance.now() - this.pauseStartTime;\n      this.pauseStartTime = 0;\n    }\n  }\n}\n\nconst STORAGE_KEY = \"meteorDefenseHighScore\";\n\n// Add after other classes, before Game class\nclass TextRenderer {\n  static drawTitle(\n    ctx,\n    { title = \"\", color = COLORS.TEXT, subtitle = null, copy = null },\n  ) {\n    const x = GAME_WIDTH / 2;\n    const baseY = GAME_HEIGHT / 4;\n    const titleLineHeight = FONT.TITLE.size * 1.2;\n    const subtitleLineHeight = FONT.LARGE.size * 1.3;\n    const copyLineHeight = FONT.SMALL.size * 1.35;\n\n    // Split title into lines\n    const titleLines = title.split(\"\\n\");\n    // Calculate starting Y position that grows upward\n    const titleStartY = baseY - (titleLines.length - 1) * titleLineHeight;\n\n    // Draw main title lines\n    ctx.fillStyle = color;\n    ctx.font = FONT.TITLE.full;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    titleLines.forEach((line, index) => {\n      ctx.fillText(line, x, titleStartY + index * titleLineHeight);\n    });\n\n    // Draw subtitle if provided\n    if (subtitle) {\n      ctx.fillStyle = COLORS.TEXT;\n      ctx.font = FONT.LARGE.full;\n      ctx.letterSpacing = LETTER_SPACING;\n      // Split subtitle into lines and render each one\n      const subtitleLines = subtitle.split(\"\\n\");\n      subtitleLines.forEach((line, index) => {\n        ctx.fillText(\n          line,\n          x,\n          baseY + titleLineHeight + index * subtitleLineHeight,\n        );\n      });\n      ctx.letterSpacing = \"0px\";\n    }\n    if (copy) {\n      ctx.fillStyle = COLORS.TEXT;\n      ctx.font = FONT.SMALL.full;\n      ctx.letterSpacing = LETTER_SPACING;\n      // Split copy into lines and render each one\n      const copyLines = copy.split(\"\\n\");\n      copyLines.forEach((line, index) => {\n        ctx.fillText(line, x, (GAME_HEIGHT / 5) * 3 + index * copyLineHeight);\n      });\n      ctx.letterSpacing = \"0px\";\n    }\n  }\n}\n\nclass Game {\n  constructor() {\n    this.canvas = document.getElementById(\"canvas\");\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.lastTime = 0;\n    this.meteors = [];\n    this.coins = [];\n    this.assetLoader = new AssetLoader();\n    this.gameState = GAME_STATES.LOADING;\n\n    // Initialize game dimensions and scaling\n    this.initializeCanvas();\n    window.addEventListener(\"resize\", () => this.initializeCanvas());\n\n    // Initialize other game properties\n    this.initializeGameProperties();\n\n    // Start game loop immediately\n    requestAnimationFrame((timestamp) => this.gameLoop(timestamp));\n\n    // Load assets separately\n    this.loadAssets();\n  }\n\n  initializeCanvas() {\n    // Get dynamic viewport height (accounts for mobile browser UI elements)\n    const viewportWidth = window.innerWidth;\n    const viewportHeight = window.innerHeight;\n\n    // Calculate maximum possible game size that maintains aspect ratio\n    const gameAspectRatio = GAME_WIDTH / GAME_HEIGHT;\n    const viewportAspectRatio = viewportWidth / viewportHeight;\n\n    let scale;\n    if (viewportAspectRatio > gameAspectRatio) {\n      // Viewport is wider than game - fit to height\n      scale = viewportHeight / GAME_HEIGHT;\n    } else {\n      // Viewport is taller than game - fit to width\n      scale = viewportWidth / GAME_WIDTH;\n    }\n\n    // Ensure the scaled size doesn't exceed viewport\n    scale = Math.min(scale, 1);\n\n    this.canvas.width = GAME_WIDTH;\n    this.canvas.height = GAME_HEIGHT;\n\n    // Apply scale through CSS\n    this.canvas.style.width = `${GAME_WIDTH * scale}px`;\n    this.canvas.style.height = `${GAME_HEIGHT * scale}px`;\n  }\n\n  setupEventListeners() {\n    this.canvas.addEventListener(\"click\", (e) => {\n      const rect = this.canvas.getBoundingClientRect();\n      const scale = this.canvas.width / rect.width;\n      const x = (e.clientX - rect.left) * scale;\n      const y = (e.clientY - rect.top) * scale;\n\n      if (this.gameState === GAME_STATES.MENU) {\n        if (this.startButton.isClicked(x, y)) {\n          this.startGame();\n        }\n      } else if (this.gameState === GAME_STATES.GAME_OVER) {\n        if (this.retryButton.isClicked(x, y)) {\n          this.startGame();\n        }\n      } else if (this.gameState === GAME_STATES.LEVEL_COMPLETE) {\n        if (this.nextLevelButton.isClicked(x, y)) {\n          this.startNextLevel();\n        }\n      } else if (this.gameState === GAME_STATES.PLAYING) {\n        // Check for coin collection first\n        let coinCollected = false;\n        for (let i = this.coins.length - 1; i >= 0; i--) {\n          const coin = this.coins[i];\n          if (coin.isClicked(x, y)) {\n            this.currency += coin.value;\n            this.currentScore += coin.value; // Add to current score\n            this.coins.splice(i, 1);\n            coinCollected = true;\n            break;\n          }\n        }\n\n        // Only check defense interactions if we didn't collect a coin\n        if (!coinCollected) {\n          // Check if defense option was clicked\n          this.defenseOptions.forEach((option) => {\n            if (option.isClicked(x, y)) {\n              if (this.selectedDefense === option.type) {\n                // Deselect if clicking the same defense\n                this.selectedDefense = null;\n                console.log(\"Defense deselected\");\n              } else if (this.currency >= option.type.cost) {\n                this.selectedDefense = option.type;\n                console.log(`Selected ${option.type.name} defense`);\n              } else {\n                console.log(\"Not enough currency!\");\n              }\n            }\n          });\n\n          // Check if grid spot was clicked\n          if (this.selectedDefense) {\n            const spot = this.getSpotAtPosition(x, y);\n            if (spot && spot.isEmpty()) {\n              if (this.currency >= this.selectedDefense.cost) {\n                spot.placeDefense(this.selectedDefense);\n                this.currency -= this.selectedDefense.cost;\n                this.selectedDefense = null; // Reset selection after placing defense\n              }\n            }\n          }\n        }\n      } else if (this.gameState === GAME_STATES.LIFE_LOST) {\n        if (this.continueButton.isClicked(x, y)) {\n          this.continuePlaying();\n          this.currency += 120;\n        }\n      }\n    });\n  }\n\n  startGame() {\n    this.gameState = GAME_STATES.PLAYING;\n    this.meteors = [];\n    this.coins = [];\n    this.currency = INITIAL_CURRENCY;\n    this.selectedDefense = null;\n    this.lives = INITIAL_LIVES; // Reset lives when starting new game\n    this.currentScore = 0; // Reset current score\n    this.levelManager.startLevel(0);\n\n    // Reset defense grid\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        this.defenseGrid[row][lane].removeDefense();\n      }\n    }\n  }\n\n  startNextLevel() {\n    this.meteors = [];\n    this.coins = [];\n    this.currency = INITIAL_CURRENCY;\n    this.selectedDefense = null;\n\n    // Reset defense grid\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        this.defenseGrid[row][lane].removeDefense();\n      }\n    }\n\n    this.levelManager.startLevel(this.levelManager.currentLevel + 1);\n    this.gameState = GAME_STATES.PLAYING;\n  }\n\n  gameLoop(timestamp) {\n    // Calculate delta time\n    const deltaTime = timestamp - this.lastTime;\n    this.lastTime = timestamp;\n\n    // Clear canvas\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    // Update and draw game elements\n    this.update(deltaTime);\n    this.draw();\n\n    // Continue game loop\n    requestAnimationFrame((timestamp) => this.gameLoop(timestamp));\n  }\n\n  drawBackground() {\n    if (DEBUG) {\n      this.ctx.fillStyle = \"#666\";\n      this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n\n      return;\n    }\n\n    // Draw background image\n    const bgImage = this.assetLoader.getImage(\"background\");\n    if (bgImage) {\n      // Draw the image covering the full canvas, before anything else\n      this.ctx.fillStyle = COLORS.BACKGROUND; // Add black background to prevent any transparency\n      this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n      this.ctx.drawImage(bgImage, 0, 0, GAME_WIDTH, GAME_HEIGHT);\n    } else {\n      // Fallback to solid color if image not loaded\n      this.ctx.fillStyle = COLORS.BACKGROUND;\n      this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n    }\n  }\n\n  drawDefenseGrid() {\n    // Draw defense grid\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        this.defenseGrid[row][lane].draw(this.ctx);\n      }\n    }\n  }\n\n  update(deltaTime) {\n    if (this.gameState === GAME_STATES.PLAYING) {\n      const currentTime = performance.now();\n\n      // Update all defense spots\n      for (let row = 0; row < this.defenseGrid.length; row++) {\n        for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n          this.defenseGrid[row][lane].update(\n            currentTime,\n            this.meteors,\n            this.coins,\n          );\n        }\n      }\n\n      // Update meteors and check for lives\n      this.meteors = this.meteors.filter((meteor) => {\n        meteor.update(deltaTime);\n        if (meteor.y >= GAME_HEIGHT - PADDING_BOTTOM) {\n          this.lives--;\n          if (this.lives <= 0) {\n            // Update high score when game ends\n            if (this.currentScore > this.highScore) {\n              this.highScore = this.currentScore;\n              this.saveHighScore();\n            }\n            // Update level high score when game ends\n            if (this.levelManager.currentLevel > this.levelHighScore) {\n              this.levelHighScore = this.levelManager.currentLevel;\n              this.saveLevelHighScore();\n            }\n            this.gameState = GAME_STATES.GAME_OVER;\n          } else {\n            this.gameState = GAME_STATES.LIFE_LOST;\n          }\n          return false;\n        }\n        return true;\n      });\n\n      // Update coins\n      this.coins = this.coins.filter((coin) => {\n        return coin.update(currentTime);\n      });\n\n      // Update level manager\n      this.levelManager.update(currentTime, this.meteors);\n\n      // Check for level completion\n      if (this.levelManager.isLevelComplete(this.meteors)) {\n        if (this.levelManager.currentLevel >= LEVELS.length - 1) {\n          this.gameState = GAME_STATES.GAME_COMPLETE;\n        } else {\n          this.gameState = GAME_STATES.LEVEL_COMPLETE;\n        }\n      }\n    } else if (this.gameState === GAME_STATES.LIFE_LOST) {\n      // Pause the level timer\n      this.levelManager.pause();\n    }\n  }\n\n  drawCurrency() {\n    const currencyY = GAME_HEIGHT - PADDING_BOTTOM + UNIT * 15; // Position below game grid\n\n    this.ctx.fillStyle = COLORS.TEXT;\n    this.ctx.font = FONT.SMALL.full;\n    this.ctx.textAlign = \"center\";\n    this.ctx.letterSpacing = LETTER_SPACING;\n\n    // Draw currency centered below grid\n    this.ctx.fillText(\n      `${TEXTS.CURRENCY} $${this.currency}`,\n      GAME_WIDTH / 2,\n      currencyY,\n    );\n\n    // Level text centered below progress bar\n    this.ctx.fillText(\n      `${LEVELS[this.levelManager.currentLevel].name}`,\n      GAME_WIDTH / 2,\n      TEXT_TOP,\n    );\n\n    // Draw scores in top left corner\n    this.ctx.textAlign = \"left\";\n    this.ctx.fillText(\n      `${this.currentScore} ${TEXTS.SCORE}`,\n      PADDING_LEFT,\n      TEXT_TOP,\n    );\n\n    this.ctx.letterSpacing = \"0px\";\n  }\n\n  draw() {\n    this.drawBackground();\n\n    if (this.gameState === GAME_STATES.LOADING) {\n      this.drawLoadingScreen();\n    } else if (this.gameState === GAME_STATES.MENU) {\n      TextRenderer.drawTitle(this.ctx, {\n        title: TEXTS.TITLE,\n        subtitle: TEXTS.SUB_TITLE,\n        copy: TEXTS.INTRO,\n        color: COLORS.GAME_OVER_COLOR,\n      });\n\n      this.startButton.draw(this.ctx);\n      this.drawVersion();\n    } else if (this.gameState === GAME_STATES.PLAYING) {\n      this.drawDefenseGrid();\n\n      // Draw currency and lives\n      this.drawCurrency();\n      this.drawLives();\n      this.drawProgressBar(this.ctx);\n\n      // Draw defense options\n      this.defenseOptions.forEach((option) => {\n        option.draw(\n          this.ctx,\n          this.selectedDefense && option.type.id === this.selectedDefense.id,\n          this.currency,\n        );\n      });\n\n      // Draw meteors\n      this.meteors.forEach((meteor) => meteor.draw(this.ctx));\n\n      // Draw coins\n      const currentTime = performance.now();\n      this.coins.forEach((coin) => coin.draw(this.ctx, currentTime));\n\n      this.drawVersion();\n    } else if (this.gameState === GAME_STATES.LIFE_LOST) {\n      // Draw the life lost screen\n      this.drawCurrency();\n      this.drawLives();\n      this.drawProgressBar(this.ctx);\n\n      // Add semi-transparent overlay\n      this.ctx.fillStyle = \"rgba(0, 0, 0, 0.7)\";\n      this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n\n      TextRenderer.drawTitle(this.ctx, {\n        title: TEXTS.LIFE_LOST,\n        color: COLORS.GAME_OVER_COLOR,\n        subtitle: TEXTS.LIFE_REMAINING(this.lives),\n      });\n\n      this.continueButton.draw(this.ctx);\n    } else if (this.gameState === GAME_STATES.LEVEL_COMPLETE) {\n      TextRenderer.drawTitle(this.ctx, {\n        title: TEXTS.LEVEL_COMPLETE,\n        color: COLORS.SUCCESS_COLOR,\n      });\n      this.nextLevelButton.draw(this.ctx);\n    } else if (this.gameState === GAME_STATES.GAME_COMPLETE) {\n      TextRenderer.drawTitle(this.ctx, {\n        title: TEXTS.GAME_COMPLETE,\n        color: COLORS.SUCCESS_COLOR,\n        subtitle: `${TEXTS.SCORE}: ${this.currentScore} (${TEXTS.LEVEL} ${\n          this.levelManager.currentLevel + 1\n        })\n${TEXTS.HIGH_SCORE}: ${this.highScore} (${TEXTS.LEVEL} ${\n          this.levelHighScore + 1\n        })`,\n      });\n    } else if (this.gameState === GAME_STATES.GAME_OVER) {\n      TextRenderer.drawTitle(this.ctx, {\n        title: TEXTS.GAME_OVER,\n        color: COLORS.GAME_OVER_COLOR,\n        subtitle: `${TEXTS.SCORE}: ${this.currentScore} (${TEXTS.LEVEL} ${\n          this.levelManager.currentLevel + 1\n        })\n${TEXTS.HIGH_SCORE}: ${this.highScore} (${TEXTS.LEVEL} ${\n          this.levelHighScore + 1\n        })`,\n      });\n      this.retryButton.draw(this.ctx);\n    }\n  }\n\n  createDefenseOptions() {\n    const optionsAreaY = GAME_HEIGHT - PADDING_BOTTOM + UNIT * 30; // Move down to make room for currency\n    const spacing = UNIT * 20;\n    const totalWidth = (SPOT_SIZE + spacing) * DEFENSE_TYPES.length - spacing;\n    const startX = (GAME_WIDTH - totalWidth) / 2;\n\n    return DEFENSE_TYPES.map((type, index) => {\n      const x = startX + index * (SPOT_SIZE + spacing);\n      const y = optionsAreaY;\n      return new DefenseOption(type, x, y);\n    });\n  }\n\n  createDefenseGrid() {\n    const grid = [];\n\n    // Create 2D array for easier position reference\n    for (let row = 0; row < GRID_ROWS; row++) {\n      const rowArray = [];\n      for (let lane = 0; lane < LANES; lane++) {\n        const x = PADDING_LEFT + lane * LANE_WIDTH + LANE_WIDTH / 2;\n        const y =\n          GAME_HEIGHT - PADDING_BOTTOM - row * SPOT_SIZE - SPOT_SIZE / 2;\n        rowArray.push(new DefenseSpot(x, y, row, lane));\n      }\n      grid.push(rowArray);\n    }\n\n    return grid;\n  }\n\n  // Helper method to get spot at specific coordinates\n  getSpotAtPosition(x, y) {\n    for (let row = 0; row < this.defenseGrid.length; row++) {\n      for (let lane = 0; lane < this.defenseGrid[row].length; lane++) {\n        const spot = this.defenseGrid[row][lane];\n        if (\n          x >= spot.x - SPOT_SIZE / 2 &&\n          x <= spot.x + SPOT_SIZE / 2 &&\n          y >= spot.y - SPOT_SIZE / 2 &&\n          y <= spot.y + SPOT_SIZE / 2\n        ) {\n          return spot;\n        }\n      }\n    }\n    return null;\n  }\n\n  drawProgressBar(ctx) {\n    // Draw progress bar background\n    const barWidth = GAME_WIDTH - PADDING_LEFT - PADDING_RIGHT; // Leave some padding\n    const barHeight = UNIT * 20;\n    const x = PADDING_LEFT;\n    const y = UNIT * 20; // Padding from top\n\n    // Background\n    ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n    ctx.fillRect(x, y, barWidth, barHeight);\n\n    // Progress (inverted to show remaining time)\n    const progress = 1 - this.levelManager.getLevelProgress();\n    ctx.fillStyle = COLORS.PROGRESS_BAR;\n    ctx.fillRect(x, y, barWidth * progress, barHeight);\n\n    // Border\n    ctx.strokeStyle = COLORS.PROGRESS_BORDER;\n    ctx.lineWidth = UNIT * 2;\n    ctx.strokeRect(x, y, barWidth, barHeight);\n\n    // Time remaining\n    if (DEBUG) {\n      const timeLeft = Math.ceil(\n        (LEVELS[this.levelManager.currentLevel].duration -\n          (performance.now() - this.levelManager.levelStartTime)) /\n          1000,\n      );\n      if (timeLeft > 0) {\n        ctx.font = FONT.SMALL.full;\n        ctx.fillText(`${timeLeft}s`, GAME_WIDTH - 30, y + barHeight / 2 + 5);\n      }\n    }\n  }\n\n  async loadAssets() {\n    try {\n      const success = await this.assetLoader.loadAll();\n      if (success) {\n        this.gameState = GAME_STATES.MENU;\n      } else {\n        console.error(\"Failed to load assets\");\n      }\n    } catch (error) {\n      console.error(\"Error loading assets:\", error);\n    }\n  }\n\n  drawLoadingScreen() {\n    const progress = this.assetLoader.getLoadingProgress();\n\n    // draw black background\n    this.ctx.fillStyle = COLORS.BACKGROUND;\n    this.ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);\n\n    // Draw loading bar\n    const barWidth = GAME_WIDTH - PADDING_LEFT - PADDING_RIGHT; // Leave some padding\n    const barHeight = UNIT * 20;\n    const x = PADDING_LEFT;\n    const y = GAME_HEIGHT / 2;\n\n    // Background\n    this.ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n    this.ctx.fillRect(x, y, barWidth, barHeight);\n\n    // Progress\n    this.ctx.fillStyle = COLORS.PROGRESS_BAR;\n    this.ctx.fillRect(x, y, barWidth * progress, barHeight);\n\n    // Border\n    this.ctx.strokeStyle = COLORS.PROGRESS_BORDER;\n    this.ctx.lineWidth = UNIT * 2;\n    this.ctx.strokeRect(x, y, barWidth, barHeight);\n\n    // Loading text\n    this.ctx.fillStyle = COLORS.TEXT;\n    this.ctx.font = FONT.LARGE.full;\n    this.ctx.textAlign = \"center\";\n    this.ctx.fillText(\"Loading...\", GAME_WIDTH / 2, y - UNIT * 20);\n    this.ctx.fillText(\n      `${Math.floor(progress * 100)}%`,\n      GAME_WIDTH / 2,\n      y + UNIT * 40,\n    );\n  }\n\n  drawLives() {\n    const heartSize = UNIT * 17;\n    const spacing = UNIT * 5;\n    const startX =\n      GAME_WIDTH -\n      PADDING_LEFT -\n      heartSize / 2 -\n      (heartSize + spacing) * (INITIAL_LIVES - 1);\n    const y = PADDING_TOP + UNIT * 20;\n\n    // Draw hearts\n    for (let i = 0; i < INITIAL_LIVES; i++) {\n      const x = startX + (heartSize + spacing) * i;\n\n      // Draw empty heart outline\n      this.ctx.strokeStyle = COLORS.HEART_STROKE;\n      this.ctx.lineWidth = UNIT * 2;\n      this.drawHeart(x, y - heartSize / 2, heartSize);\n\n      // Fill heart if life is remaining\n      if (i < this.lives) {\n        this.ctx.fillStyle = COLORS.HEART_FILL;\n        this.drawHeart(x, y - heartSize / 2, heartSize, true);\n      }\n    }\n  }\n\n  // Helper method to draw a heart\n  drawHeart(x, y, size, fill = false) {\n    const path = new Path2D();\n    path.moveTo(x, y + size / 4);\n    path.bezierCurveTo(x, y, x - size / 2, y, x - size / 2, y + size / 4);\n    path.bezierCurveTo(\n      x - size / 2,\n      y + size / 2,\n      x,\n      y + (size * 3) / 4,\n      x,\n      y + (size * 3) / 4,\n    );\n    path.bezierCurveTo(\n      x,\n      y + (size * 3) / 4,\n      x + size / 2,\n      y + size / 2,\n      x + size / 2,\n      y + size / 4,\n    );\n    path.bezierCurveTo(x + size / 2, y, x, y, x, y + size / 4);\n\n    if (fill) {\n      this.ctx.fill(path);\n    } else {\n      this.ctx.lineCap = \"round\";\n      this.ctx.stroke(path);\n    }\n  }\n\n  // Add new method to continue playing\n  continuePlaying() {\n    this.gameState = GAME_STATES.PLAYING;\n    this.meteors = [];\n    // Resume the level timer\n    this.levelManager.resume();\n  }\n\n  // Add after constructor\n  loadHighScore() {\n    const saved = localStorage.getItem(STORAGE_KEY + \"_coins\");\n    return saved ? parseInt(saved, 0) : 0;\n  }\n\n  saveHighScore() {\n    localStorage.setItem(STORAGE_KEY + \"_coins\", this.highScore.toString());\n  }\n\n  // Add new method to draw version\n  drawVersion() {\n    this.ctx.globalAlpha = 0.5;\n    this.ctx.fillStyle = COLORS.TEXT;\n    this.ctx.font = FONT.TINY.full; // Smaller font size\n    this.ctx.textAlign = \"right\";\n    this.ctx.fillText(\n      `v${LEVEL_GEN_CONFIG.levelVersion}`,\n      GAME_WIDTH - UNIT * 5,\n      GAME_HEIGHT - UNIT * 5,\n    ); // Position in bottom left corner\n    this.ctx.globalAlpha = 1;\n  }\n\n  // Add new method to load level high score\n  loadLevelHighScore() {\n    const saved = localStorage.getItem(STORAGE_KEY + \"_level\");\n    return saved ? parseInt(saved, 0) : 0;\n  }\n\n  // Add new method to save level high score\n  saveLevelHighScore() {\n    localStorage.setItem(\n      STORAGE_KEY + \"_level\",\n      this.levelHighScore.toString(),\n    );\n  }\n\n  // Move initialization code to separate method\n  initializeGameProperties() {\n    // Create buttons\n    this.startButton = new Button(TEXTS.START_GAME);\n    this.retryButton = new Button(TEXTS.TRY_AGAIN);\n\n    // Initialize currency and defense options\n    this.currency = INITIAL_CURRENCY;\n    this.defenseOptions = this.createDefenseOptions();\n    this.selectedDefense = null;\n\n    // Initialize the defense grid\n    this.defenseGrid = this.createDefenseGrid();\n\n    this.levelManager = new LevelManager();\n\n    // Add new buttons\n    this.nextLevelButton = new Button(TEXTS.NEXT_LEVEL);\n\n    // Add new continue button\n    this.continueButton = new Button(TEXTS.CONTINUE);\n\n    // Add lives property\n    this.lives = INITIAL_LIVES;\n\n    // Add high score properties\n    this.currentScore = 0;\n    this.highScore = this.loadHighScore();\n\n    // Add level high score property\n    this.levelHighScore = this.loadLevelHighScore();\n\n    this.setupEventListeners();\n  }\n}\n\n// Start the game when the page loads\nwindow.addEventListener(\"load\", () => {\n  game = new Game();\n});\n"],"names":["$35da740d59af89ba$var$game","$35da740d59af89ba$var$GRID_ROWS","Math","floor","$35da740d59af89ba$var$GAME_AREA_HEIGHT","$35da740d59af89ba$var$LETTER_SPACING","$35da740d59af89ba$var$COLORS","BACKGROUND","TEXT","DEFENSE_OPTION_TEXT","DEFENSE_OPTION_TEXT_INACTIVE","BUTTON","BUTTON_TEXT","PROGRESS_BAR","PROGRESS_BORDER","DEFENSE_BACKGROUND","GRID_LINE","SELECTION","HEART_FILL","HEART_STROKE","GAME_OVER_COLOR","SUCCESS_COLOR","$35da740d59af89ba$var$TEXTS","TITLE","window","TXT","SUB_TITLE","INTRO","START_GAME","TRY_AGAIN","LIVES","LEVEL","SCORE","COINS","CURRENCY","HIGH_SCORE","LEVEL_COMPLETE","GAME_OVER","GAME_COMPLETE","LIFE_LOST","CONTINUE","NEXT_LEVEL","LIFE_REMAINING","lives","$35da740d59af89ba$var$LEVEL_GEN_CONFIG","levelVersion","baseDuration","durationIncrease","maxLevels","difficultyMultiplier","meteorWeights","start","small","medium","large","end","minSpawnGap","minSpawnGapEnd","maxSpawnGap","maxSpawnGapEnd","difficultyRamp","waveDuration","waveDurationEnd","waveGap","waveGapEnd","$35da740d59af89ba$var$LEVELS","$35da740d59af89ba$var$generateLevels","config","levels","diff","levelNum","duration","sqrt","meteors","currentTime","levelProgress","adjustedWaveDuration","waveEndTime","waveProgress","meteorType","$35da740d59af89ba$var$selectMeteorType","weights","random","lane","push","type","startTime","minGap","maxGap","name","sort","a","b","$35da740d59af89ba$var$GAME_STATES","LOADING","MENU","PLAYING","$35da740d59af89ba$var$DEFENSE_TYPES","id","color","cost","damage","health","$35da740d59af89ba$var$METEOR_TYPES","speed","$35da740d59af89ba$var$UNIT","damageRate","rotateRate","wiggleRate","wiggleAmount","sizeMultiplier","x","y","coinReward","$35da740d59af89ba$var$FONT","TINY","size","family","full","SMALL","LARGE","$35da740d59af89ba$var$AssetLoader","constructor","images","Map","fonts","totalAssets","loadedAssets","loadAll","fontPromises","loadFont","meteorPromises","$35da740d59af89ba$var$ASSETS","map","path","index","loadImage","defensePromises","backgroundPromise","Promise","all","error","console","key","src","resolve","reject","img","Image","onload","set","onerror","Error","getImage","get","getLoadingProgress","fontFamily","url","fontFace","FontFace","loadedFont","load","document","add","$35da740d59af89ba$var$Meteor","isBlocked","blockingDefense","baseRotation","wiggleRotation","wiggleOffset","baseX","$35da740d59af89ba$var$PADDING_LEFT","$35da740d59af89ba$var$GAME_AREA_WIDTH","$35da740d59af89ba$var$LANE_WIDTH","update","deltaTime","cos","block","defense","unblock","draw","ctx","wiggleX","sin","meteorImage","assetLoader","save","translate","rotate","height","$35da740d59af89ba$var$METEOR_SIZE","width","drawImage","restore","fillStyle","beginPath","arc","PI","fill","takeDamage","$35da740d59af89ba$var$Button","text","backgroundColor","textColor","fontSize","$35da740d59af89ba$var$GAME_WIDTH","$35da740d59af89ba$var$GAME_HEIGHT","$35da740d59af89ba$var$BUTTON_WIDTH","isClicked","clickX","clickY","fillRect","font","textAlign","textBaseline","letterSpacing","fillText","$35da740d59af89ba$var$Projectile","checkCollision","meteor","meteorX","dx","dy","distance","isOffScreen","$35da740d59af89ba$var$Defense","maxHealth","projectiles","lastFireTime","fireRate","blockingMeteors","isEmpty","amount","coins","defenseRow","forEach","m","filter","projectile","i","length","$35da740d59af89ba$var$Coin","splice","isSelected","isInactive","strokeStyle","lineWidth","strokeRect","defenseImage","globalAlpha","max","$35da740d59af89ba$var$DefenseOption","currentCurrency","$35da740d59af89ba$var$SPOT_SIZE","$35da740d59af89ba$var$DefenseSpot","row","placeDefense","defenseType","removeDefense","value","lifetime","createTime","performance","now","hitRadius","angle","vx","vy","waveAmplitude","waveFrequency","waveOffset","baseY","time","age","remainingTime","coinX","coinY","gradient","createRadialGradient","addColorStop","stroke","$35da740d59af89ba$var$LevelManager","currentLevel","levelStartTime","remainingMeteors","allMeteorsSpawned","pauseStartTime","totalPausedTime","startLevel","levelIndex","levelTime","level","meteorData","shift","isLevelComplete","getLevelProgress","adjustedTime","min","pause","resume","$35da740d59af89ba$var$STORAGE_KEY","$35da740d59af89ba$var$TextRenderer","drawTitle","title","subtitle","copy","titleLineHeight","subtitleLineHeight","copyLineHeight","titleLines","split","titleStartY","line","subtitleLines","copyLines","$35da740d59af89ba$var$Game","canvas","getElementById","getContext","lastTime","gameState","initializeCanvas","addEventListener","initializeGameProperties","requestAnimationFrame","timestamp","gameLoop","loadAssets","scale","viewportWidth","innerWidth","viewportHeight","innerHeight","viewportAspectRatio","style","setupEventListeners","e","rect","getBoundingClientRect","clientX","left","clientY","top","startButton","startGame","retryButton","nextLevelButton","startNextLevel","coinCollected","coin","currency","currentScore","defenseOptions","option","selectedDefense","log","spot","getSpotAtPosition","continueButton","continuePlaying","levelManager","defenseGrid","clearRect","drawBackground","bgImage","drawDefenseGrid","highScore","saveHighScore","levelHighScore","saveLevelHighScore","drawCurrency","$35da740d59af89ba$var$PADDING_TOP","drawLoadingScreen","drawVersion","drawLives","drawProgressBar","createDefenseOptions","startX","createDefenseGrid","grid","rowArray","progress","barWidth","heartSize","drawHeart","Path2D","moveTo","bezierCurveTo","lineCap","loadHighScore","saved","localStorage","getItem","parseInt","setItem","toString","loadLevelHighScore"],"version":3,"file":"neo.a4f7df0f.js.map"}